<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="待葡萄成熟透">
  <meta name="keyword" content="">
  
    <link rel="shortcut icon" type="image/ico" href="/抱抱.png"/>
  
  <title>
    
      面试 | js | Ydl&#39;s Blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
<meta name="generator" content="Hexo 5.3.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Ydl's Blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>面试 | js</h2>
  <p class="post-date">2022-01-18</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p><code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>null</code>、<code>undefined</code>、<code>Symbol</code>、<code>BigInt</code></p>
<h5 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a><code>Symbol</code></h5><p>在ES6中新引入的一种数据类型，用来表示“独一无二”的值，可以用作<strong>对象属性的唯一标识符</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> info1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;波吉&#x27;</span>,</span><br><span class="line">  description: <span class="string">&#x27;又善良又可爱&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> info2 = &#123;</span><br><span class="line">  description: <span class="string">&#x27;排名第一的国王&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在想要汇总这两个对象为<code>info</code>，使用<code>Object.assign(&#123;&#125;, info1, info2)</code>，后一个描述会覆盖掉前一个描述，使用<code>Symbol</code>进行改写就可以了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> info1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;波吉&#x27;</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&#x27;description&#x27;</span>)]: <span class="string">&#x27;又善良又可爱&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> info2 = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&#x27;description&#x27;</span>)]: <span class="string">&#x27;排名第一的国王&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> info = <span class="built_in">Object</span>.assign(&#123;&#125;, info1, info2);</span><br><span class="line"><span class="keyword">let</span> t = <span class="built_in">Object</span>.getOwnPropertySymbols(info);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;t.length; i++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(t[i], info[t[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Symbol(description) &#x27;又善良又可爱&#x27;</span></span><br><span class="line"><span class="comment">// Symbol(description) &#x27;排名第一的国王&#x27;</span></span><br></pre></td></tr></table></figure>
<p>其实<code>Symbol</code>里面的参数是可有可无的；本质上是生成了一个唯一的属性，所以汇总的时候不会覆盖</p>
<p>除此之外，不能通过<code>info[Symbol(&#39;description&#39;)]</code>来访问<code>info1</code>和<code>info2</code>里的描述，因为这种写法相当于又给<code>info</code>添加了一个唯一的属性，必须通过<code>Object.getOwnPropertySymbols(info)</code>来获取属性列表，进而取到对应的值</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> t = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> info = &#123;</span><br><span class="line">name: <span class="string">&#x27;波吉&#x27;</span>,</span><br><span class="line">t: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">[t]: <span class="string">&#x27;又善良又可爱&#x27;</span>, <span class="comment">// 变量做属性要加方括号</span></span><br><span class="line">&#125;;</span><br><span class="line">info.t  <span class="comment">// &#x27;1&#x27;</span></span><br><span class="line">info[<span class="string">&#x27;t&#x27;</span>] <span class="comment">// &#x27;1&#x27;</span></span><br><span class="line">info[t] <span class="comment">// &#x27;又善良又可爱&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p><code>Object</code>、<code>Array</code>、<code>Function</code></p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>存储位置不同</p>
<h3 id="2-检测数据类型"><a href="#2-检测数据类型" class="headerlink" title="2. 检测数据类型"></a>2. 检测数据类型</h3><p><strong>Object.prototype.toString.call</strong>：Array、Function等重写了toString，所以得用Object.prototype.toString.call而不是toString</p>
<p><strong>instanceof</strong></p>
<p><strong>constructor</strong></p>
<p><strong>typeof</strong>：用来判断除了object（包括null）的基本数据类型</p>
<h3 id="3-判断是否是数组"><a href="#3-判断是否是数组" class="headerlink" title="3. 判断是否是数组"></a>3. 判断是否是数组</h3><ul>
<li><code>Object.prototype.toString.call(obj)</code></li>
<li><code>obj instanceof Array</code></li>
<li><code>Array.isArray(obj)</code></li>
<li><code>obj.__proto__ === Array.prototype</code></li>
<li><code>Array.prototype.isPrototypeOf(obj)</code></li>
</ul>
<h3 id="4-null和undefined区别"><a href="#4-null和undefined区别" class="headerlink" title="4. null和undefined区别"></a>4. null和undefined区别</h3><p>undefined表示未定义，例如声明了但还没有定义的变量的值是undefined；null表示空对象，例如<code>Object.prototype.__proto</code>__是null表示已经到头了</p>
<p>undefined不是保留字，可以用作变量名；null是保留字</p>
<blockquote>
<p>可以通过void 0来获取undefined</p>
</blockquote>
<h3 id="5-typeof-null的结果"><a href="#5-typeof-null的结果" class="headerlink" title="5. typeof null的结果"></a>5. typeof null的结果</h3><p>Object</p>
<p>null的底层存储全是0，而000的类型标签刚好表示对象</p>
<h3 id="6-为什么0-1-0-2-0-3"><a href="#6-为什么0-1-0-2-0-3" class="headerlink" title="6. 为什么0.1+0.2!==0.3"></a>6. 为什么0.1+0.2!==0.3</h3><p>因为0.1和0.2在底层双精度浮点数的二进制存储都是无限循环，相加存在误差</p>
<p>可以通过Number.EPSILON进行修正</p>
<h3 id="7-和-amp-amp-的返回值"><a href="#7-和-amp-amp-的返回值" class="headerlink" title="7. ||和&amp;&amp;的返回值"></a>7. ||和&amp;&amp;的返回值</h3><ul>
<li>对于 || ，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值</li>
<li>&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值</li>
</ul>
<h3 id="8-判断相等的方法"><a href="#8-判断相等的方法" class="headerlink" title="8. 判断相等的方法"></a>8. 判断相等的方法</h3><p>使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较</p>
<p>使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false</p>
<p>使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的</p>
<h3 id="9-包装类型"><a href="#9-包装类型" class="headerlink" title="9. 包装类型"></a>9. 包装类型</h3><p>在调用基本类型的属性或方法时，隐式地将基本类型转换为对象</p>
<h4 id="装包"><a href="#装包" class="headerlink" title="装包"></a>装包</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="built_in">Object</span>(a);</span><br></pre></td></tr></table></figure>
<h4 id="拆包"><a href="#拆包" class="headerlink" title="拆包"></a>拆包</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line">a.valueOf();</span><br></pre></td></tr></table></figure>
<h3 id="10-隐式类型转换"><a href="#10-隐式类型转换" class="headerlink" title="10. 隐式类型转换"></a>10. 隐式类型转换</h3><p>如果变量是基本类型，那么直接返回</p>
<p>对于对象，使用ToPrimitive方法</p>
<p>如果是对象，那么先toString，再valueOf，如果中间有基本类型就返回，没有就报错</p>
<p>如果是Date，那么先valueOf，再toString，如果中间有基本类型就返回，没有就报错</p>
<h3 id="11-拷贝"><a href="#11-拷贝" class="headerlink" title="11. 拷贝"></a>11. 拷贝</h3><p>每个数据都会占有一块内存，通过变量来访问；如果拷贝之后的不同变量访问的是同一块内存，这种方式就是浅拷贝；如果是开辟了一块新的内存来拷贝的话，不同变量访问的就不是同一块内存，就是深拷贝</p>
<p>拷贝基本数据类型，例如<code>Number</code>、<code>String</code>都是浅拷贝，深浅拷贝只针对对象，例如<code>Array</code>、<code>Object</code></p>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p><strong>1.直接用<code>=</code></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  name: <span class="string">&#x27;波吉&#x27;</span>,</span><br><span class="line">  rank: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">b.rank = <span class="number">10086</span>;</span><br><span class="line">a.rank <span class="comment">/*10086*/</span></span><br><span class="line">b === a <span class="comment">/* true */</span></span><br></pre></td></tr></table></figure>
<p><strong>2.<code>Object.assign</code></strong></p>
<p>该方法可以把任意多个源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象；拷贝的是<strong>对象属性</strong>而不是对象本身</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  name: <span class="string">&#x27;波吉&#x27;</span>,</span><br><span class="line">  rank: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 如果a是数组的话就是Object.assign([] ,a) */</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a);</span><br><span class="line">a === b <span class="comment">/* false */</span></span><br></pre></td></tr></table></figure>
<p>像上面这个例子，<code>a</code>里面的属性都是基础数据类型，所以使用该方法之后就相当于深拷贝，但如果<code>a</code>里面的属性是对象的话，那么只是拷贝了引用；如果<code>a</code>是数组的话也是很类似的，看数组元素是数字还是对象，如果是数字就是深拷贝，对象就是浅拷贝</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  name: <span class="string">&#x27;波吉&#x27;</span>,</span><br><span class="line">  friends: &#123;</span><br><span class="line">    name1: <span class="string">&#x27;卡克&#x27;</span>,</span><br><span class="line">    name2: <span class="string">&#x27;snake&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a);</span><br><span class="line">b.name = <span class="string">&#x27;ydl&#x27;</span>;</span><br><span class="line">b.friends.name2 = <span class="string">&#x27;蛇&#x27;</span>;</span><br><span class="line"><span class="comment">/* a为 &#123;</span></span><br><span class="line"><span class="comment">  name: &#x27;波吉&#x27;,</span></span><br><span class="line"><span class="comment">  friends: &#123;</span></span><br><span class="line"><span class="comment">    name1: &#x27;卡克&#x27;,</span></span><br><span class="line"><span class="comment">    name2: &#x27;蛇&#x27;</span></span><br><span class="line"><span class="comment">  &#125;  </span></span><br><span class="line"><span class="comment">&#125; */</span></span><br></pre></td></tr></table></figure>
<p><strong><code>3.扩展运算符...</code></strong></p>
<p>和<code>Object.assign</code>很类似，也是对对象属性或数组元素进行拷贝</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  name: <span class="string">&#x27;波吉&#x27;</span>,</span><br><span class="line">  friends: &#123;</span><br><span class="line">    name1: <span class="string">&#x27;卡克&#x27;</span>,</span><br><span class="line">    name2: <span class="string">&#x27;snake&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> b =&#123;</span><br><span class="line">  ...a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-let、const、var的区别"><a href="#12-let、const、var的区别" class="headerlink" title="12. let、const、var的区别"></a>12. let、const、var的区别</h3><p><strong>块级作用域</strong>、<strong>变量提升</strong>、<strong>重复声明</strong>、<strong>初始值设置</strong>、<strong>指针指向</strong></p>
<h3 id="13-箭头函数与普通函数的区别"><a href="#13-箭头函数与普通函数的区别" class="headerlink" title="13. 箭头函数与普通函数的区别"></a>13. 箭头函数与普通函数的区别</h3><p>箭头函数没有自己的this，箭头函数里的this指向不会通过call、apply、bind等方法改变</p>
<p>箭头函数不能作为构造函数，因为new的第二步需要将函数中的this指向创建的对象，但是箭头函数没有this，且不能改变指向，所以不能</p>
<p>箭头函数没有argument</p>
<p>箭头函数没有prototype</p>
<h3 id="14-Map和Object"><a href="#14-Map和Object" class="headerlink" title="14. Map和Object"></a>14. Map和Object</h3><p>都是键值对的集合</p>
<p>map的key是有序的，迭代时以插入的顺序返回键值；object的则是无序的</p>
<p>map的key可以是任意值；object的则必须是String或Symbol</p>
<p>map默认不包含任何键；object有一个原型，原型上的键名可能和自己设置的冲突</p>
<h3 id="15-JSON"><a href="#15-JSON" class="headerlink" title="15. JSON"></a>15. JSON</h3><p>JSON 是一种轻量级的数据交换格式，基于js ，但是JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如 JSON 中属性值不能为函数、NaN等，因此大多数的 js 对象是不符合 JSON 对象的格式的。</p>
<p><code>JSON.stringfy</code>用来js对象转JSON字符串</p>
<p><code>JSON.parse</code>用来JSON字符串转js对象</p>
<h3 id="16-js脚本延迟加载的方式"><a href="#16-js脚本延迟加载的方式" class="headerlink" title="16. js脚本延迟加载的方式"></a>16. js脚本延迟加载的方式</h3><p><strong>defer属性：</strong> 让脚本的请求加载与文档的解析同步，然后在文档解析完成后再执行这个脚本文件</p>
<p><strong>async属性：</strong> 使脚本异步请求加载，不会阻塞页面的解析过程，但是脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞</p>
<p><strong>动态创建 DOM 方式：</strong> 对文档的加载事件进行监听，当文档加载完成后再创建 script 标签来引入 js 脚本</p>
<p><strong>setTimeout</strong></p>
<h3 id="17-DOM和BOM"><a href="#17-DOM和BOM" class="headerlink" title="17. DOM和BOM"></a>17. DOM和BOM</h3><p>DOM 指的是文档对象模型，把文档当做一个对象</p>
<p>BOM 指的是浏览器对象模型，把浏览器当做一个对象来对待，核心是 window，具有双重角色，既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象</p>
<h3 id="18-ES6模块和commonJS模块的异同"><a href="#18-ES6模块和commonJS模块的异同" class="headerlink" title="18. ES6模块和commonJS模块的异同"></a>18. ES6模块和commonJS模块的异同</h3><p>CommonJS的 <code>require</code> 语法是同步的，当我们使用<code>require</code> 加载一个模块的时候，必须要等这个模块加载完后，才会执行后面的代码，在浏览器端文件一般存放在服务器或者CDN上，如果使用同步的方式加载一个模块还需要由网络来决定快慢，很容易进入“假死状态”</p>
<ul>
<li>CommonJS模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</li>
<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</li>
<li>对于循环引用，CommonJS 输出的是当前已经执行那部分的值，而不是代码全部执行后的值，ES6 模块是动态引用，变量不会被缓存，真正取值的时候就能取到最终的值</li>
</ul>
<h3 id="19-解释型语言和编译型语言的区别"><a href="#19-解释型语言和编译型语言的区别" class="headerlink" title="19. 解释型语言和编译型语言的区别"></a>19. 解释型语言和编译型语言的区别</h3><ul>
<li>解释型每次运行都需要解释源代码，效率较低；编译型一次性编译成平台相关的机器语言文件，以后在运行时，直接运行编译结果即可</li>
<li>解释型只要平台提供相应的解释器，就可以运行源代码，所以移植性更好；编译型与特定平台相关，一般无法移植到其他平台</li>
</ul>
<h3 id="20-for-in和for-of的区别"><a href="#20-for-in和for-of的区别" class="headerlink" title="20. for in和for of的区别"></a>20. for in和for of的区别</h3><ul>
<li>for… of 遍历获取的是对象的键值，for…in 获取的是对象的键名</li>
<li>for… in 会遍历对象的整个原型链，而 for … of 只遍历当前对象不会遍历原型链</li>
<li>for in可以搭配hasOwnProperty来实现只遍历当前对象</li>
</ul>
<h3 id="21-原型与原型链"><a href="#21-原型与原型链" class="headerlink" title="21. 原型与原型链"></a>21. 原型与原型链</h3><p>原型：每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了所有创建的实例可以共享的属性和方法</p>
<p>原型链：当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么就去原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去</p>
<h3 id="22-闭包-作用域-作用域链"><a href="#22-闭包-作用域-作用域链" class="headerlink" title="22. 闭包/作用域/作用域链"></a>22. 闭包/作用域/作用域链</h3><p>指有权访问另一个函数作用域中变量的函数</p>
<p>全局作用域、函数作用域、块级作用域</p>
<p><strong>作用域链：</strong> 在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链</p>
<h3 id="23-执行上下文"><a href="#23-执行上下文" class="headerlink" title="23. 执行上下文"></a>23. 执行上下文</h3><p>当js执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文</p>
<h3 id="24-实现继承的方式"><a href="#24-实现继承的方式" class="headerlink" title="24. 实现继承的方式"></a>24. 实现继承的方式</h3><p><strong>原型链继承</strong>：将父类实例作为子类的原型</p>
<p><code>Student.prototype=new Person();</code></p>
<p>缺点：</p>
<ul>
<li>无法实现多继承</li>
<li>所有新实例都会共享父类实例、原型链上的属性和方法</li>
<li>子构造函数的constructor指向错误，需要额外<code>Student.prototype.constructor=Student;</code></li>
</ul>
<p><strong>构造函数继承</strong>：在一个类中执行另一个类的构造函数，通过<code> call</code>函数设置<code> this</code>的指向，这样就可以得到另一个类的所有属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, grade, site</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="built_in">this</span>, name)</span><br><span class="line">  WebsiteMaster.call(<span class="built_in">this</span>, site)</span><br><span class="line">  <span class="built_in">this</span>.grade = grade</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点：</p>
<ul>
<li>只能继承父类的实例属性，不能继承父类原型上的属性、方法</li>
<li>实例并不是父类的实例，而只是子类的实例</li>
</ul>
<p><strong>寄生组合式</strong>：通过<code> Object.create()</code>来代替给子类原型赋值的过程，解决了两次调用父类构造函数的问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, grade, site</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="built_in">this</span>, name)            <span class="comment">// 继承属性</span></span><br><span class="line">  WebsiteMaster.call(<span class="built_in">this</span>, site)</span><br><span class="line">  <span class="built_in">this</span>.grade = grade</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype)        <span class="comment">// 继承方法</span></span><br><span class="line">Student.prototype.constructor = Student   <span class="comment">// 修复构造函数指向</span></span><br></pre></td></tr></table></figure>
<h3 id="25-垃圾回收"><a href="#25-垃圾回收" class="headerlink" title="25. 垃圾回收"></a>25. 垃圾回收</h3><p>垃圾回收是指收回已经不再参与运行的变量所占用的内存空间</p>
<h3 id="3-对象拷贝"><a href="#3-对象拷贝" class="headerlink" title="3. 对象拷贝"></a>3. 对象拷贝</h3><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p><strong>1.把对象转换成JSON字符串再转换回来</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">name</span>: &#123; <span class="attr">a</span>: <span class="string">&quot;波吉&quot;</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1));</span><br></pre></td></tr></table></figure>
<p>能处理的数据只有能够被<code>json</code>直接表示的结构；当遇到循环引用的对象时会报错；当遇到函数、<code>undefined</code>、<code>symbol</code>时，如果这些是作为<strong>对象属性</strong>来<code>stringfy</code>，那么直接忽略；如果是作为<strong>数组元素</strong>，那么为<code>null</code>，如果<strong>单独</strong>拿来<code>stringfy</code>，则是<code>undefined</code></p>
<blockquote>
<p>循环引用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">  b: obj1</span><br><span class="line">&#125;;</span><br><span class="line">obj1.a = obj2;</span><br></pre></td></tr></table></figure>

<img src="https://ydl8023.oss-cn-beijing.aliyuncs.com/20220118164344.png" width="50%" />
</blockquote>
<p><strong>2.递归拷贝</strong></p>
<p><code>Reflect.ownKeys()</code>方法返回一个由目标对象自身的属性组成的数组，不包括原型链上继承的属性；考虑了<code>Symbol</code>、<code>undefined</code>、函数<br><code>for in</code>方法会考虑对象原型链上的继承的属性、<code>undefined</code>、函数，但是没考虑<code>Symbol</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> deepClone=<span class="function"><span class="params">target</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> target!==<span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> cloneTarget=<span class="built_in">Array</span>.isArray(target)?[]:&#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(target))&#123;</span><br><span class="line">    cloneTarget[key]=deepClone(target[key]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneTarget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-new运算符"><a href="#4-new运算符" class="headerlink" title="4. new运算符"></a>4. new运算符</h2><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> boji = <span class="keyword">new</span> Person(<span class="string">&#x27;波吉&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>以上面代码为例，<code>new Person(&#39;波吉&#39;)</code>可以解析为以下步骤</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.__proto__ = Person.prototype; </span><br><span class="line"><span class="keyword">var</span> result = Person.call(obj, <span class="string">&#x27;波吉&#x27;</span>)； </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> ? result||obj : obj;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>创建一个继承自<code>Person.prototype</code>的空对象</p>
</li>
<li><p>将构造函数中的<code>this</code>指向<code>obj</code>，并传递参数’波吉’调用构造函数；执行完毕后，<code>obj</code>多了一个属性<code>name</code>，并且其值为波吉</p>
</li>
<li><p>返回对象给变量<code>boji</code></p>
</li>
</ol>
<blockquote>
<ul>
<li>如果构造函数本身返回了一个对象，那么<code>new</code>操作符返回的就是构造函数的返回值</li>
<li>如果构造函数返回的不是对象（例如<code>null</code>，<code>undefined</code>；虽然<code>null</code>是基本数据类型，但是<code>typeof</code>确是<code>object</code>）或者啥也没返回，那么<code>new</code>返回的就是继承自<code>Person.prototype</code>的新对象</li>
</ul>
</blockquote>
<h4 id="手写实现"><a href="#手写实现" class="headerlink" title="手写实现"></a>手写实现</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 法一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  cons = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">  obj.__proto__ = cons.prototype;</span><br><span class="line">  <span class="keyword">var</span> result = cons.apply(obj, [].slice.call(<span class="built_in">arguments</span>).slice(<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> ? result || obj : obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 法二 更优雅</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objGenerator</span>(<span class="params">cons, ...arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  obj.__proto__ = cons.prototype;</span><br><span class="line">  <span class="keyword">var</span> result = cons.apply(obj, arg);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> ? result || obj : obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = objGenerator(Person, <span class="string">&#x27;波吉&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="5-apply、call、bind异同"><a href="#5-apply、call、bind异同" class="headerlink" title="5. apply、call、bind异同"></a>5. <code>apply</code>、<code>call</code>、<code>bind</code>异同</h2><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><p>这三个函数都是<code> Function</code>原型上的方法 <code>Function.prototype.call()</code>，<code>Function.prototype.apply</code>，<code>Function.prototype.bind()</code>，因此所有的函数可以调用这三个方法。</p>
<p>三个函数的第一个参数都是必选的，表示<code>this</code>的指向，如果不需要指定<code>this</code>的指向，第一个参数可以为<code>null</code></p>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p>函数调用<code>apply</code>、<code>call</code>时的返回值就是函数本身的返回值，而调用<code>bind</code>返回值是一个新的函数</p>
<p><code>apply</code>接受的是一个参数数组，而<code>call</code>是多个参数</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#面试" >
    <span class="tag-code">面试</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/posts/30446/">
        <span class="nav-arrow">← </span>
        
          📖算法 | 剑指offer
        
      </a>
    
    
      <a class="nav-right" href="/posts/44262/">
        
          2021总结
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-nav-text">1. 数据类型</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-nav-text">基本类型</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Symbol"><span class="toc-nav-text">Symbol</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-nav-text">引用数据类型</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-nav-text">区别</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-%E6%A3%80%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-nav-text">2. 检测数据类型</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E6%95%B0%E7%BB%84"><span class="toc-nav-text">3. 判断是否是数组</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#4-null%E5%92%8Cundefined%E5%8C%BA%E5%88%AB"><span class="toc-nav-text">4. null和undefined区别</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#5-typeof-null%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="toc-nav-text">5. typeof null的结果</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#6-%E4%B8%BA%E4%BB%80%E4%B9%880-1-0-2-0-3"><span class="toc-nav-text">6. 为什么0.1+0.2!&#x3D;&#x3D;0.3</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#7-%E5%92%8C-amp-amp-%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-nav-text">7. ||和&amp;&amp;的返回值</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#8-%E5%88%A4%E6%96%AD%E7%9B%B8%E7%AD%89%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-nav-text">8. 判断相等的方法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#9-%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="toc-nav-text">9. 包装类型</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E8%A3%85%E5%8C%85"><span class="toc-nav-text">装包</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%8B%86%E5%8C%85"><span class="toc-nav-text">拆包</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#10-%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-nav-text">10. 隐式类型转换</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#11-%E6%8B%B7%E8%B4%9D"><span class="toc-nav-text">11. 拷贝</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-nav-text">浅拷贝</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#12-let%E3%80%81const%E3%80%81var%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-nav-text">12. let、const、var的区别</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#13-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-nav-text">13. 箭头函数与普通函数的区别</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#14-Map%E5%92%8CObject"><span class="toc-nav-text">14. Map和Object</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#15-JSON"><span class="toc-nav-text">15. JSON</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#16-js%E8%84%9A%E6%9C%AC%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-nav-text">16. js脚本延迟加载的方式</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#17-DOM%E5%92%8CBOM"><span class="toc-nav-text">17. DOM和BOM</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#18-ES6%E6%A8%A1%E5%9D%97%E5%92%8CcommonJS%E6%A8%A1%E5%9D%97%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-nav-text">18. ES6模块和commonJS模块的异同</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#19-%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-nav-text">19. 解释型语言和编译型语言的区别</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#20-for-in%E5%92%8Cfor-of%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-nav-text">20. for in和for of的区别</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#21-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-nav-text">21. 原型与原型链</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#22-%E9%97%AD%E5%8C%85-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-nav-text">22. 闭包&#x2F;作用域&#x2F;作用域链</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#23-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-nav-text">23. 执行上下文</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#24-%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-nav-text">24. 实现继承的方式</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#25-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-nav-text">25. 垃圾回收</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3-%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D"><span class="toc-nav-text">3. 对象拷贝</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-nav-text">深拷贝</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-new%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-nav-text">4. new运算符</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-nav-text">执行过程</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0"><span class="toc-nav-text">手写实现</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-apply%E3%80%81call%E3%80%81bind%E5%BC%82%E5%90%8C"><span class="toc-nav-text">5. apply、call、bind异同</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="toc-nav-text">相同点</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="toc-nav-text">不同点</span></a></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://ydl8686.github.io/posts/55448/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2023 | Article by <a target="_blank" rel="noopener" href="https://github.com/ydl8686">ydl</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'false';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>

  </body>
</html>