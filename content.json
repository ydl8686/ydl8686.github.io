{"meta":{"title":"Ydl's Blog","subtitle":null,"description":"待葡萄成熟透","author":"Ydl","url":"http://ydl8686.github.io","root":"/"},"pages":[{"title":"About","date":"2023-02-18T01:46:09.145Z","updated":"2021-05-06T12:20:17.861Z","comments":true,"path":"about/index.html","permalink":"http://ydl8686.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2023-02-18T01:46:09.255Z","updated":"2021-02-18T11:21:06.931Z","comments":true,"path":"photos/README.html","permalink":"http://ydl8686.github.io/photos/README.html","excerpt":"","text":"Blog-Back-Up存储博客照片"},{"title":"","date":"2023-02-18T01:46:09.250Z","updated":"2021-02-18T11:22:01.123Z","comments":true,"path":"photos/data.json","permalink":"http://ydl8686.github.io/photos/data.json","excerpt":"","text":"{\"list\":[{\"date\":\"2021-2-\",\"arr\":{\"year\":2021,\"month\":2,\"link\":[\"2021-2-17_狼小魂大大.JPG\",\"2021-2-18_最近真的很爱浩浩和介叔啊.JPG\",\"2021-2-18_要吃冰淇淋么.JPG\"],\"text\":[\"狼小魂大大\",\"最近真的很爱浩浩和介叔啊\",\"要吃冰淇淋么\"],\"type\":[\"image\",\"image\",\"image\"]}}]}"},{"title":"","date":"2023-02-18T01:46:09.272Z","updated":"2021-02-18T08:39:30.229Z","comments":true,"path":"photos/ins.css","permalink":"http://ydl8686.github.io/photos/ins.css","excerpt":"","text":"#post-instagram{ padding: 30px; } #post-instagram .article-entry{ padding-right: 0; } .instagram{ background-color:#F5FFFF; position: relative; min-height: 500px; } .instagram img { width: 100%; } .instagram .year { font-size: 16px; } .instagram .open-ins{ padding: 10px 0; color: #cdcdcd; } .instagram .open-ins:hover{ color: #657b83; } .instagram .year{ display: inline; } .instagram .thumb { width: 25%; height: 0; padding-bottom: 25%; position: relative; display: inline-block; text-align: center; background: #ededed; outline: 1px solid #ddd; } .instagram .thumb a { position: relative; } .instagram .album h1 em{ font-style: normal; font-size: 14px; margin-left: 10px; } .instagram .album ul{ display: flex; flex-wrap: wrap; clear: both; width: 100%; text-align: left; } .instagram .album li{ list-style: none; display: inline-block; box-sizing: border-box; padding: 0 5px; margin-bottom: -10px; height: 0; width: 25%; position: relative; padding-bottom: 25%; } .instagram .album li:before{ display: none; } .instagram .album div.img-box{ position: absolute; width: 90%; height: 90%; -webkit-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); -moz-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); } .instagram .album div.img-box img{ width: 100%; height: 100%; position: absolute; z-index: 2; } .instagram .album div.img-box .img-bg{ position: absolute; top: 0; left: 0; bottom: 0px; width: 100%; margin: -5px; padding: 5px; -webkit-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -moz-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -webkit-transition: all 0.15s ease-out 0.1s; -moz-transition: all 0.15s ease-out 0.1s; -o-transition: all 0.15s ease-out 0.1s; transition: all 0.15s ease-out 0.1s; opacity: 0.2; cursor: pointer; display: block; z-index: 3; } .instagram .album div.img-box .icon { font-size: 14px; position: absolute; left: 50%; top: 50%; margin-left: -7px; margin-top: -7px; color: #999; z-index: 1; } .instagram .album div.img-box .img-bg:hover{ opacity: 0; } .photos-btn-wrap { border-bottom: 1px solid #e5e5e5; margin-bottom: 20px; } .photos-btn { font-size: 16px; color: #333; margin-bottom: -4px; padding: 5px 8px 3px; } .photos-btn.active { color: #08c; border: 1px solid #e5e5e5; border-bottom: 5px solid #fff; } @media screen and (max-width:600px) { .instagram .thumb { width: 50%; padding-bottom: 50%; } .instagram .album li { width: 100%; position: relative; padding-bottom: 100%; text-align: center; } .instagram .album div.img-box{ margin: 0; width: 90%; height: 90%; } }"},{"title":"相册","slug":"photos","date":"2023-02-18T01:46:09.212Z","updated":"2022-12-31T04:05:37.209Z","comments":false,"path":"photos/index.html","permalink":"http://ydl8686.github.io/photos/index.html","excerpt":"","text":"Photos 图片正在加载中… (function() { var loadScript = function(path) { var $script = document.createElement('script') document.getElementsByTagName('body')[0].appendChild($script) $script.setAttribute('src', path) } setTimeout(function() { loadScript('./ins.js') }, 0) })()"},{"title":"","date":"2023-02-18T01:46:09.220Z","updated":"2021-02-18T08:39:30.229Z","comments":true,"path":"photos/ins.js","permalink":"http://ydl8686.github.io/photos/ins.js","excerpt":"","text":"/******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports; /******/ /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ exports: {}, /******/ id: moduleId, /******/ loaded: false /******/ }; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.loaded = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = \"/dist/\"; /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(0); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(1); var _view = __webpack_require__(2); var _view2 = _interopRequireDefault(_view); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } /** * @name impush-client * @description 这个项目让我发家致富… * @date 2016-12-1 */ var _collection = []; var _count = 0; var searchData; function addMask(elem) { var rect = elem.getBoundingClientRect(); var style = getComputedStyle(elem, null); var mask = document.createElement('i'); mask.className = 'icon-film'; mask.style.color = '#fff'; mask.style.fontSize = '26px'; mask.style.position = 'absolute'; mask.style.right = '10px'; mask.style.bottom = '10px'; mask.style.zIndex = 1; elem.parentNode.appendChild(mask); } var createVideoIncon = function createVideoIncon() { var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]'); for (var i = 0, len = $videoImg.length; i < len; i++) { addMask($videoImg[i]); } }; var render = function render(res) { var ulTmpl = \"\"; for (var j = 0, len2 = res.list.length; j < len2; j++) { var data = res.list[j].arr; var liTmpl = \"\"; for (var i = 0, len = data.link.length; i < len; i++) { var minSrc = 'https://raw.githubusercontent.com/ydl8686/Blog-Back-Up/master/min_photos/' + data.link[i]; var src = 'https://raw.githubusercontent.com/ydl8686/Blog-Back-Up/master/photos/' + data.link[i]; var type = data.type[i]; var target = src + (type === 'video' ? '.mp4' : '.jpg'); src += ''; liTmpl += '\\ \\ \\ \\ ' + data.text[i] + '\\ '; } ulTmpl = ulTmpl + '' + data.year + '年' + data.month + '月\\ ' + liTmpl + '\\ '; } document.querySelector('.instagram').innerHTML = '' + ulTmpl + ''; createVideoIncon(); _view2.default.init(); }; var replacer = function replacer(str) { var arr = str.split(\"/\"); return \"/assets/ins/\" + arr[arr.length - 1]; }; var ctrler = function ctrler(data) { var imgObj = {}; for (var i = 0, len = data.length; i < len; i++) { var y = data[i].y; var m = data[i].m; var src = replacer(data[i].src); var text = data[i].text; var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m); if (imgObj[key]) { imgObj[key].srclist.push(src); imgObj[key].text.push(text); } else { imgObj[key] = { year: y, month: m, srclist: [src], text: [text] }; } } render(imgObj); }; function loadData(success) { if (!searchData) { var xhr = new XMLHttpRequest(); xhr.open('GET', './data.json?t=' + +new Date(), true); xhr.onload = function() { if (this.status >= 200 && this.status < 300) { var res = JSON.parse(this.response); searchData = res; success(searchData); } else { console.error(this.statusText); } }; xhr.onerror = function() { console.error(this.statusText); }; xhr.send(); } else { success(searchData); } } var Ins = { init: function init() { loadData(function(data) { render(data); }); } }; Ins.init(); // export default impush; /***/ }, /* 1 */ /***/ function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */ (function(global) { 'use strict'; var inViewport = __webpack_require__(3); var lazyAttrs = ['data-src']; global.lzld = lazyload(); // Provide libs using getAttribute early to get the good src // and not the fake data-src replaceGetAttribute('Image'); replaceGetAttribute('IFrame'); function registerLazyAttr(attr) { if (indexOf.call(lazyAttrs, attr) === -1) { lazyAttrs.push(attr); } } function lazyload(opts) { opts = merge({ 'offset': 333, 'src': 'data-src', 'container': false }, opts || {}); if (typeof opts.src === 'string') { registerLazyAttr(opts.src); } var elts = []; function show(elt) { var src = findRealSrc(elt); if (src) { elt.src = src; } elt.setAttribute('data-lzled', true); elts[indexOf.call(elts, elt)] = null; } function findRealSrc(elt) { if (typeof opts.src === 'function') { return opts.src(elt); } return elt.getAttribute(opts.src); } function register(elt) { elt.onload = null; elt.removeAttribute('onload'); elt.onerror = null; elt.removeAttribute('onerror'); if (indexOf.call(elts, elt) === -1) { inViewport(elt, opts, show); } } return register; } function replaceGetAttribute(elementName) { var fullname = 'HTML' + elementName + 'Element'; if (fullname in global === false) { return; } var original = global[fullname].prototype.getAttribute; global[fullname].prototype.getAttribute = function(name) { if (name === 'src') { var realSrc; for (var i = 0, max = lazyAttrs.length; i < max; i++) { realSrc = original.call(this, lazyAttrs[i]); if (realSrc) { break; } } return realSrc || original.call(this, name); } // our own lazyloader will go through theses lines // because we use getAttribute(opts.src) return original.call(this, name); }; } function merge(defaults, opts) { for (var name in defaults) { if (opts[name] === undefined) { opts[name] = defaults[name]; } } return opts; } // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html function indexOf(value) { for (var i = this.length; i-- && this[i] !== value;) {} return i; } module.exports = lazyload; // export default impush; /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ }, /* 2 */ /***/ function(module, exports) { 'use strict'; var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) { // parse slide data (url, title, size ...) from DOM elements // (children of gallerySelector) var parseThumbnailElements = function parseThumbnailElements(el) { el = el.parentNode.parentNode; var thumbElements = el.getElementsByClassName('thumb'), numNodes = thumbElements.length, items = [], figureEl, linkEl, size, type, // video or not target, item; for (var i = 0; i < numNodes; i++) { figureEl = thumbElements[i]; // // include only element nodes if (figureEl.nodeType !== 1) { continue; } linkEl = figureEl.children[0]; // size = linkEl.getAttribute('data-size').split('x'); type = linkEl.getAttribute('data-type'); target = linkEl.getAttribute('data-target'); // create slide object item = { src: linkEl.getAttribute('href'), w: parseInt(size[0], 10), h: parseInt(size[1], 10) }; if (figureEl.children.length > 1) { item.title = figureEl.children[1].innerHTML; } if (linkEl.children.length > 0) { item.msrc = linkEl.children[0].getAttribute('src'); item.type = type; item.target = target; item.html = ''; if (type === 'video') { //item.src = null; } } item.el = figureEl; // save link to element for getThumbBoundsFn items.push(item); } return items; }; // find nearest parent element var closest = function closest(el, fn) { return el && (fn(el) ? el : closest(el.parentNode, fn)); }; // triggers when user clicks on thumbnail var onThumbnailsClick = function onThumbnailsClick(e) { e = e || window.event; e.preventDefault ? e.preventDefault() : e.returnValue = false; var eTarget = e.target || e.srcElement; // find root element of slide var clickedListItem = closest(eTarget, function(el) { return el.tagName && el.tagName.toUpperCase() === 'FIGURE'; }); if (!clickedListItem) { return; } // find index of clicked item by looping through all child nodes // alternatively, you may define index via data- attribute var clickedGallery = clickedListItem.parentNode, // childNodes = clickedListItem.parentNode.childNodes, // numChildNodes = childNodes.length, childNodes = document.getElementsByClassName('thumb'), numChildNodes = childNodes.length, nodeIndex = 0, index; for (var i = 0; i < numChildNodes; i++) { if (childNodes[i].nodeType !== 1) { continue; } if (childNodes[i] === clickedListItem) { index = nodeIndex; break; } nodeIndex++; } if (index >= 0) { // open PhotoSwipe if valid index found openPhotoSwipe(index, clickedGallery); } return false; }; // parse picture index and gallery index from URL (#&pid=1&gid=2) var photoswipeParseHash = function photoswipeParseHash() { var hash = window.location.hash.substring(1), params = {}; if (hash.length < 5) { return params; } var vars = hash.split('&'); for (var i = 0; i < vars.length; i++) { if (!vars[i]) { continue; } var pair = vars[i].split('='); if (pair.length < 2) { continue; } params[pair[0]] = pair[1]; } if (params.gid) { params.gid = parseInt(params.gid, 10); } return params; }; var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) { var pswpElement = document.querySelectorAll('.pswp')[0], gallery, options, items; items = parseThumbnailElements(galleryElement); // define options (if needed) options = { // define gallery index (for URL) galleryUID: galleryElement.getAttribute('data-pswp-uid'), getThumbBoundsFn: function getThumbBoundsFn(index) { // See Options -> getThumbBoundsFn section of documentation for more info var thumbnail = items[index].el.getElementsByTagName('img')[0], // find thumbnail pageYScroll = window.pageYOffset || document.documentElement.scrollTop, rect = thumbnail.getBoundingClientRect(); return { x: rect.left, y: rect.top + pageYScroll, w: rect.width }; } }; // PhotoSwipe opened from URL if (fromURL) { if (options.galleryPIDs) { // parse real index when custom PIDs are used // http://photoswipe.com/documentation/faq.html#custom-pid-in-url for (var j = 0; j < items.length; j++) { if (items[j].pid == index) { options.index = j; break; } } } else { // in URL indexes start from 1 options.index = parseInt(index, 10) - 1; } } else { options.index = parseInt(index, 10); } // exit if index not found if (isNaN(options.index)) { return; } if (disableAnimation) { options.showAnimationDuration = 0; } // Pass data to PhotoSwipe and initialize it gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options); gallery.init(); var $tempVideo; var stopVideoHandle = function stopVideoHandle() { if ($tempVideo) { $tempVideo.remove(); $tempVideo = null; } }; var changeHandle = function changeHandle() { var item = gallery.currItem; stopVideoHandle(); if (item.type === 'video') { var $ctn = item.container; var style = $ctn.getElementsByClassName('pswp__img')[0].style; var $video = document.createElement('video'); $video.setAttribute('autoplay', 'autoplay'); $video.setAttribute('controls', 'controls'); $video.setAttribute('src', item.target); $video.style.width = style.width; $video.style.height = style.height; $video.style.position = 'absolute'; $video.style.zIndex = 2; $tempVideo = $video; $ctn.appendChild($video); } }; gallery.listen('initialZoomIn', changeHandle); gallery.listen('afterChange', changeHandle); gallery.listen('initialZoomOut', stopVideoHandle); }; // loop through all gallery elements and bind events var galleryElements = document.querySelectorAll(gallerySelector); for (var i = 0, l = galleryElements.length; i < l; i++) { galleryElements[i].setAttribute('data-pswp-uid', i + 1); galleryElements[i].onclick = onThumbnailsClick; } // Parse URL and open gallery if it contains #&pid=3&gid=1 var hashData = photoswipeParseHash(); if (hashData.pid && hashData.gid) { openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true); } }; var Viewer = function() { function init() { initPhotoSwipeFromDOM('.photos'); } return { init: init }; }(); module.exports = Viewer; /***/ }, /* 3 */ /***/ function(module, exports) { /* WEBPACK VAR INJECTION */ (function(global) { module.exports = inViewport; var instances = []; var supportsMutationObserver = typeof global.MutationObserver === 'function'; function inViewport(elt, params, cb) { var opts = { container: global.document.body, offset: 0 }; if (params === undefined || typeof params === 'function') { cb = params; params = {}; } var container = opts.container = params.container || opts.container; var offset = opts.offset = params.offset || opts.offset; for (var i = 0; i < instances.length; i++) { if (instances[i].container === container) { return instances[i].isInViewport(elt, offset, cb); } } return instances[ instances.push(createInViewport(container)) - 1 ].isInViewport(elt, offset, cb); } function addEvent(el, type, fn) { if (el.attachEvent) { el.attachEvent('on' + type, fn); } else { el.addEventListener(type, fn, false); } } function debounce(func, wait, immediate) { var timeout; return function() { var context = this, args = arguments; var callNow = immediate && !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); function later() { timeout = null; if (!immediate) func.apply(context, args); } }; } // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708 var contains = function() { if (!global.document) { return true; } return global.document.documentElement.compareDocumentPosition ? function(a, b) { return !!(a.compareDocumentPosition(b) & 16); } : global.document.documentElement.contains ? function(a, b) { return a !== b && (a.contains ? a.contains(b) : false); } : function(a, b) { while (b = b.parentNode) { if (b === a) { return true; } } return false; }; } function createInViewport(container) { var watches = createWatches(); var scrollContainer = container === global.document.body ? global : container; var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15); addEvent(scrollContainer, 'scroll', debouncedCheck); if (scrollContainer === global) { addEvent(global, 'resize', debouncedCheck); } if (supportsMutationObserver) { observeDOM(watches, container, debouncedCheck); } // failsafe check, every 200ms we check for visible images // usecase: a hidden parent containing eleements // when the parent becomes visible, we have no event that the children // became visible setInterval(debouncedCheck, 150); function isInViewport(elt, offset, cb) { if (!cb) { return isVisible(elt, offset); } var remote = createRemote(elt, offset, cb); remote.watch(); return remote; } function createRemote(elt, offset, cb) { function watch() { watches.add(elt, offset, cb); } function dispose() { watches.remove(elt); } return { watch: watch, dispose: dispose }; } function watchInViewport(elt, offset, cb) { if (isVisible(elt, offset)) { watches.remove(elt); cb(elt); } } function isVisible(elt, offset) { if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) { return false; } // Check if the element is visible // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js if (!elt.offsetWidth || !elt.offsetHeight) { return false; } var eltRect = elt.getBoundingClientRect(); var viewport = {}; if (container === global.document.body) { viewport = { top: -offset, left: -offset, right: global.document.documentElement.clientWidth + offset, bottom: global.document.documentElement.clientHeight + offset }; } else { var containerRect = container.getBoundingClientRect(); viewport = { top: containerRect.top - offset, left: containerRect.left - offset, right: containerRect.right + offset, bottom: containerRect.bottom + offset }; } // The element must overlap with the visible part of the viewport var visible = ( (eltRect.right > viewport.left) && (eltRect.left < viewport.right) && (eltRect.bottom > viewport.top) && (eltRect.top < viewport.bottom) ); return visible; } return { container: container, isInViewport: isInViewport }; } function createWatches() { var watches = []; function add(elt, offset, cb) { if (!isWatched(elt)) { watches.push([elt, offset, cb]); } } function remove(elt) { var pos = indexOf(elt); if (pos !== -1) { watches.splice(pos, 1); } } function indexOf(elt) { for (var i = watches.length - 1; i >= 0; i--) { if (watches[i][0] === elt) { return i; } } return -1; } function isWatched(elt) { return indexOf(elt) !== -1; } function checkAll(cb) { return function() { for (var i = watches.length - 1; i >= 0; i--) { cb.apply(this, watches[i]); } }; } return { add: add, remove: remove, isWatched: isWatched, checkAll: checkAll }; } function observeDOM(watches, container, cb) { var observer = new MutationObserver(watch); var filter = Array.prototype.filter; var concat = Array.prototype.concat; observer.observe(container, { childList: true, subtree: true, // changes like style/width/height/display will be catched attributes: true }); function watch(mutations) { // some new DOM nodes where previously watched // we should check their positions if (mutations.some(knownNodes) === true) { setTimeout(cb, 0); } } function knownNodes(mutation) { var nodes = concat.call([], Array.prototype.slice.call(mutation.addedNodes), mutation.target ); return filter.call(nodes, watches.isWatched).length > 0; } } /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ } /******/ ]);"},{"title":"","date":"2023-02-18T01:46:09.207Z","updated":"2021-02-18T08:39:30.230Z","comments":true,"path":"photos/lazyload.min.js","permalink":"http://ydl8686.github.io/photos/lazyload.min.js","excerpt":"","text":"/*! * An jQuery | zepto plugin for lazy loading images. * author -> jieyou * see https://github.com/jieyou/lazyload * use some tuupola's code https://github.com/tuupola/jquery_lazyload (BSD) * use component's throttle https://github.com/component/throttle (MIT) */ !function(a){\"function\"==typeof define&&define.amd?define([\"jquery\"],a):a(window.jQuery||window.Zepto)}(function(a){function g(){}function h(a,b){var e;return e=b._$container==d?(\"innerHeight\"in c?c.innerHeight:d.height())+d.scrollTop():b._$container.offset().top+b._$container.height(),e=b.offset().left+e.threshold+b.width()}function l(a,b){var c=0;a.each(function(d){function g(){f.trigger(\"_lazyload_appear\"),c=0}var f=a.eq(d);if(!(f.width()b.failure_limit)return!1}else g()})}function m(a){return a.filter(function(b){return!a.eq(b)._lazyload_loadStarted})}function n(a,b){function h(){f=0,g=+new Date,e=a.apply(c,d),c=null,d=null}var c,d,e,f,g=0;return function(){c=this,d=arguments;var a=new Date-g;return f||(a>=b?h():f=setTimeout(h,b-a)),e}}var f,c=window,d=a(c),e={threshold:0,failure_limit:0,event:\"scroll\",effect:\"show\",effect_params:null,container:c,data_attribute:\"original\",data_srcset_attribute:\"original-srcset\",skip_invisible:!0,appear:g,load:g,vertical_only:!1,check_appear_throttle_time:300,url_rewriter_fn:g,no_fake_img_loader:!1,placeholder_data_img:\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\",placeholder_real_img:\"http://ditu.baidu.cn/yyfm/lazyload/0.0.1/img/placeholder.png\"};f=function(){var a=Object.prototype.toString;return function(b){return a.call(b).replace(\"[object \",\"\").replace(\"]\",\"\")}}(),a.fn.hasOwnProperty(\"lazyload\")||(a.fn.lazyload=function(b){var i,j,k,h=this;return a.isPlainObject(b)||(b={}),a.each(e,function(g,h){var i=f(b[g]);-1!=a.inArray(g,[\"threshold\",\"failure_limit\",\"check_appear_throttle_time\"])?\"String\"==i?b[g]=parseInt(b[g],10):\"Number\"!=i&&(b[g]=h):\"container\"==g?(b._$container=b.hasOwnProperty(g)?b[g]==c||b[g]==document?d:a(b[g]):d,delete b.container):!e.hasOwnProperty(g)||b.hasOwnProperty(g)&&i==f(e[g])||(b[g]=h)}),i=\"scroll\"==b.event,k=0==b.check_appear_throttle_time?l:n(l,b.check_appear_throttle_time),j=i||\"scrollstart\"==b.event||\"scrollstop\"==b.event,h.each(function(c){var e=this,f=h.eq(c),i=f.attr(\"src\"),k=f.attr(\"data-\"+b.data_attribute),l=b.url_rewriter_fn==g?k:b.url_rewriter_fn.call(e,f,k),n=f.attr(\"data-\"+b.data_srcset_attribute),o=f.is(\"img\");return 1==f._lazyload_loadStarted||i==l?(f._lazyload_loadStarted=!0,h=m(h),void 0):(f._lazyload_loadStarted=!1,o&&!i&&f.one(\"error\",function(){f.attr(\"src\",b.placeholder_real_img)}).attr(\"src\",b.placeholder_data_img),f.one(\"_lazyload_appear\",function(){function i(){d&&f.hide(),o?(n&&f.attr(\"srcset\",n),l&&f.attr(\"src\",l)):f.css(\"background-image\",'url(\"'+l+'\")'),d&&f[b.effect].apply(f,c?b.effect_params:[]),h=m(h)}var d,c=a.isArray(b.effect_params);f._lazyload_loadStarted||(d=\"show\"!=b.effect&&a.fn[b.effect]&&(!b.effect_params||c&&0==b.effect_params.length),b.appear!=g&&b.appear.call(e,f,h.length,b),f._lazyload_loadStarted=!0,b.no_fake_img_loader||n?(b.load!=g&&f.one(\"load\",function(){b.load.call(e,f,h.length,b)}),i()):a(\"\").one(\"load\",function(){i(),b.load!=g&&b.load.call(e,f,h.length,b)}).attr(\"src\",l))}),j||f.on(b.event,function(){f._lazyload_loadStarted||f.trigger(\"_lazyload_appear\")}),void 0)}),j&&b._$container.on(b.event,function(){k(h,b)}),d.on(\"resize load\",function(){k(h,b)}),a(function(){k(h,b)}),this})});"},{"title":"","date":"2023-02-18T01:46:09.266Z","updated":"2021-02-18T08:39:30.230Z","comments":true,"path":"photos/package.json","permalink":"http://ydl8686.github.io/photos/package.json","excerpt":"","text":"{\"name\":\"hexo-site\",\"version\":\"0.0.0\",\"private\":true,\"hexo\":{\"version\":\"3.2.2\"},\"dependencies\":{\"hexo\":\"^3.1.0\",\"hexo-deployer-git\":\"0.0.4\",\"hexo-deployer-rsync\":\"^0.1.2\",\"hexo-generator-archive\":\"^0.1.3\",\"hexo-generator-baidu-sitemap\":\"^0.1.2\",\"hexo-generator-category\":\"^0.1.3\",\"hexo-generator-feed\":\"^1.2.0\",\"hexo-generator-index\":\"^0.1.3\",\"hexo-generator-json-content\":\"^3.0.1\",\"hexo-generator-json-feed\":\"^1.0.0\",\"hexo-generator-sitemap\":\"^1.1.2\",\"hexo-generator-tag\":\"^0.1.2\",\"hexo-helper-qrcode\":\"^1.0.1\",\"hexo-renderer-ejs\":\"^0.1.0\",\"hexo-renderer-marked\":\"^0.2.5\",\"hexo-renderer-stylus\":\"^0.2.3\",\"hexo-server\":\"^0.1.2\"}}"},{"title":"Project","date":"2023-02-18T01:46:09.192Z","updated":"2021-05-06T12:20:17.863Z","comments":true,"path":"project/index.html","permalink":"http://ydl8686.github.io/project/index.html","excerpt":"","text":""},{"title":"Tags","date":"2023-02-18T01:46:09.168Z","updated":"2021-05-06T12:20:17.865Z","comments":true,"path":"tags/index.html","permalink":"http://ydl8686.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"面试合集","slug":"面试合集","date":"2023-02-26T23:58:35.000Z","updated":"2023-03-08T11:35:55.699Z","comments":true,"path":"posts/57112/","link":"","permalink":"http://ydl8686.github.io/posts/57112/","excerpt":"","text":"UDP和TCP的区别、使用场景、优劣，如何让UDP更可靠区别 TCP面向连接，UDP是无连接的TCP在开始数据传输之前要经过三次握手，UDP却不需要任何准备即可进行数据传输，因此UDP不会引入建立连接的时延 TCP提供可靠的服务，UDP则是尽最大努力交付TCP传输数据具有重传机制，如果在传输数据的过程中发生丢包事件，发送方会重传丢失的数据以保证发送的数据一定能完整到达接收方，因此是可靠的。UDP在网络层不能保证数据传输的可靠性。（可以在应用层实现UDP数据传输的可靠性） UDP效率比TCP高UDP在传输数据前不需要建立连接，没有繁琐的握手过程，没有复杂的拥塞控制算法和重传机制，所以UDP相对于TCP具有较高的效率。 每一条TCP连接只能是点到点，UDP支持一对一、一对多、多对多 TCP对系统资源要求较多，UDP对系统资源要求较少TCP建立连接后，会为连接分配发送缓存和接受缓存，维护拥塞控制变量以及序号和确认号的参数，因此需要占用较多的系统资源。而UDP是无连接的，对系统资源要求较少 使用场景TCP：对网络通讯质量有要求时，例如整个数据要准确无误的传递给对方 FTP：文件传输协议 SSH：安全登录 Telnet：不安全文本传送 SMTP：简单邮件传输协议 HTTP：超文本传输协议 UDP：对网络通讯质量要求不高时，要求网络通讯速度能尽量的快 流媒体 如果采用TCP，一旦发生丢包，TCP会将后续包缓存起来，等前面的包重传并接收到后再继续发送（重传的数据会占用窗口大小），延迟会越来越大 实时游戏 自定义重传策略能把丢包产生的延迟降到最低 物联网 各自优缺点TCP优点：可靠、稳定 TCP缺点：慢、效率低、占用系统资源高、易被攻击（SYN Flood攻击） SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪 UDP优点：快、稍安全 UDP缺点：不可靠、不稳定 如何让UDP更可靠在上层应用层模仿TCP的可靠性传输 添加seq/ack机制，确保数据发送到对端 添加超时重传机制 输入url到出现页面的过程 url中的host可以是ip地址也可以是域名，如果是域名则需要将域名解析为ip地址 查看本地hosts文件是否有相关规则 发送DNS请求到本地DNS服务器查询，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，如果没有，本地DNS服务器还要向DNS根服务器进行查询 递归查询 迭代查询 建立TCP连接 发送HTTP请求 或者是HTTPS 服务器处理请求并返回HTTP报文 浏览器拿到数据后处理渲染页面 处理 HTML 标记并构建 DOM 树。 处理 CSS 标记并构建 CSSOM 树。 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，以计算每个节点的几何信息。 将各个节点绘制到屏幕上。 断开连接 闭包 上级作用域指的是创建时的上级而不是调用的上级，与this指针不同 定义闭包是指能够访问另一个函数内部变量的函数，创建闭包最常见的方式就是将函数作为返回值 有时候需要得到函数内的局部变量。但是，正常情况下这是办不到的，只有通过变通方法才能实现，闭包就是这种方法 实际应用获取多个元素并添加点击事件 for (var j = 0; j &lt; op.length; j++) &#123; (function(j) &#123; op[j].onclick = function() &#123; alert(j); &#125;; &#125;)(j);&#125; 作用 保护函数的私有变量不受外部的干扰（立即执行函数）。形成不销毁的栈内存。 保存，把一些函数内的值保存下来。闭包可以实现方法和属性的私有化 缺点被引用的内部变量不能被销毁，增大了内存消耗，使用不当易造成内存泄露 Vue响应式原理Vue是基于Object.defineProperty来实现数据响应的，通过Object.defineProperty的 getter/setter 对收集的依赖项进行监听,在属性被访问和修改时通知变化,进而更新视图数据 受现代JavaScript 的限制 (以及废弃Object.observe)，Vue2不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行getter/setter 转化过程，所以属性必须在 data 对象上存在才能让Vue转换它，这样才能让它是响应的。 http各个版本区别http/0.9只支持GET方法；只能回应HTML格式的字符串，不能回应别的格式 http/1.0任何格式的内容都可以发送；除了GET命令，还引入了POST命令和HEAD命令；请求和回应的格式也发生变化；新增状态码等 每个TCP连接只能发送一个请求，发送数据完毕，连接就关闭 http/1.1（主流）持久连接，TCP连接默认不关闭，可以被多个请求复用；同一个TCP连接里面，客户端可以通过pipeline同时发送多个请求，但是响应的时候必须按照发送的顺序接收；请求头信息新增host字段；报文主体压缩 同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着（队头堵塞） 解决队头阻塞：减少请求的次数（精灵图）；域名分片，因为一个域名的连接数是有限的，所以划分多个子域名来处理请求 http/2头信息和数据体都是二进制，并且统称为”帧”；多路复用，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，可以通过流标识符来进行重组，从而避免了”队头堵塞”；允许服务器主动向客户端发送资源，这叫做服务器推送；HPACK首部压缩 请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度；DDoS攻击，一直主动发送资源 http/2解决队头阻塞只是应用层表面，然而还是基于传输层TCP的，收不到还是会要等待重传造成阻塞 http/3使用UDP+QUIC的方式，其中QUIC整合了TCP以及TLS握手过程 https加密过程 websocketWebSocket是一种在单个TCP连接上进行全双工通信的协议，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，允许服务端主动向客户端推送数据 在 WebSocket出现以前，使用HTTP创建一个和服务端进双通道通信的 web 应用，需要进行不停的轮询，这会导致一些问题： 服务端被迫维持来自每个客户端的大量不同的连接 大量的轮询请求会造成高开销，比如会带上多余重复的header，造成了无用的数据传输。 虽然HTTP/2也具备服务器推送功能，但HTTP/2只能推送静态资源，无法推送指定的信息 websocket和http是有一定交叉关系的，在最开始握手的时候是采用http来进行协议切换的，101状态码表示切换成功 特点没有同源限制，客户端可以与任意服务器通信； 与 HTTP 协议有着良好的兼容性，默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器； 建立连接需要握手（HTTP就不需要） 在线离线问题–时间戳当客户端第一次发送请求至服务端时会携带唯一标识、以及时间戳，服务端到db或者缓存去查询该请求的唯一标识，如果不存在就存入db或者缓存中， 第二次客户端定时再次发送请求依旧携带唯一标识、以及时间戳，服务端到db或者缓存去查询该请求的唯一标识，如果存在就把上次的时间戳拿取出来，使用当前时间戳减去上次的时间，得出的毫秒秒数判断是否大于指定的时间，若小于的话就是在线，否则就是离线； 断线问题–心跳检测 客户端每隔一段时间发一个探测包给服务器，并启动一个超时定时器 服务器端接收到检测包，应该回应一个包给客户端 如果客户机收到服务器的应答包，则说明服务器正常，删除超时定时器 如果客户端的超时定时器超时，依然没有收到应答包，则说明服务器挂了 数据类型基本数据类型null：typeof null为object，表示没有任何对象，例如原型链的末端Object.prototype.__proto__ undefined：表示没有任何值，例如声明但是没有初始化的变量、不存在的对象属性 这俩都没有对象包装器，所以就是一个值 boolean number：+0===-0 //true，但是除的时候会分别得到+Infinity和-Infinity；NaN是唯一不等于自身的值； string：字符串长度是指其中UTF-16代码单元的数量，可能与Unicode字符的实际数量不同；不可变 bigint：表示任意大小的整数 symbol：独一无二的值，哪怕创建时的传参是一样的，symbol值也不一样；可以用来定义常量消除魔法字符、作为对象属性（不过for in来遍历对象属性时不会输出symbol值作为的key） const PROP_NAME = Symbol()const PROP_AGE = Symbol()let obj = &#123; [PROP_NAME]: &quot;一斤代码&quot;&#125;obj[PROP_AGE] = 18obj[PROP_NAME] // &#x27;一斤代码&#x27;obj[PROP_AGE] // 18 区别声明时，基本数据存放在栈里，引用数据存放在堆中 访问时，基本数据类型是按值访问的，引用数据类型是按引用访问的 修改时，基本数据是不可变的，引用数据则是可变的 传参时，基本数据类型传的是值，引用数据类型传的是引用（对象在堆上的引用） 因此，参数是一个对象时，函数内部尽量不要修改函数外部的值 基本数据类型的赋值是把值拷贝一份，而引用数据类型则是拷贝对象在堆上的地址，不会新创建对象 css中的一些单位em和rem计算em，如果自身元素是没有设置字体大小的，那么就会根据其父元素（如果父元素没有设置font-size，就去找爷元素递归）的字体大小作为参照去计算，如果元素本身已经设置了字体，那么就会基于自身的字体大小进行计算（width等设置了em，先看自己元素有没有设置font-size，有的话拿这个算，没的话再往上找） rem和em比较相似，不过计算的参照物不是父元素，而是根html元素，避免了字体大小逐层复合的连锁反应 浏览器默认字体16px vh、vw、vmin、vmax以vh为例，表示视窗高度的百分比，1vh就相当于整个视窗高度的1% %盒模型中的百分比width/height、max-width/height、min-width/height：值为百分比时，其相对于包含块的 width/height 进行计算； padding、margin：值为百分比时，如果是水平的值，就是相对于包含块的width进行计算；如果是垂直的值，就是相对于包含块的height进行计算。 文本中的百分比font-size：根据父元素的font-size进行计算； line-height：根据font-size进行计算； 定位中的百分比如果元素为静态（ static ）或相对定位（ relative ），包含块一般是其父容器； 如果元素为绝对定位（ absolute ），包含块应该是离它最近的 position 为 absolute 、 relative 或 fixed 的祖先元素； 如果元素为固定定位（ fixed ），包含块就是视窗（ viewport ） HTTP状态码1XXHTTP缓存与CDN缓存HTTP缓存缓存是一种保存资源副本并在下次请求时直接使用该副本的技术，当 web 缓存发现请求的资源已经被存储，那么直接使用该资源的拷贝，而不会去再次请求服务端 根据是否需要重新向服务器发起请求可以分成两种：强制缓存和对比/协商缓存 强制缓存 客户端请求数据 服务端返回数据以及缓存规则 客户端将数据和缓存规则存进缓存数据库 再次请求数据，先看缓存数据库里的缓存规则，如果资源没过期那么直接从缓存数据库中取，否则向服务端发起请求 Expires：主要是用在http/1.0，现在默认使用http/1.1，作用基本忽略；它的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。 到期时间是由服务端生成的，如果客户端时间跟服务器时间不一致，这就会导致命中误差 Cache-Control：默认值为private ​ max-age：设置资源可以被缓存的时间，单位为秒，在这段时间内再次请求这个资源将会直接使用缓存数据库中的数据 ​ s-maxage：和 max-age 是一样的，不过它只针对代理服务器缓存而言 ​ public：响应可以被任何缓存区（发送请求的客户端、代理服务器CDN等）缓存 ​ private：只有个人能缓存，代理服务器不可以缓存 ​ no-cache：强制客户端每次直接向服务器发送请求，服务器接收到请求后，判断资源是否变更，是则返回新内容，否则返回304，未变更 ​ no-store：禁止一切缓存 对比/协商缓存 客户端请求数据 服务端返回数据以及缓存标识 客户端将数据以及缓存标识存进缓存数据库 再次请求数据，将缓存标识发给服务端 服务端返回304，未变更，客户端直接使用缓存数据；否则返回最新数据以及缓存规则 Last-Modified（响应）/If-Modified-Since（请求） 服务端响应请求时，会带上Last-Modified字段告诉浏览器这个资源的最后修改时间；浏览器后来再次请求时，带上If-Modified-Since字段发给服务端；服务端通过对比资源最后的修改时间来判断是否能使用缓存 Etag（响应）/If-None-Match（请求） 优先级比Last-Modified/If-Modified-Since更高； 服务端响应请求时，会带上Etag字段告诉浏览器这个资源在服务器的唯一标识；浏览器后来再次请求时，带上If-None-Match字段发给服务端；服务端对比这个If-None-Match和这个资源现在的Etag是否一致来判断是否能使用缓存","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://ydl8686.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Linux#6 | 用户和组群账户管理","slug":"Linux-6-用户和组群账户管理","date":"2023-02-22T10:01:06.000Z","updated":"2023-02-27T08:12:31.294Z","comments":true,"path":"posts/6065/","link":"","permalink":"http://ydl8686.github.io/posts/6065/","excerpt":"","text":"","categories":[],"tags":[{"name":"课业","slug":"课业","permalink":"http://ydl8686.github.io/tags/%E8%AF%BE%E4%B8%9A/"}]},{"title":"Linux#5 | 常用操作命令","slug":"linux复习1","date":"2023-02-22T07:20:46.000Z","updated":"2023-02-27T08:12:31.288Z","comments":true,"path":"posts/22722/","link":"","permalink":"http://ydl8686.github.io/posts/22722/","excerpt":"","text":"文本内容显示cat显示文件内容，也可以把几个文件内容附加到另一个文件中。如果没有指定文件，或者文件为-，那么从标准输入读取 把textfile1文件内容加上行号后输入到textfile2中cat -n textfile1 &gt; textfile2使用cat命令创建mm.txtcat &gt;mm.txt&lt;&lt;EOF 输入EOF会自动回到shell提示符界面 more分页显示文件内容，按空格显示下一页，按b返回显示上一页 逐页显示文件内容，如果有连续两行以上空白行则以一行显示more -s testfile从第20行开始显示文件内容more +20 testfile一次两行显示文件内容more -2 testfile less回卷显示文件内容，与more相似，不同在于前者可以往回卷动 less testfile head显示指定文件前若干行，默认设置为10行；如果没有指定文件，则从标准输入中读取 查看前100字节数据内容head -c 100 testfile查看前3行数据内容head -3 testfile tail显示指定文件末尾若干行；如果指定多个文件，会在每段输出的开始添加相应文件名作为头。如果不指定文件或文件为-，则从标准输入读取数据。 一般用来显示日志文件，命令执行后不会自动结束，文件在更新时可以实时看到 查看末尾3行内容tail -3 testfile查看末尾100字节内容tail -c 100 testfile 文本内容处理sort对文件中的数据排序并显示到标准输出上，默认升序排列 sort -r testfile倒序排列 uniq将文件中的重复行数据从输出文件中删除 删除重复行uniq -d testfile查看不重复的数据内容uniq -u testfile cut从文件每行中输出选定的字节、字符或字段 显示文件中第1个和第5个字段，并用:连接cut -f 1,5 -d: /etc/passwd comm逐行比较两个已排过序的文件 comm file1 file2会输出三列，第1列file1特有的行，第2列file2特有的行，第3列共有的行 添加指定参数-1、-2和-3会不输出对应的列 diff逐行比较两个文件，并列出不同之处，不要求事先对文件进行排序 文件和命令查找grep查找文件内符合条件的字符串 在文件kkk中搜索匹配字符test file的行数据内容grep &#x27;test file&#x27; kkk显示所有以d开头的文件中包含test的行数据内容grep &#x27;test&#x27; d*显示/root/aa文件中b开头的行数据内容grep ^b /root/aa显示/root/aa文件中不是以b开头的行数据内容grep -v ^b /root/aa显示/root/kkk文件中以le结尾的行数据内容grep le$ /root/kkk查找sshd进程信息ps -ef|grep sshd find将文件系统内符合条件的文件列出来，只有和条件完全相符的才会被列出来 按名字查找find /boot -name grub.cfgfind / -name &#x27;*.conf&#x27;按更改时间查找find / -ctime -20 /目录下最近20天内更改过的文件 mtime(modification time)：当文件的 内容数据 更改时，就会更新这个时间。内容数据指的是文件的内容，而不是文件的属性或权限。 ctime(status time)：当文件的 状态 改变时，就会更新这个时间，举例来说，像是 权限 与 属性 被更改了，都会更新这个时间。 atime(access time)：当文件内容被取用的时候，就会更新这个 读取时间 。举例来说，如果使用 cat 命令去读取一个文件的内容，就会更新该文件的 atime。 locate通过数据库来查找文件，比find的速度快 查找test文件locate test显示找到几个test文件locate -c test 系统信息显示uname显示计算机以及操作系统相关信息，例如硬件架构、内核发行号、操作系统名称、主机名等 显示操作系统内核发行号uname -r显示硬件架构名称uname -m显示操作系统全部信息uname -a hostname显示或修改计算机主机名 显示计算机主机名hostname修改主机名为LINUXhostname LINUX free显示系统物理内存和swap的使用情况 查看物理内存和swap使用情况free以MB为单位查看free -m查看物理内存+交换分区总容量free -t du显示目录或文件的磁盘占用量；如果没有给出文件或目录名称，那么就对当前目录进行统计 显示文件的磁盘占用量du file显示目录的磁盘占用量du -s /root以MB为单位显示du -sh /root 信息交流echo字符串可以加引号也可以不加；输出加引号的字符串时，将引号内的内容原样输出；输出不加引号的字符串时，将字符串中的各个单词作为字符串输出，各字符串之间用一个空格分隔","categories":[],"tags":[{"name":"课业","slug":"课业","permalink":"http://ydl8686.github.io/tags/%E8%AF%BE%E4%B8%9A/"}]},{"title":"📖算法 | 每日一题","slug":"算法-每日一题","date":"2023-02-12T04:47:41.000Z","updated":"2023-02-13T07:56:52.418Z","comments":true,"path":"posts/26641/","link":"","permalink":"http://ydl8686.github.io/posts/26641/","excerpt":"","text":"字母板上的路径 2023-2-12 每次都是先上下移动再左右移动，针对z的特殊情况需要先左右移动再上下，因为z的右边是空的走不了 var alphabetBoardPath = function(target) &#123; let result=&#x27;&#x27;; if(!target)&#123; return &#x27;&#x27;; &#125; // m,n用来表示上一个字符起点的坐标 let m=0; let n=0; for(let i=0;i&lt;target.length;i++)&#123; let obj=coordinate(target.charAt(i)); let y=run(obj.y-n,&#x27;y&#x27;); let x=run(obj.x-m,&#x27;x&#x27;); // 特殊情况判断 if(target.charAt(i)===&#x27;z&#x27;)&#123; result=result+y+x+&#x27;!&#x27;; &#125; else&#123; result=result+x+y+&#x27;!&#x27;; &#125; m=obj.x; n=obj.y; &#125; return result;&#125;;// 返回字符在字母板上的位置let coordinate=char=&gt;&#123; let num=char.charCodeAt()-&#x27;a&#x27;.charCodeAt(); return &#123; x:Math.floor(num/5), y:num%5, &#125;&#125;//返回从起点到终点的路径字符串let run=(val, axis)=&gt;&#123; let result=&#x27;&#x27;; if(val===0)&#123; return result; &#125; let char=&#x27;&#x27;; if(axis===&#x27;x&#x27;)&#123; if(val&gt;0)&#123; char=&#x27;D&#x27;; &#125; else&#123; char=&#x27;U&#x27;; &#125; &#125; else&#123; if(val&gt;0)&#123; char=&#x27;R&#x27;; &#125; else&#123; char=&#x27;L&#x27;; &#125; &#125; for(let i=0;i&lt;Math.abs(val);i++)&#123; result=result+char; &#125; return result;&#125; 替换子串得到平衡字符串 2023-2-13 首先是题目条件的转化，将得到平衡字符串转化为寻找包含指定字符串的子串需要注意的是，寻找子串要尽可能降低时间复杂度，减少循环 var balancedString = function(s) &#123; let m=new Map(); for(let i=0;i&lt;s.length;i++)&#123; if(m.has(s.charAt(i)))&#123; m.set(s.charAt(i),m.get(s.charAt(i))+1); &#125; else&#123; m.set(s.charAt(i),1); &#125; &#125; let mod=new Map(); for(let x of m)&#123; if(x[1]&gt;(s.length/4))&#123; mod.set(x[0],x[1]-(s.length/4)); &#125; &#125; //接下来就是要找一个包含mod的子串 return help(s,mod);&#125;;let help=(s,m)=&gt;&#123; let l=0; for(let x of m)&#123; l+=x[1]; &#125; // result是我们要的子串长度 for(let result=l;result&lt;=s.length;result++)&#123; // 降低时间复杂度，对于一个长度只声明一次map，通过添加/删除元素来避免多次循环声明 let t=s.substring(0,result); let mymap=new Map(); for(let k=0;k&lt;t.length;k++)&#123; if(mymap.has(t.charAt(k)))&#123; mymap.set(t.charAt(k),mymap.get(t.charAt(k))+1); &#125; else&#123; mymap.set(t.charAt(k),1); &#125; &#125; for(let i=0;i+result&lt;=s.length;i++)&#123; if(i!=0)&#123; mymap.set(s.charAt(i-1),mymap.get(s.charAt(i-1))-1); if(mymap.has(s.charAt(i-1+result)))&#123; mymap.set(s.charAt(i-1+result),mymap.get(s.charAt(i-1+result))+1); &#125; else&#123; mymap.set(s.charAt(i-1+result),1); &#125; &#125; let signal=true; for(let u of m)&#123; if(!mymap.has(u[0]) || mymap.get(u[0])&lt;u[1])&#123; signal=false; &#125; &#125; if(signal)&#123; return result; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://ydl8686.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"软件安全课程实践","slug":"软件安全实践","date":"2023-02-10T03:02:03.000Z","updated":"2023-02-16T15:09:52.686Z","comments":true,"path":"posts/49951/","link":"","permalink":"http://ydl8686.github.io/posts/49951/","excerpt":"","text":"第一题 P239 12. 安装ubuntu sudo pip install flawfinder 使用root权限是为了将flawfinder加入环境变量，可以直接使用flawfinder作为命令，如果直接pip安装，接下来的操作会报错提示没有flawfinder命令 去知乎上搜索github上的c项目，并在ubuntu上以zip包形式下载下来 flawfinder --quiet --html $&#123;目标目录路径&#125; &gt; $&#123;输出路径&#125; 解析错误，需要将源代码转换至utf-8编码 sudo pip install cvt2utfcvt2utf convert ./ -b -i c cpp -x txt 将cpp和c文件转换为utf-8编码 再次运行flawrfinder命令，成功输出results.html 对比其他C/C++代码分析工具如RATS、Splint的异同 Flawfinder：一款开源的用于C/C++静态扫描的分析工具，其根据内部字典数据库进行静态搜索，匹配简单的缺陷与漏洞，flawfinder工具不需要编译C/C++代码，可以直接进行扫描分析。简单快速，优点是免费，且不需要编译。source RATS：一种用于C、C++、Python、Per和PHP代码的安全审计工具。它能够对源代码进行扫描，找出潜在的危险函数调用。该工具的最终目标并不是找出代码漏洞，而是为人工安全审计提供一个方便合理的起点。RATS结合了静态检查技术和深度语义分析技术检查缓冲区溢出漏洞。RATS遵守通用公共许可证GPL。RATS可以对整个工程代码进行检查，而不是单一文件。同时，RATS还可以检查数组的边界。source Splint：(原来的 LCLint) 是一个GNU免费授权的Lint程序，是一个动态检查C语言程序安全弱点和编写错误的程序。Splint会进行多种常规检查,包括未使用的变量,类型不一致,使用未定义变量,无法执行的代码,忽略返回值,执行路径未返回,无限循环等错误。source 第二题 P239 15. 下载American Fuzzy Lop项目 wget https://lcamtuf.coredump.cx/afl/releases/afl-latest.tgztar -zxvf afl-latest.tgzcd afl-2.52b 安装gcc编译器 sudo apt-get install gcc 编译以及安装 make // 从makefile中读取指令，然后编译sudo make install // 从makefile中读取指令，安装到指定的位置afl-fuzz // 验证是否安装成功 创建测试文件mytestfile.c #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;signal.h&gt; int vuln(char *str)&#123; int len = strlen(str); if(str[0] == &#x27;A&#x27; &amp;&amp; len == 66) &#123; raise(SIGSEGV); &#125; else if(str[0] == &#x27;F&#x27; &amp;&amp; len == 6) &#123; raise(SIGSEGV); &#125; else &#123; printf(&quot;it is good!\\n&quot;); &#125; return 0;&#125;int main(int argc, char *argv[])&#123; char buf[100]=&#123;0&#125;; gets(buf); //存在栈溢出漏洞 printf(buf); //存在格式化字符串漏洞 vuln(buf); return 0;&#125; 使用afl-gcc -g -o afl_test mytestfile.c进行编译插桩 创建fuzz_input和fuzz_output文件夹作为模糊测试的输入输出，并在fuzz_input下通过echo 666 &gt; testcase创建一个测试样本 开始模糊测试afl-fuzz -i fuzz_input -o fuzz_output ./afl_test 报错，系统配置问题导致出错 解决方案：root权限执行 `echo ecore > /proc/sys/kernel/core_pattern` 再次开始模糊测试 14分钟后 结果分析 crashes文件夹里面是产生crash的样例 hangs里面是产生超时的样例 queue里面是每个不同执行路径的测试用例 第三题 P239 16. ubuntu下安装Metasploit curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb &gt; msfinstall &amp;&amp; chmod 755 msfinstall &amp;&amp; ./msfinstall 在msf控制台输入search ms08-067搜索并使用ms08-067漏洞模块 show options查看当前配置 使用set RHOST 172.16.237.142命令设置靶机ip 需要关闭xp的防火墙，否则两台电脑无法互相ping通 使用set payload windows/meterpreter/reverse_tcp设置payload并再次查看配置 输入exploit命令开始对靶机进行渗透攻击，并进入特殊的payload：meterpreter 进行渗透操作 上传攻击机文件至靶机 截屏 clearev清除靶机日志 第四题 P304 25. 从github里160道crackme中找到一道Brad Soblesky.1.exe，使用vc6编写，在给定的输入框中输入正确的字符串才算成功，否则失败 使用OllyDbg打开上述exe文件 因为提示输入的内容、输入错误/成功的消息都是由字符串组成，所以我们搜索文本字符串 在这里，我们看到了输入错误的提示Incorrect try again!!，因为这一部分猜测是拿我们输入的字符串（可能进一步加密）和正确密码对比后的结果，所以我们双击找到起始函数位置下的断点，倒推对比的逻辑 这幅图里可以看到两种情况，分别是正确的和错误的，在此之前则是判断以及跳转的逻辑，重点关注 jnz 和 jmp jnz和jmp在汇编语言中都代表指令的跳转，前者表示上条指令结果不为0时转移，后者则是无条件跳转；指令中的SHORT规定了转移地址的标号为有符号的8位二进制数 尝试修改汇编代码，把跳转逻辑直接抹掉并保存 再次运行程序，发现无论输入什么都提示Correct way to go!!，破解成功 第五题 P342 12.熊猫烧香的病毒行为 运行病毒前 运行病毒后，通过对比可以发现多出了一个名为spoclsv.exe的进程，即熊猫烧香病毒创建出来的进程 启动项被修改 启动项可以用来设置开机自启动 注册表被编辑，并启动了对应的spoclsv.exe文件 注册表实际上是一个庞大的数据库，这个数据库记录了机器软硬件环境的各种信息，对操作系统及应用程序的正常运行至关重要。具体来讲，此数据库包含了Windows系统和应用程序的初始化信息、应用程序和文档文件的关联、硬件设备的说明、状态和属性等数据，操作系统和应用程序会对此数据库进行频繁存取，以保存和获取必要的数据source 在对应目录下发现了该exe文件 图标被修改 C盘根目录下生成setup.exe和autorun.inf文件 分析熊猫烧香的病毒结构 三个关键函数，作用分别是释放病毒并运行、感染其他文件、病毒的自我保护，这里选取第一个函数进行具体分析 拷贝病毒并运行 检查Desktop.ini文件是否存在，不存在则跳转 call是在调用字符串拼接函数，把拼接的结果完整路径放到EAX寄存器里，再次调用函数来判断该路径文件是否存在，如果文件不存在则跳转至00408110 如果存在则删掉该文件 还是调用同样的字符串拼接函数，之后把对应的文件删除 读取病毒文件到内存中 判断文件大小是否为0、是否被感染、是否第一次运行 test是为了判断文件大小是否为0，不为0则文件首地址放到EAX寄存器里；再CMP比较文件最后一个数据是否为0，为0表示没有被感染过；最后再CMP判断是否是第一次运行病毒程序 拷贝病毒到系统目录下，并且运行起来 小结 检查Desktoi.ini是否存在，存在就删除，不存在就创建 拷贝病毒文件到内存，并作相应的判断 拷贝到系统目录下，并且运行","categories":[],"tags":[{"name":"课业","slug":"课业","permalink":"http://ydl8686.github.io/tags/%E8%AF%BE%E4%B8%9A/"}]},{"title":"设计模式六大原则","slug":"设计模式六大原则","date":"2023-02-05T15:58:13.000Z","updated":"2023-02-11T03:31:34.929Z","comments":true,"path":"posts/12639/","link":"","permalink":"http://ydl8686.github.io/posts/12639/","excerpt":"","text":"单一职责原则","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://ydl8686.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"NestJs","slug":"nestjs","date":"2023-01-26T02:07:45.000Z","updated":"2023-01-28T04:17:08.489Z","comments":true,"path":"posts/23921/","link":"","permalink":"http://ydl8686.github.io/posts/23921/","excerpt":"","text":"前置知识restful api：每个资源都有对应的url来标识，通过不同的请求方法来对这个资源进行操作 请求发送与接收get对于get请求，前端有两种发起请求时携带参数的形式，一种是query参数，一种是动态path参数，两者在apifox中都写在Params中；在nestjs中通过Request注解来获取。 前者对应的数据是req.query，也可以直接通过Query注解获取； 后者通过在Get注解的路径参数中加入像:id这样的占位符，然后通过Request.params来获取，也可以直接通过Param注解来获取 如果一个get请求既有路径参数，又有query参数，那么只能通过Request注解来获取 post对于post请求，请求参数放在body中，nestjs依然可以通过Request注解来获取，对应的数据是req.body，也可以通过Body注解获取 在Body和Query注解中传入参数后，将会只获得对应参数key的value 除了以上注解外，还可以通过Header注解来获取请求头信息，可以用来获取cookie等 版本控制：一般通过uri中的version来指定服务的版本，也可以通过header或者accept来指定 sessionnestjs底层我们使用默认的express，安装好express-session和@types/express-session","categories":[],"tags":[{"name":"nestjs","slug":"nestjs","permalink":"http://ydl8686.github.io/tags/nestjs/"}]},{"title":"面试 | css","slug":"css","date":"2022-09-03T02:57:16.000Z","updated":"2023-02-12T04:55:44.824Z","comments":true,"path":"posts/19784/","link":"","permalink":"http://ydl8686.github.io/posts/19784/","excerpt":"","text":"1. 度量单位em、rem、vh、vw、%em相对长度单位，相对于当前对象内文本的字体尺寸，根据父元素的font-size大小变化而变化 rem相对长度单位，相对于根元素（即html元素）font-size的倍数，不会被它的父元素影响 rem布局的本质是等比缩放大屏用户需要有选择要更大字体或者更多内容的自由，如果使用rem布局，那么用户就只能被迫接受更大字体 vh和vwviewport height和viewport width，对应的是window.innerHeight和window.innerWidth，把浏览器导航栏下方到浏览器下方的距离化成了100份 %相对于父元素的大小 2. rem布局加载闪烁问题在使用rem布局时可能会出现加载闪烁的问题，也就是在加载的时候会出现元素一开始很小，闪烁后恢复正常大小的情况；这是因为引入的js文件中有修改font-size的部分，阻塞了后续的DOM解析和渲染；此时前面的DOM可以被正确地解析及渲染，所以会出现元素很小的情况，之后js解析完成后，元素恢复正常大小可以使用媒体查询来设置html元素的font-size；这样dom还没有渲染完但是已经可以正常展现的时候，显示的元素大小也是正确的 https://blog.csdn.net/u013778905/article/details/77938784https://yanhaijing.com/css/2017/09/29/principle-of-rem-layout/ 3. position中的relative和absoluterelative 相对于原来位置移动，设置后元素仍然处于文档流中，可能会撑大容器 absolute 元素会脱离文档流，没有设置偏移量的话就还在原来的位置，会影响其他元素的位置定位 在父元素没有设置相对定位(relative)或绝对定位(absolute+fixed)的情况下，元素相对于html元素偏移 父元素设置了相对定位或绝对定位后，元素会相对于离自己最近的设置了相对或绝对定位的父元素进行定位 https://www.runoob.com/w3cnote/css-position-static-relative-absolute-fixed.html 4. 三栏布局实现 grid布局.container &#123; display: grid; grid-template-columns: 100px auto 200px;&#125; flex布局.container &#123; display: flex;&#125;.item1 &#123; height: 60vh; width: 100px;&#125;.item2 &#123; height: 130vh; flex: 1 0 auto;&#125;.item3 &#123; height: 80vh; width: 240px;&#125; 浮动+BFC.column1 &#123; float: left; width: 100px; height: 300px; background-color: green;&#125;.column2 &#123; float: right; width: 100px; height: 300px; background-color: green;&#125;.column3 &#123; overflow: hidden; /*创建bfc*/ height: 300px; background-color: red;&#125; 5. BFC块级格式化上下文，其中格式化上下文是指页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用 高度塌陷：在文档流中，父元素的高度默认是被子元素撑开的，但是子元素设置成浮动后，子元素会脱离文档流，导致子元素无法撑起父元素的高度可以将父元素高度写死防止高度塌陷的问题，但是一旦高度写死，父元素的高度将不能自动适应子元素的高度 形成BFC的条件 浮动元素 position(absolute、fixed) display为inline-block，table-cell，table-caption overflow除了visible以外的值","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://ydl8686.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"面试 | js","slug":"面试lalala","date":"2022-01-18T07:15:26.000Z","updated":"2023-02-12T04:55:18.108Z","comments":true,"path":"posts/55448/","link":"","permalink":"http://ydl8686.github.io/posts/55448/","excerpt":"","text":"1. 原型与原型链概念原型（prototype）一个简单的对象，用于实现对象的属性继承。有了prototype，就不需要为每一个实例创建重复的属性方法，后代都能够使用；需要每个实例各自一份的，就放到构造函数里 构造函数可以通过new来新建一个对象的函数 function Student(name) &#123; this.name = name; this.sayBye = function () &#123; console.log(&#x27;bye&#x27;); &#125;&#125; 上面这个是一个普通的函数，但是通过new关键词来生成对象时就是构造函数 let boji = new Student(&#x27;波吉&#x27;); 如果不写new，这就是一个普通函数，它返回undefined。但是，如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this; 上面这个sayBye函数放在构造函数里，每个实例对象都各有一份，可以将其挪到原型上来减少内存开销 Student.prototype.sayBye = function() &#123; console.log(&#x27;bye&#x27;);&#125; 实例通过构造函数new创建出来的对象 上面的boji就是一个实例 关系每个构造函数都有一个prototype对象属性（注意，必须是构造函数，像箭头函数不是构造函数，没有prototype对象属性），叫做显式原型；有了prototype，就不需要为每一个实例创建重复的属性方法，后代都能够访问 实例只能通过__proto__指向原型，叫做隐式原型，通过原型链上的constructor指向构造函数（但是实际上只有prototype才有constructor） boji.hasOwnProperty(&#x27;constructor&#x27;) /* false */boji.__proto__.hasOwnProperty(&#x27;constructor&#x27;) /* true */ const cons = function() &#123; console.log(&#x27;波吉&#x27;);&#125;cons.prototype.name = &#x27;国王排名&#x27;;cons.rank = 1;const instance = new cons();instance.__proto__.name /* 国王排名 */instance.constructor.rank /* 1 */const instance1 = new cons();instance1.__proto__.name /* 国王排名 */instance1.constructor.rank /* 1 */cons === cons.prototype.constructor /* true */ 利用instance of判断一个对象是不是数组就是通过不停的.__proto__来判断是否会等于Array.prototype，如果一直到null都不等于，那么就不是数组 当访问对象的属性时，如果实例不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象Object.prototype，如还是没找到，则输出 undefined； 修改实例对象本身的属性，如果不存在对应的属性，则进行添加该属性，如果需要修改原型的属性时，则可以直接赋值原型的属性修改；但是这样会造成所有继承于该对象的实例的属性发生改变。 2. 数据类型基本类型String、Number、Boolean、null、undefined、Symbol Symbol在ES6中新引入的一种数据类型，用来表示“独一无二”的值，可以用作对象属性的唯一标识符 let info1 = &#123; name: &#x27;波吉&#x27;, description: &#x27;又善良又可爱&#x27;,&#125;;let info2 = &#123; description: &#x27;排名第一的国王&#x27;&#125; 现在想要汇总这两个对象为info，使用Object.assign(&#123;&#125;, info1, info2)，后一个描述会覆盖掉前一个描述，使用Symbol进行改写就可以了 let info1 = &#123; name: &#x27;波吉&#x27;, [Symbol(&#x27;description&#x27;)]: &#x27;又善良又可爱&#x27;,&#125;;let info2 = &#123; [Symbol(&#x27;description&#x27;)]: &#x27;排名第一的国王&#x27;&#125;let info = Object.assign(&#123;&#125;, info1, info2);let t = Object.getOwnPropertySymbols(info);for(let i=0; i&lt;t.length; i++)&#123; console.log(t[i], info[t[i]]);&#125;// Symbol(description) &#x27;又善良又可爱&#x27;// Symbol(description) &#x27;排名第一的国王&#x27; 其实Symbol里面的参数是可有可无的；本质上是生成了一个唯一的属性，所以汇总的时候不会覆盖 除此之外，不能通过info[Symbol(&#39;description&#39;)]来访问info1和info2里的描述，因为这种写法相当于又给info添加了一个唯一的属性，必须通过Object.getOwnPropertySymbols(info)来获取属性列表，进而取到对应的值 let t = Symbol();let info = &#123; name: &#x27;波吉&#x27;, t: &#x27;1&#x27;, [t]: &#x27;又善良又可爱&#x27;, // 变量做属性要加方括号&#125;;info.t // &#x27;1&#x27;info[&#x27;t&#x27;] // &#x27;1&#x27;info[t] // &#x27;又善良又可爱&#x27; 引用数据类型Object、Array、Function 3. 对象拷贝每个数据都会占有一块内存，通过变量来访问；如果拷贝之后的不同变量访问的是同一块内存，这种方式就是浅拷贝；如果是开辟了一块新的内存来拷贝的话，不同变量访问的就不是同一块内存，就是深拷贝 拷贝基本数据类型，例如Number、String都是深拷贝，深浅拷贝只针对对象，例如Array、Object 浅拷贝1.直接用= let a = &#123; name: &#x27;波吉&#x27;, rank: 1&#125;;let b = a;b.rank = 10086;a.rank /*10086*/b === a /* true */ 2.Object.assign 该方法可以把任意多个源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象；拷贝的是对象属性而不是对象本身 let a = &#123; name: &#x27;波吉&#x27;, rank: 1&#125;;/* 如果a是数组的话就是Object.assign([] ,a) */let b = Object.assign(&#123;&#125;, a);a === b /* false */ 像上面这个例子，a里面的属性都是基础数据类型，所以使用该方法之后就相当于深拷贝，但如果a里面的属性是对象的话，那么只是拷贝了引用；如果a是数组的话也是很类似的，看数组元素是数字还是对象，如果是数字就是深拷贝，对象就是浅拷贝 let a = &#123; name: &#x27;波吉&#x27;, friends: &#123; name1: &#x27;卡克&#x27;, name2: &#x27;snake&#x27; &#125;&#125;;let b = Object.assign(&#123;&#125;, a);b.name = &#x27;ydl&#x27;;b.friends.name2 = &#x27;蛇&#x27;;/* a为 &#123; name: &#x27;波吉&#x27;, friends: &#123; name1: &#x27;卡克&#x27;, name2: &#x27;蛇&#x27; &#125; &#125; */ 3.扩展运算符... 和Object.assign很类似，也是对对象属性或数组元素进行拷贝 let a = &#123; name: &#x27;波吉&#x27;, friends: &#123; name1: &#x27;卡克&#x27;, name2: &#x27;snake&#x27; &#125;&#125;;let b =&#123; ...a&#125; 深拷贝1.把对象转换成JSON字符串再转换回来 let obj1 = &#123; name: &#123; a: &quot;波吉&quot; &#125; &#125;;let obj2 = JSON.parse(JSON.stringify(obj1)); 能处理的数据只有能够被json直接表示的结构；当遇到循环引用的对象时会报错；当遇到函数、undefined、symbol时，如果这些是作为对象属性来stringfy，那么直接忽略；如果是作为数组元素，那么为null，如果单独拿来stringfy，则是undefined 循环引用 let obj1 = &#123;&#125;;let obj2 = &#123; b: obj1&#125;;obj1.a = obj2; 2.递归拷贝 Reflect.ownKeys()方法返回一个由目标对象自身的属性组成的数组，不包括原型链上继承的属性；考虑了Symbol、undefined、函数for in方法会考虑对象原型链上的继承的属性、undefined、函数，但是没考虑Symbol const deepClone=target=&gt;&#123; if(typeof target!==&#x27;object&#x27;)&#123; return target; &#125; let cloneTarget=Array.isArray(target)?[]:&#123;&#125;; for(let key of Reflect.ownKeys(target))&#123; cloneTarget[key]=deepClone(target[key]); &#125; return cloneTarget;&#125; 4. new运算符执行过程function Person(name) &#123; this.name = name;&#125;let boji = new Person(&#x27;波吉&#x27;); 以上面代码为例，new Person(&#39;波吉&#39;)可以解析为以下步骤 var obj = &#123;&#125;;obj.__proto__ = Person.prototype; var result = Person.call(obj, &#x27;波吉&#x27;)； return typeof result === &#x27;object&#x27; ? result||obj : obj; 创建一个继承自Person.prototype的空对象 将构造函数中的this指向obj，并传递参数’波吉’调用构造函数；执行完毕后，obj多了一个属性name，并且其值为波吉 返回对象给变量boji 如果构造函数本身返回了一个对象，那么new操作符返回的就是构造函数的返回值 如果构造函数返回的不是对象（例如null，undefined；虽然null是基本数据类型，但是typeof确是object）或者啥也没返回，那么new返回的就是继承自Person.prototype的新对象 手写实现// 法一function objGenerator() &#123; var obj = &#123;&#125;; cons = arguments[0]; obj.__proto__ = cons.prototype; var result = cons.apply(obj, [].slice.call(arguments).slice(1)); return typeof result === &#x27;object&#x27; ? result || obj : obj&#125;// 法二 更优雅function objGenerator(cons, ...arg) &#123; var obj = &#123;&#125;; obj.__proto__ = cons.prototype; var result = cons.apply(obj, arg); return typeof result === &#x27;object&#x27; ? result || obj : obj&#125;var p = objGenerator(Person, &#x27;波吉&#x27;); 5. apply、call、bind异同相同点这三个函数都是 Function原型上的方法 Function.prototype.call()，Function.prototype.apply，Function.prototype.bind()，因此所有的函数可以调用这三个方法。 三个函数的第一个参数都是必选的，表示this的指向，如果不需要指定this的指向，第一个参数可以为null 不同点函数调用apply、call时的返回值就是函数本身的返回值，而调用bind返回值是一个新的函数 apply接受的是一个参数数组，而call是多个参数","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://ydl8686.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"📖算法 | 剑指offer","slug":"剑指offer算法","date":"2022-01-17T08:50:36.000Z","updated":"2023-03-03T08:54:04.291Z","comments":true,"path":"posts/30446/","link":"","permalink":"http://ydl8686.github.io/posts/30446/","excerpt":"","text":"03 数组中重复的数字 解法1使用数据结构Set，利用其不会储存相同元素的特性来解决，不断往里面添加元素，看看Set大小有没有变，没变说明添加的就是重复的元素 var findRepeatNumber = function(nums) &#123; let mySet = new Set(); let size = mySet.size; let result = -1; nums.some(e =&gt; &#123; mySet.add(e); if(mySet.size === size) &#123; result = e; return true; &#125; size+=1; &#125;) return result;&#125;; 需要注意的是，在遍历数组nums的时候，不能采用forEach里return结果的方式，因为这样并不会跳出循环，break也是一样的；可以使用some和every方法来实现可跳出的循环，前者return true时跳出，后者return false跳出 解法2可以使用原地交换的方式，因为题目中说长度为n的数组，元素大小在[0,n-1]，有重复元素，那么在建立索引和值的对应关系上，一定会出现某个索引对应了两个值的情况，该值就是重复的元素 var findRepeatNumber = function(nums) &#123; let i=0; while(true)&#123; if(nums[i] !== i)&#123; /*防止出现1，1，1的情况*/ if(nums[nums[i]] === nums[i])&#123; return nums[i]; &#125; /*交换*/ [nums[nums[i]], nums[i]] =[nums[i], nums[nums[i]]]; &#125; else &#123; i++; &#125; &#125;&#125;; 04 二维数组中的查找 因为每行、每列都是递增顺序排列的，所以可以从右上角开始，如果当前数组中的数比target大，那么往左移；小，那么往下移；终止循环的条件是索引越界 var findNumberIn2DArray = function(matrix, target) &#123; let i = 0; let j = matrix[0].length-1; while(true) &#123; if(i&gt;matrix.length-1 || j&lt;0) &#123; return false; &#125; if(target === matrix[i][j]) &#123; return true; &#125; if(matrix[i][j] &gt; target) &#123; j--; &#125; else if(matrix[i][j] &lt; target) &#123; i++; &#125; &#125;&#125;; 05 替换空格 使用js的常用API就可以解决 // 法一var replaceSpace = function(s) &#123; return s.split(&#x27; &#x27;).join(&#x27;%20&#x27;);&#125;;// 法二var replaceSpace = function(s) &#123; // 必须要有g，不然只会替换第一个 return s.replace(/\\s/g, &#x27;%20&#x27;);&#125;; str.replace(/^\\s+|\\s+$/g, &#39;haloha&#39;)\\s : 表示 space ，空格+： 一个或多个^： 开始，^\\s，以空格开始$： 结束，\\s$，以空格结束|： 或者/g：global， 全局 06 从尾到头打印链表 先顺序遍历，把结果放到数组里，再reverse一下；或者使用unshift() /** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;number[]&#125; */// 法一var reversePrint = function(head) &#123; let result = []; while(head) &#123; result.push(head.val); head = head.next; &#125; result.reverse(); return result;&#125;;// 法二var reversePrint = function(head) &#123; let result = []; while(head) &#123; /*在数组首位置添加元素*/ result.unshift(head.val); head = head.next; &#125; return result;&#125;; 07 重建二叉树 核心是递归，根据preorder里的第一个元素，可以把inorder划分成左子树和右子树，再根据inoder里子树的大小，将preorder里划分成左子树和右子树，然后对应的进行递归操作即可 /** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;number[]&#125; preorder * @param &#123;number[]&#125; inorder * @return &#123;TreeNode&#125; */var buildTree = function(preorder, inorder) &#123; let result = new TreeNode(preorder[0]); // 特殊情况 // if(preorder.length === 1)&#123; // return result; // &#125; // else if(preorder.length === 0)&#123; // return null; // &#125; let index = inorder.indexOf(preorder[0]); result.left = buildTree(preorder.slice(1, 1+index), inorder.slice(0, index)); result.right = buildTree(preorder.slice(1+index), inorder.slice(index+1)); return result;&#125;; 10 斐波那契数列 解法1（动态规划）使用最简单的递归方法，，果然超时了，函数的入栈出栈的时间成本还是太高了，所以用了最简单的迭代，不过空间复杂度是O(N)，比较占用内存 var fib = function(n) &#123; if(n === 0 || n === 1) &#123; return n; &#125; let arr = [0, 1]; for(let i=2; i&lt;=n; i++) &#123; arr[i] = (arr[i-1] + arr[i-2])%1000000007; &#125; return arr[n];&#125;;// 还可以继续优化，因为n只与n-1，n-2有关，所以可以将空间复杂度降至O（1） 解法2使用递归的同时，再开辟一个新的数组用来存储已经算过的项，避免重复；例如算n-1和n-2这两项的时候都会用到第n-3项。所以在使用某一项的时候先看看这个数组里面有没有值，没有值再递归计算赋值 不过这样时间复杂度和空间复杂度都好高啊，还是使用动态规划最好 青蛙跳台阶也可以转换成类似的想法，关键是得到f(n)=f(n-1)+f(n-2)这个不变式 11 旋转数组的最小数字 线性遍历数组，发现后一个比前一个小，那么后一个就是答案；如果遍历完都没找到就说明这个数组是升序排列，返回第一个就好；时间复杂度O（N） var minArray = function(numbers) &#123; for(let i=0;i&lt;numbers.length-1;i++)&#123; if(numbers[i+1] &lt; numbers[i])&#123; return numbers[i+1]; &#125; &#125; return numbers[0]&#125;; 12 矩阵中的路径🌟 回溯 本题的思路核心是回溯，每次判断完一条路径是否符合条件后，要及时把状态恢复，以便其他条件递归 var exist = function(board, word) &#123; for(let i=0;i&lt;board.length;i++)&#123; for(let j=0;j&lt;board[0].length;j++)&#123; // 特殊情况，要判断的word只有一个字符 if(word.length===1 &amp;&amp; board[i][j]===word.charAt(0))&#123; return true; &#125; else if(board[i][j]===word.charAt(0))&#123; if(help(board,word.substring(1),i,j))&#123; return true; &#125; &#125; &#125; &#125; return false;&#125;;// 用来判断某一个字符是否存在符合条件的下一个字符var help = (board, word, i, j) =&gt; &#123; // 用来记录i,j位置的元素，用来回溯 let temp=board[i][j]; // 确保不会出现重复使用的情况 board[i][j]=&#x27;0&#x27;; let target = word.charAt(0); let signal1=false; let signal2=false; let signal3=false; let signal4=false; let res1=false; let res2=false; let res3=false; let res4=false; // 判断四个方向是否可行，并分别进行递归判断 if(j+1&lt;board[0].length &amp;&amp; board[i][j+1]===target)&#123; signal1=true; res1=help(board, word.substring(1),i,j+1); &#125; if(i+1&lt;board.length &amp;&amp; board[i+1][j]===target)&#123; signal2=true; res2=help(board, word.substring(1),i+1,j); &#125; if(j-1&gt;=0 &amp;&amp; board[i][j-1]===target)&#123; signal3=true; res3=help(board, word.substring(1),i,j-1); &#125; if(i-1&gt;=0 &amp;&amp; board[i-1][j]===target)&#123; signal4=true; res4=help(board, word.substring(1),i-1,j); &#125; // 当前状态的恢复 board[i][j]=temp; // 结果判定 if(word.length===1 &amp;&amp; (signal1||signal2||signal3||signal4))&#123; return true; &#125; else if(signal1||signal2||signal3||signal4)&#123; return res1||res2||res3||res4; &#125; else&#123; return false; &#125;&#125; 19 删除链表的倒数第 N 个结点 var removeNthFromEnd = function(head, n) &#123; let p=head; let target=head; for(let i=0;i&lt;n-1;i++)&#123; p=p.next; &#125; let pre=head; while(p.next)&#123; pre=target; p=p.next; target=target.next; &#125; /** 特殊情况，要删除的节点是头节点 链表只有一个元素，删除这个元素也可以归为上面👆“要删除的节点是头节点”这一类 **/ if(head===target)&#123; return target.next; &#125; pre.next=target.next; return head;&#125;; 29 顺时针打印矩阵 var spiralOrder = function(matrix) &#123; let result=[]; // 判断数组是否为空 // 不能[]===[] //false if(matrix.length===0)&#123; return result; &#125; help(matrix,result,0,0,matrix[0].length-1,matrix.length-1); return result;&#125;;let help=(matrix,result,l,t,r,b)=&gt;&#123; if(l===r &amp;&amp; t===b)&#123; result.push(matrix[t][l]); return; &#125; if(l&gt;r || t&gt;b)&#123; return; &#125; if(l&lt;r &amp;&amp; t==b)&#123; for(let i=l;i&lt;=r;i++)&#123; result.push(matrix[t][i]); &#125; &#125; else if(t&lt;b &amp;&amp; l==r)&#123; for(let i=t;i&lt;=b;i++)&#123; result.push(matrix[i][r]); &#125; &#125; else&#123; for(let i=l;i&lt;=r;i++)&#123; result.push(matrix[t][i]); &#125; for(let i=t+1;i&lt;=b;i++)&#123; result.push(matrix[i][r]); &#125; for(let i=r-1;i&gt;=l;i--)&#123; result.push(matrix[b][i]); &#125; for(let i=b-1;i&gt;t;i--)&#123; result.push(matrix[i][l]); &#125; &#125; l++; t++; r--; b--; help(matrix,result,l,t,r,b);&#125; 38 字符串的排列🌟 回溯 考察的是DFS+回溯，回溯体现在数组和字符串上，需要注意的是当字符串只有一个字符时的特殊情况 // 数组在某个index添加删除元素var permutation = function(s) &#123; if(!s)&#123; return []; &#125; let strArr=s.split(&#x27;&#x27;); let result=new Set(); let temp=&#x27;&#x27;; for(let i=0;i&lt;strArr.length;i++)&#123; temp+=strArr[i]; let char=strArr[i]; let charIndex=strArr.indexOf(char); strArr.splice(charIndex,1); help(strArr,result,temp); temp=temp.substring(0,temp.length-1); strArr.splice(charIndex,0,char); &#125; return Array.from(result);&#125;;let help=(strArr,result,temp)=&gt;&#123; // 两种情况 if(strArr.length===0)&#123; result.add(temp); return ; &#125; if(strArr.length===1)&#123; temp+=strArr[0]; result.add(temp); return ; &#125; else&#123; for(let i=0;i&lt;strArr.length;i++)&#123; temp+=strArr[i]; let char=strArr[i]; let charIndex=strArr.indexOf(char); strArr.splice(charIndex,1); help(strArr,result,temp); temp=temp.substring(0,temp.length-1); strArr.splice(charIndex,0,char); &#125; &#125;&#125; 44 数字序列中某一位的数字 找规律，计算不同位数占用索引的多少，倒推给定的n属于哪一个数，然后找到对应的某一位即可 var findNthDigit = function(n) &#123; if(n&lt;10)&#123; return n; &#125; let i=1; // i表示n所在数字的位数 let cp=n; while(cp-(Math.pow(10,i)-Math.pow(10,i-1))*i&gt;0)&#123; cp=cp-(Math.pow(10,i)-Math.pow(10,i-1))*i; i++; &#125; cp=cp-1; let t=Math.floor(cp/i); let m=cp%i; let tempResult=Math.pow(10,i-1)+t; return (tempResult+&#x27;&#x27;).charAt(m);&#125;; 50 第一个只出现一次的字符 解法1用两个数组来解决这个问题，一个数组用来存储遍历过的字符，一个数组用来存储已经重复过的的字符；遍历时遇到的字符在这两个数组内都没有出现时，进入第一个数组；如果在第一个数组中出现了，那么从第一个数组中剔除，并加入第二个数组；其余情况都不用考虑 不过好像其实也没有降低时间复杂度，因为使用到了indexOf来查找重复字符的索引，如果让自己来实现的话，又是O(N)的复杂度，综合下来还是O(N2)时间复杂度 var firstUniqChar = function(s) &#123; if(!s)&#123; return &#x27; &#x27;; &#125; let temp = []; let dupTemp = []; for(let i=0;i&lt;s.length;i++)&#123; if(dupTemp.indexOf(s[i]) === -1 &amp;&amp; temp.indexOf(s[i]) === -1)&#123; temp.push(s[i]); &#125; else if(temp.indexOf(s[i]) !== -1)&#123; temp.splice(temp.indexOf(s[i]), 1); dupTemp.push(s[i]); &#125; &#125; return temp[0]?temp[0]:&#x27; &#x27;;&#125;; 解法2使用map来解决；需要注意到的是，map对象是乱序的；但是按照key,value的形式来遍历时，是按照插入的顺序进行的 var firstUniqChar = function(s) &#123; var map = new Map(); for(let i=0;i&lt;s.length;i++)&#123; var cur = s.charAt(i); if(map.has(cur))&#123; // 如果已经出现过这个字符，那么设为false map.set(cur,false); &#125; else &#123; // 第一次遇到设置成true map.set(cur,true); &#125; &#125; for([key,value] of map)&#123; if(value)&#123; return key; &#125; &#125; return &#x27; &#x27;&#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://ydl8686.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"js常用API","slug":"js算法常用API","date":"2021-03-24T06:05:09.000Z","updated":"2023-02-13T07:52:54.722Z","comments":true,"path":"posts/14402/","link":"","permalink":"http://ydl8686.github.io/posts/14402/","excerpt":"总结了一些比较常用的数据结构以及对应的API","text":"总结了一些比较常用的数据结构以及对应的API 常用数据结构Arrayjs数组里面的元素类型可以都不一样 var a=new Array()var a=[1,2,3]a.length //NumberArray.isArray(a) //truea.toString() //返回数组的字符串形式&quot;1,2,3&quot;a.push(value,vlaue....) //在数组的末端添加一个或多个元素，并返回添加后的数组长度。pop() //用于删除数组的最后一个元素，并返回该元素shift() //用于删除数组的第一个元素，并返回该元素unshift(value) //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。join() //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。concat() //将参数数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。reverse() //用于颠倒数组中元素的顺序，改变了原数组slice(start_index, upto_index); //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。splice(index, count_to_remove, addElement1, addElement2, ...); //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。sort() //对原数组成员进行排序，默认是按照字典顺序排序。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。map() //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。forEach() //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。filter() //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。some() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。every() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。reduce() //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员）reduceRight() //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员）indexOf(s) //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置lastIndexOf(s) //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。 map//传入函数的形式不同a.map((x)=&gt;&#123; return -x;&#125;) //把a数组里的所有元素取反，返回新数组a.map(function(x)&#123; return Math.abs(x)&#125;) //取绝对值 forEacha.forEach((x,y,z)=&gt;&#123; console.log(x,y,z)&#125;)// forEach中不能使用break或return来跳出循环// 可以使用some和every方法来实现可跳出的循环，前者return true时跳出，后者return false跳出 filterarr.filter(x=&gt;&#123; if(x===&#x27;2&#x27;)&#123; return true &#125; else&#123; return false &#125;&#125;) //把符合条件的元素返回组成一个新数组 some/everyarr.some(x=&gt;&#123; if(x===&#x27;2&#x27;)&#123; return true &#125; else&#123; return false &#125;&#125;) //arr[1,2,&#x27;1&#x27;,&#x27;2&#x27;] truearr.every(x=&gt;&#123; if(x===&#x27;2&#x27;)&#123; return true &#125; else&#123; return false &#125;&#125;) //false reduce//z是索引，w是原数组t.reduce((x,y,z,w)=&gt;&#123; console.log(z) // 1 2 return x*y;&#125;) //arr[1,2,3] 6t.reduce((x,y,z,w)=&gt;&#123; console.log(z) // 0 1 2 return x*y;&#125;,0) 0 Stringvar s=new String()var s=&quot;12345&quot;var str=String.fromCharCode(97); //str=&#x27;a&#x27;s.lengths.chatAt(index) //返回指定位置的字符s.concat(s2) //返回新的连接后的字符串s.slice(start,end) //用于从原字符串取出子字符串并返回新字符串，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。s.substring(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。s.substr(start,length) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。s.indexOf(s) //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 s.lastIndexOf() //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。s.trim() //用于去除字符串两端的空格，返回一个新字符串s.toLowerCase() //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。s.toUpperCase() //全部转为大写s.localeCompare(s2) //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。s.match(regexp) //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。s.search() //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。s.replace(oldValue,newValue) //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。s.split() //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。 Mapvar m = new Map(); // 空Mapm.set(&#x27;Adam&#x27;, 67); // 添加新的key-valuem.has(&#x27;Adam&#x27;); // 是否存在key &#x27;Adam&#x27;: truem.get(&#x27;Adam&#x27;); // 67m.delete(&#x27;Adam&#x27;); // 删除key &#x27;Adam&#x27;//遍历mapfor([key,value] of map)&#123; console.log(key,value)&#125; Setvar s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3, 3]); // &#123;1, 2, 3&#125;s.add(4);s; // Set &#123;1, 2, 3, 4&#125;s.delete(3);s; // Set &#123;1, 2, 4&#125;s.size; // 3s.has(2); // true 常用方法进制转换var value = parseInt(12).toString(2); //parsetInt里面是要转换的数字，toString里面是要转换的进制，如果要转换为其他进制，替换掉就好了 判断变量类型判断变量类型一般用typeof就可以了 声明相同元素数组new Array(100).fill(1)数组长度为100，每个元素都是1 声明固定长宽的二维数组/** * 10列10行 **/let arr = new Array(10);for(let i = 0;i &lt; arr.length; i++)&#123; arr[i] = new Array(10).fill(0);&#125; 遍历Array、Map、SetArray可以使用下标，Map和Set不能使用下标，ES6引入了iterable类型，Array,Map,Set都属于iterable类型，它们可以使用for…of循环来遍历 let a = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;];let s = new Set([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]);let m = new Map([[1, &#x27;x&#x27;], [2, &#x27;y&#x27;], [3, &#x27;z&#x27;]]);for (let x of a) &#123; log(x); &#125;for (let x of s) &#123; log(x);&#125;for (let x of m) &#123; log(x[0] + &#x27;=&#x27; + x[1]); // 分别是key和value&#125; 字符与ASCII码互转将字符转为ascii码 let char=&#x27;a&#x27;;let num=str.charCodeAt(); // 97 将ascii码转为对应字符 let num=97;let char=String.fromCharCode(num); 小数取整向上取整Math.ceil(3/2) //2 向下取整Math.floor(3/2) //1 四舍五入取整Math.round(3/2) //2 数组索引处添加/删除都是对原数组进行操作删除arr.splice(index, 1)添加arr.splice(index, 0, content)","categories":[],"tags":[{"name":"API","slug":"API","permalink":"http://ydl8686.github.io/tags/API/"}]},{"title":"快捷键","slug":"快捷键","date":"2021-03-24T02:57:01.000Z","updated":"2022-12-31T04:05:37.193Z","comments":true,"path":"posts/20356/","link":"","permalink":"http://ydl8686.github.io/posts/20356/","excerpt":"","text":"mac1.ctrl+左/右：切换左右桌面2.ctrl+command+q：锁屏 mac下的chrome1.command+n：打开新窗口2.command+t：打开新标签页3.command+option+左/右：切换前/后标签页4.command+w：关闭当前标签页 mac下的vscode1.ctrl+反引号：显示终端2.command+ctrl+f：全屏/退出全屏3.option+点击：插入多个光标4.command+i：选中当前行5.command+shift+k：删除当前行6.option+上/下：移动上下行7.command+enter：下一行插入8.command+shift+enter：上一行插入9.shift+option（ALT）+f：格式化代码","categories":[],"tags":[{"name":"实用技巧","slug":"实用技巧","permalink":"http://ydl8686.github.io/tags/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}]}],"categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://ydl8686.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"课业","slug":"课业","permalink":"http://ydl8686.github.io/tags/%E8%AF%BE%E4%B8%9A/"},{"name":"算法","slug":"算法","permalink":"http://ydl8686.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"设计模式","slug":"设计模式","permalink":"http://ydl8686.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"nestjs","slug":"nestjs","permalink":"http://ydl8686.github.io/tags/nestjs/"},{"name":"API","slug":"API","permalink":"http://ydl8686.github.io/tags/API/"},{"name":"实用技巧","slug":"实用技巧","permalink":"http://ydl8686.github.io/tags/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}]}