{"meta":{"title":"Ydl's Blog","subtitle":null,"description":"待葡萄成熟透","author":"Ydl","url":"http://ydl8686.github.io","root":"/"},"pages":[{"title":"Project","date":"2021-05-06T12:20:17.863Z","updated":"2021-05-06T12:20:17.863Z","comments":true,"path":"project/index.html","permalink":"http://ydl8686.github.io/project/index.html","excerpt":"","text":""},{"title":"Tags","date":"2021-05-06T12:20:17.865Z","updated":"2021-05-06T12:20:17.865Z","comments":true,"path":"tags/index.html","permalink":"http://ydl8686.github.io/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2021-05-06T12:20:17.862Z","updated":"2021-05-06T12:20:17.861Z","comments":true,"path":"about/index.html","permalink":"http://ydl8686.github.io/about/index.html","excerpt":"","text":""},{"title":"相册","slug":"photos","date":"2021-02-18T08:39:30.229Z","updated":"2021-02-18T08:39:30.229Z","comments":false,"path":"photos/index.html","permalink":"http://ydl8686.github.io/photos/index.html","excerpt":"","text":"Photos 图片正在加载中… (function() { var loadScript = function(path) { var $script = document.createElement('script') document.getElementsByTagName('body')[0].appendChild($script) $script.setAttribute('src', path) } setTimeout(function() { loadScript('./ins.js') }, 0) })()"},{"title":"","date":"2021-02-18T08:39:30.229Z","updated":"2021-02-18T08:39:30.229Z","comments":true,"path":"photos/ins.css","permalink":"http://ydl8686.github.io/photos/ins.css","excerpt":"","text":"#post-instagram{ padding: 30px; } #post-instagram .article-entry{ padding-right: 0; } .instagram{ background-color:#F5FFFF; position: relative; min-height: 500px; } .instagram img { width: 100%; } .instagram .year { font-size: 16px; } .instagram .open-ins{ padding: 10px 0; color: #cdcdcd; } .instagram .open-ins:hover{ color: #657b83; } .instagram .year{ display: inline; } .instagram .thumb { width: 25%; height: 0; padding-bottom: 25%; position: relative; display: inline-block; text-align: center; background: #ededed; outline: 1px solid #ddd; } .instagram .thumb a { position: relative; } .instagram .album h1 em{ font-style: normal; font-size: 14px; margin-left: 10px; } .instagram .album ul{ display: flex; flex-wrap: wrap; clear: both; width: 100%; text-align: left; } .instagram .album li{ list-style: none; display: inline-block; box-sizing: border-box; padding: 0 5px; margin-bottom: -10px; height: 0; width: 25%; position: relative; padding-bottom: 25%; } .instagram .album li:before{ display: none; } .instagram .album div.img-box{ position: absolute; width: 90%; height: 90%; -webkit-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); -moz-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); } .instagram .album div.img-box img{ width: 100%; height: 100%; position: absolute; z-index: 2; } .instagram .album div.img-box .img-bg{ position: absolute; top: 0; left: 0; bottom: 0px; width: 100%; margin: -5px; padding: 5px; -webkit-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -moz-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -webkit-transition: all 0.15s ease-out 0.1s; -moz-transition: all 0.15s ease-out 0.1s; -o-transition: all 0.15s ease-out 0.1s; transition: all 0.15s ease-out 0.1s; opacity: 0.2; cursor: pointer; display: block; z-index: 3; } .instagram .album div.img-box .icon { font-size: 14px; position: absolute; left: 50%; top: 50%; margin-left: -7px; margin-top: -7px; color: #999; z-index: 1; } .instagram .album div.img-box .img-bg:hover{ opacity: 0; } .photos-btn-wrap { border-bottom: 1px solid #e5e5e5; margin-bottom: 20px; } .photos-btn { font-size: 16px; color: #333; margin-bottom: -4px; padding: 5px 8px 3px; } .photos-btn.active { color: #08c; border: 1px solid #e5e5e5; border-bottom: 5px solid #fff; } @media screen and (max-width:600px) { .instagram .thumb { width: 50%; padding-bottom: 50%; } .instagram .album li { width: 100%; position: relative; padding-bottom: 100%; text-align: center; } .instagram .album div.img-box{ margin: 0; width: 90%; height: 90%; } }"},{"title":"","date":"2021-02-18T08:39:30.230Z","updated":"2021-02-18T08:39:30.230Z","comments":true,"path":"photos/lazyload.min.js","permalink":"http://ydl8686.github.io/photos/lazyload.min.js","excerpt":"","text":"/*! * An jQuery | zepto plugin for lazy loading images. * author -> jieyou * see https://github.com/jieyou/lazyload * use some tuupola's code https://github.com/tuupola/jquery_lazyload (BSD) * use component's throttle https://github.com/component/throttle (MIT) */ !function(a){\"function\"==typeof define&&define.amd?define([\"jquery\"],a):a(window.jQuery||window.Zepto)}(function(a){function g(){}function h(a,b){var e;return e=b._$container==d?(\"innerHeight\"in c?c.innerHeight:d.height())+d.scrollTop():b._$container.offset().top+b._$container.height(),e=b.offset().left+e.threshold+b.width()}function l(a,b){var c=0;a.each(function(d){function g(){f.trigger(\"_lazyload_appear\"),c=0}var f=a.eq(d);if(!(f.width()b.failure_limit)return!1}else g()})}function m(a){return a.filter(function(b){return!a.eq(b)._lazyload_loadStarted})}function n(a,b){function h(){f=0,g=+new Date,e=a.apply(c,d),c=null,d=null}var c,d,e,f,g=0;return function(){c=this,d=arguments;var a=new Date-g;return f||(a>=b?h():f=setTimeout(h,b-a)),e}}var f,c=window,d=a(c),e={threshold:0,failure_limit:0,event:\"scroll\",effect:\"show\",effect_params:null,container:c,data_attribute:\"original\",data_srcset_attribute:\"original-srcset\",skip_invisible:!0,appear:g,load:g,vertical_only:!1,check_appear_throttle_time:300,url_rewriter_fn:g,no_fake_img_loader:!1,placeholder_data_img:\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\",placeholder_real_img:\"http://ditu.baidu.cn/yyfm/lazyload/0.0.1/img/placeholder.png\"};f=function(){var a=Object.prototype.toString;return function(b){return a.call(b).replace(\"[object \",\"\").replace(\"]\",\"\")}}(),a.fn.hasOwnProperty(\"lazyload\")||(a.fn.lazyload=function(b){var i,j,k,h=this;return a.isPlainObject(b)||(b={}),a.each(e,function(g,h){var i=f(b[g]);-1!=a.inArray(g,[\"threshold\",\"failure_limit\",\"check_appear_throttle_time\"])?\"String\"==i?b[g]=parseInt(b[g],10):\"Number\"!=i&&(b[g]=h):\"container\"==g?(b._$container=b.hasOwnProperty(g)?b[g]==c||b[g]==document?d:a(b[g]):d,delete b.container):!e.hasOwnProperty(g)||b.hasOwnProperty(g)&&i==f(e[g])||(b[g]=h)}),i=\"scroll\"==b.event,k=0==b.check_appear_throttle_time?l:n(l,b.check_appear_throttle_time),j=i||\"scrollstart\"==b.event||\"scrollstop\"==b.event,h.each(function(c){var e=this,f=h.eq(c),i=f.attr(\"src\"),k=f.attr(\"data-\"+b.data_attribute),l=b.url_rewriter_fn==g?k:b.url_rewriter_fn.call(e,f,k),n=f.attr(\"data-\"+b.data_srcset_attribute),o=f.is(\"img\");return 1==f._lazyload_loadStarted||i==l?(f._lazyload_loadStarted=!0,h=m(h),void 0):(f._lazyload_loadStarted=!1,o&&!i&&f.one(\"error\",function(){f.attr(\"src\",b.placeholder_real_img)}).attr(\"src\",b.placeholder_data_img),f.one(\"_lazyload_appear\",function(){function i(){d&&f.hide(),o?(n&&f.attr(\"srcset\",n),l&&f.attr(\"src\",l)):f.css(\"background-image\",'url(\"'+l+'\")'),d&&f[b.effect].apply(f,c?b.effect_params:[]),h=m(h)}var d,c=a.isArray(b.effect_params);f._lazyload_loadStarted||(d=\"show\"!=b.effect&&a.fn[b.effect]&&(!b.effect_params||c&&0==b.effect_params.length),b.appear!=g&&b.appear.call(e,f,h.length,b),f._lazyload_loadStarted=!0,b.no_fake_img_loader||n?(b.load!=g&&f.one(\"load\",function(){b.load.call(e,f,h.length,b)}),i()):a(\"\").one(\"load\",function(){i(),b.load!=g&&b.load.call(e,f,h.length,b)}).attr(\"src\",l))}),j||f.on(b.event,function(){f._lazyload_loadStarted||f.trigger(\"_lazyload_appear\")}),void 0)}),j&&b._$container.on(b.event,function(){k(h,b)}),d.on(\"resize load\",function(){k(h,b)}),a(function(){k(h,b)}),this})});"},{"title":"","date":"2021-02-18T08:39:30.230Z","updated":"2021-02-18T08:39:30.230Z","comments":true,"path":"photos/package.json","permalink":"http://ydl8686.github.io/photos/package.json","excerpt":"","text":"{\"name\":\"hexo-site\",\"version\":\"0.0.0\",\"private\":true,\"hexo\":{\"version\":\"3.2.2\"},\"dependencies\":{\"hexo\":\"^3.1.0\",\"hexo-deployer-git\":\"0.0.4\",\"hexo-deployer-rsync\":\"^0.1.2\",\"hexo-generator-archive\":\"^0.1.3\",\"hexo-generator-baidu-sitemap\":\"^0.1.2\",\"hexo-generator-category\":\"^0.1.3\",\"hexo-generator-feed\":\"^1.2.0\",\"hexo-generator-index\":\"^0.1.3\",\"hexo-generator-json-content\":\"^3.0.1\",\"hexo-generator-json-feed\":\"^1.0.0\",\"hexo-generator-sitemap\":\"^1.1.2\",\"hexo-generator-tag\":\"^0.1.2\",\"hexo-helper-qrcode\":\"^1.0.1\",\"hexo-renderer-ejs\":\"^0.1.0\",\"hexo-renderer-marked\":\"^0.2.5\",\"hexo-renderer-stylus\":\"^0.2.3\",\"hexo-server\":\"^0.1.2\"}}"},{"title":"","date":"2021-02-18T11:22:01.123Z","updated":"2021-02-18T11:22:01.123Z","comments":true,"path":"photos/data.json","permalink":"http://ydl8686.github.io/photos/data.json","excerpt":"","text":"{\"list\":[{\"date\":\"2021-2-\",\"arr\":{\"year\":2021,\"month\":2,\"link\":[\"2021-2-17_狼小魂大大.JPG\",\"2021-2-18_最近真的很爱浩浩和介叔啊.JPG\",\"2021-2-18_要吃冰淇淋么.JPG\"],\"text\":[\"狼小魂大大\",\"最近真的很爱浩浩和介叔啊\",\"要吃冰淇淋么\"],\"type\":[\"image\",\"image\",\"image\"]}}]}"},{"title":"","date":"2021-02-18T11:21:06.931Z","updated":"2021-02-18T11:21:06.931Z","comments":true,"path":"photos/README.html","permalink":"http://ydl8686.github.io/photos/README.html","excerpt":"","text":"Blog-Back-Up存储博客照片"},{"title":"","date":"2021-02-18T08:49:06.952Z","updated":"2021-02-18T08:39:30.229Z","comments":true,"path":"photos/ins.js","permalink":"http://ydl8686.github.io/photos/ins.js","excerpt":"","text":"/******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports; /******/ /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ exports: {}, /******/ id: moduleId, /******/ loaded: false /******/ }; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.loaded = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = \"/dist/\"; /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(0); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(1); var _view = __webpack_require__(2); var _view2 = _interopRequireDefault(_view); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } /** * @name impush-client * @description 这个项目让我发家致富… * @date 2016-12-1 */ var _collection = []; var _count = 0; var searchData; function addMask(elem) { var rect = elem.getBoundingClientRect(); var style = getComputedStyle(elem, null); var mask = document.createElement('i'); mask.className = 'icon-film'; mask.style.color = '#fff'; mask.style.fontSize = '26px'; mask.style.position = 'absolute'; mask.style.right = '10px'; mask.style.bottom = '10px'; mask.style.zIndex = 1; elem.parentNode.appendChild(mask); } var createVideoIncon = function createVideoIncon() { var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]'); for (var i = 0, len = $videoImg.length; i < len; i++) { addMask($videoImg[i]); } }; var render = function render(res) { var ulTmpl = \"\"; for (var j = 0, len2 = res.list.length; j < len2; j++) { var data = res.list[j].arr; var liTmpl = \"\"; for (var i = 0, len = data.link.length; i < len; i++) { var minSrc = 'https://raw.githubusercontent.com/ydl8686/Blog-Back-Up/master/min_photos/' + data.link[i]; var src = 'https://raw.githubusercontent.com/ydl8686/Blog-Back-Up/master/photos/' + data.link[i]; var type = data.type[i]; var target = src + (type === 'video' ? '.mp4' : '.jpg'); src += ''; liTmpl += '\\ \\ \\ \\ ' + data.text[i] + '\\ '; } ulTmpl = ulTmpl + '' + data.year + '年' + data.month + '月\\ ' + liTmpl + '\\ '; } document.querySelector('.instagram').innerHTML = '' + ulTmpl + ''; createVideoIncon(); _view2.default.init(); }; var replacer = function replacer(str) { var arr = str.split(\"/\"); return \"/assets/ins/\" + arr[arr.length - 1]; }; var ctrler = function ctrler(data) { var imgObj = {}; for (var i = 0, len = data.length; i < len; i++) { var y = data[i].y; var m = data[i].m; var src = replacer(data[i].src); var text = data[i].text; var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m); if (imgObj[key]) { imgObj[key].srclist.push(src); imgObj[key].text.push(text); } else { imgObj[key] = { year: y, month: m, srclist: [src], text: [text] }; } } render(imgObj); }; function loadData(success) { if (!searchData) { var xhr = new XMLHttpRequest(); xhr.open('GET', './data.json?t=' + +new Date(), true); xhr.onload = function() { if (this.status >= 200 && this.status < 300) { var res = JSON.parse(this.response); searchData = res; success(searchData); } else { console.error(this.statusText); } }; xhr.onerror = function() { console.error(this.statusText); }; xhr.send(); } else { success(searchData); } } var Ins = { init: function init() { loadData(function(data) { render(data); }); } }; Ins.init(); // export default impush; /***/ }, /* 1 */ /***/ function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */ (function(global) { 'use strict'; var inViewport = __webpack_require__(3); var lazyAttrs = ['data-src']; global.lzld = lazyload(); // Provide libs using getAttribute early to get the good src // and not the fake data-src replaceGetAttribute('Image'); replaceGetAttribute('IFrame'); function registerLazyAttr(attr) { if (indexOf.call(lazyAttrs, attr) === -1) { lazyAttrs.push(attr); } } function lazyload(opts) { opts = merge({ 'offset': 333, 'src': 'data-src', 'container': false }, opts || {}); if (typeof opts.src === 'string') { registerLazyAttr(opts.src); } var elts = []; function show(elt) { var src = findRealSrc(elt); if (src) { elt.src = src; } elt.setAttribute('data-lzled', true); elts[indexOf.call(elts, elt)] = null; } function findRealSrc(elt) { if (typeof opts.src === 'function') { return opts.src(elt); } return elt.getAttribute(opts.src); } function register(elt) { elt.onload = null; elt.removeAttribute('onload'); elt.onerror = null; elt.removeAttribute('onerror'); if (indexOf.call(elts, elt) === -1) { inViewport(elt, opts, show); } } return register; } function replaceGetAttribute(elementName) { var fullname = 'HTML' + elementName + 'Element'; if (fullname in global === false) { return; } var original = global[fullname].prototype.getAttribute; global[fullname].prototype.getAttribute = function(name) { if (name === 'src') { var realSrc; for (var i = 0, max = lazyAttrs.length; i < max; i++) { realSrc = original.call(this, lazyAttrs[i]); if (realSrc) { break; } } return realSrc || original.call(this, name); } // our own lazyloader will go through theses lines // because we use getAttribute(opts.src) return original.call(this, name); }; } function merge(defaults, opts) { for (var name in defaults) { if (opts[name] === undefined) { opts[name] = defaults[name]; } } return opts; } // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html function indexOf(value) { for (var i = this.length; i-- && this[i] !== value;) {} return i; } module.exports = lazyload; // export default impush; /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ }, /* 2 */ /***/ function(module, exports) { 'use strict'; var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) { // parse slide data (url, title, size ...) from DOM elements // (children of gallerySelector) var parseThumbnailElements = function parseThumbnailElements(el) { el = el.parentNode.parentNode; var thumbElements = el.getElementsByClassName('thumb'), numNodes = thumbElements.length, items = [], figureEl, linkEl, size, type, // video or not target, item; for (var i = 0; i < numNodes; i++) { figureEl = thumbElements[i]; // // include only element nodes if (figureEl.nodeType !== 1) { continue; } linkEl = figureEl.children[0]; // size = linkEl.getAttribute('data-size').split('x'); type = linkEl.getAttribute('data-type'); target = linkEl.getAttribute('data-target'); // create slide object item = { src: linkEl.getAttribute('href'), w: parseInt(size[0], 10), h: parseInt(size[1], 10) }; if (figureEl.children.length > 1) { item.title = figureEl.children[1].innerHTML; } if (linkEl.children.length > 0) { item.msrc = linkEl.children[0].getAttribute('src'); item.type = type; item.target = target; item.html = ''; if (type === 'video') { //item.src = null; } } item.el = figureEl; // save link to element for getThumbBoundsFn items.push(item); } return items; }; // find nearest parent element var closest = function closest(el, fn) { return el && (fn(el) ? el : closest(el.parentNode, fn)); }; // triggers when user clicks on thumbnail var onThumbnailsClick = function onThumbnailsClick(e) { e = e || window.event; e.preventDefault ? e.preventDefault() : e.returnValue = false; var eTarget = e.target || e.srcElement; // find root element of slide var clickedListItem = closest(eTarget, function(el) { return el.tagName && el.tagName.toUpperCase() === 'FIGURE'; }); if (!clickedListItem) { return; } // find index of clicked item by looping through all child nodes // alternatively, you may define index via data- attribute var clickedGallery = clickedListItem.parentNode, // childNodes = clickedListItem.parentNode.childNodes, // numChildNodes = childNodes.length, childNodes = document.getElementsByClassName('thumb'), numChildNodes = childNodes.length, nodeIndex = 0, index; for (var i = 0; i < numChildNodes; i++) { if (childNodes[i].nodeType !== 1) { continue; } if (childNodes[i] === clickedListItem) { index = nodeIndex; break; } nodeIndex++; } if (index >= 0) { // open PhotoSwipe if valid index found openPhotoSwipe(index, clickedGallery); } return false; }; // parse picture index and gallery index from URL (#&pid=1&gid=2) var photoswipeParseHash = function photoswipeParseHash() { var hash = window.location.hash.substring(1), params = {}; if (hash.length < 5) { return params; } var vars = hash.split('&'); for (var i = 0; i < vars.length; i++) { if (!vars[i]) { continue; } var pair = vars[i].split('='); if (pair.length < 2) { continue; } params[pair[0]] = pair[1]; } if (params.gid) { params.gid = parseInt(params.gid, 10); } return params; }; var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) { var pswpElement = document.querySelectorAll('.pswp')[0], gallery, options, items; items = parseThumbnailElements(galleryElement); // define options (if needed) options = { // define gallery index (for URL) galleryUID: galleryElement.getAttribute('data-pswp-uid'), getThumbBoundsFn: function getThumbBoundsFn(index) { // See Options -> getThumbBoundsFn section of documentation for more info var thumbnail = items[index].el.getElementsByTagName('img')[0], // find thumbnail pageYScroll = window.pageYOffset || document.documentElement.scrollTop, rect = thumbnail.getBoundingClientRect(); return { x: rect.left, y: rect.top + pageYScroll, w: rect.width }; } }; // PhotoSwipe opened from URL if (fromURL) { if (options.galleryPIDs) { // parse real index when custom PIDs are used // http://photoswipe.com/documentation/faq.html#custom-pid-in-url for (var j = 0; j < items.length; j++) { if (items[j].pid == index) { options.index = j; break; } } } else { // in URL indexes start from 1 options.index = parseInt(index, 10) - 1; } } else { options.index = parseInt(index, 10); } // exit if index not found if (isNaN(options.index)) { return; } if (disableAnimation) { options.showAnimationDuration = 0; } // Pass data to PhotoSwipe and initialize it gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options); gallery.init(); var $tempVideo; var stopVideoHandle = function stopVideoHandle() { if ($tempVideo) { $tempVideo.remove(); $tempVideo = null; } }; var changeHandle = function changeHandle() { var item = gallery.currItem; stopVideoHandle(); if (item.type === 'video') { var $ctn = item.container; var style = $ctn.getElementsByClassName('pswp__img')[0].style; var $video = document.createElement('video'); $video.setAttribute('autoplay', 'autoplay'); $video.setAttribute('controls', 'controls'); $video.setAttribute('src', item.target); $video.style.width = style.width; $video.style.height = style.height; $video.style.position = 'absolute'; $video.style.zIndex = 2; $tempVideo = $video; $ctn.appendChild($video); } }; gallery.listen('initialZoomIn', changeHandle); gallery.listen('afterChange', changeHandle); gallery.listen('initialZoomOut', stopVideoHandle); }; // loop through all gallery elements and bind events var galleryElements = document.querySelectorAll(gallerySelector); for (var i = 0, l = galleryElements.length; i < l; i++) { galleryElements[i].setAttribute('data-pswp-uid', i + 1); galleryElements[i].onclick = onThumbnailsClick; } // Parse URL and open gallery if it contains #&pid=3&gid=1 var hashData = photoswipeParseHash(); if (hashData.pid && hashData.gid) { openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true); } }; var Viewer = function() { function init() { initPhotoSwipeFromDOM('.photos'); } return { init: init }; }(); module.exports = Viewer; /***/ }, /* 3 */ /***/ function(module, exports) { /* WEBPACK VAR INJECTION */ (function(global) { module.exports = inViewport; var instances = []; var supportsMutationObserver = typeof global.MutationObserver === 'function'; function inViewport(elt, params, cb) { var opts = { container: global.document.body, offset: 0 }; if (params === undefined || typeof params === 'function') { cb = params; params = {}; } var container = opts.container = params.container || opts.container; var offset = opts.offset = params.offset || opts.offset; for (var i = 0; i < instances.length; i++) { if (instances[i].container === container) { return instances[i].isInViewport(elt, offset, cb); } } return instances[ instances.push(createInViewport(container)) - 1 ].isInViewport(elt, offset, cb); } function addEvent(el, type, fn) { if (el.attachEvent) { el.attachEvent('on' + type, fn); } else { el.addEventListener(type, fn, false); } } function debounce(func, wait, immediate) { var timeout; return function() { var context = this, args = arguments; var callNow = immediate && !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); function later() { timeout = null; if (!immediate) func.apply(context, args); } }; } // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708 var contains = function() { if (!global.document) { return true; } return global.document.documentElement.compareDocumentPosition ? function(a, b) { return !!(a.compareDocumentPosition(b) & 16); } : global.document.documentElement.contains ? function(a, b) { return a !== b && (a.contains ? a.contains(b) : false); } : function(a, b) { while (b = b.parentNode) { if (b === a) { return true; } } return false; }; } function createInViewport(container) { var watches = createWatches(); var scrollContainer = container === global.document.body ? global : container; var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15); addEvent(scrollContainer, 'scroll', debouncedCheck); if (scrollContainer === global) { addEvent(global, 'resize', debouncedCheck); } if (supportsMutationObserver) { observeDOM(watches, container, debouncedCheck); } // failsafe check, every 200ms we check for visible images // usecase: a hidden parent containing eleements // when the parent becomes visible, we have no event that the children // became visible setInterval(debouncedCheck, 150); function isInViewport(elt, offset, cb) { if (!cb) { return isVisible(elt, offset); } var remote = createRemote(elt, offset, cb); remote.watch(); return remote; } function createRemote(elt, offset, cb) { function watch() { watches.add(elt, offset, cb); } function dispose() { watches.remove(elt); } return { watch: watch, dispose: dispose }; } function watchInViewport(elt, offset, cb) { if (isVisible(elt, offset)) { watches.remove(elt); cb(elt); } } function isVisible(elt, offset) { if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) { return false; } // Check if the element is visible // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js if (!elt.offsetWidth || !elt.offsetHeight) { return false; } var eltRect = elt.getBoundingClientRect(); var viewport = {}; if (container === global.document.body) { viewport = { top: -offset, left: -offset, right: global.document.documentElement.clientWidth + offset, bottom: global.document.documentElement.clientHeight + offset }; } else { var containerRect = container.getBoundingClientRect(); viewport = { top: containerRect.top - offset, left: containerRect.left - offset, right: containerRect.right + offset, bottom: containerRect.bottom + offset }; } // The element must overlap with the visible part of the viewport var visible = ( (eltRect.right > viewport.left) && (eltRect.left < viewport.right) && (eltRect.bottom > viewport.top) && (eltRect.top < viewport.bottom) ); return visible; } return { container: container, isInViewport: isInViewport }; } function createWatches() { var watches = []; function add(elt, offset, cb) { if (!isWatched(elt)) { watches.push([elt, offset, cb]); } } function remove(elt) { var pos = indexOf(elt); if (pos !== -1) { watches.splice(pos, 1); } } function indexOf(elt) { for (var i = watches.length - 1; i >= 0; i--) { if (watches[i][0] === elt) { return i; } } return -1; } function isWatched(elt) { return indexOf(elt) !== -1; } function checkAll(cb) { return function() { for (var i = watches.length - 1; i >= 0; i--) { cb.apply(this, watches[i]); } }; } return { add: add, remove: remove, isWatched: isWatched, checkAll: checkAll }; } function observeDOM(watches, container, cb) { var observer = new MutationObserver(watch); var filter = Array.prototype.filter; var concat = Array.prototype.concat; observer.observe(container, { childList: true, subtree: true, // changes like style/width/height/display will be catched attributes: true }); function watch(mutations) { // some new DOM nodes where previously watched // we should check their positions if (mutations.some(knownNodes) === true) { setTimeout(cb, 0); } } function knownNodes(mutation) { var nodes = concat.call([], Array.prototype.slice.call(mutation.addedNodes), mutation.target ); return filter.call(nodes, watches.isWatched).length > 0; } } /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ } /******/ ]);"}],"posts":[{"title":"红宝书#1","slug":"红宝书-1","date":"2021-05-19T01:38:07.000Z","updated":"2021-05-19T02:34:01.329Z","comments":true,"path":"2021/05/19/红宝书-1/","link":"","permalink":"http://ydl8686.github.io/2021/05/19/%E7%BA%A2%E5%AE%9D%E4%B9%A6-1/","excerpt":"","text":"函数每个函数都是Function类型的实例 声明函数四种方式123456789101112131415//函数声明function sum(num1,num2)&#123; return num1+num2;&#125;//函数表达式，定义一个变量sum并将其初始化为一个函数let sum=function(num1,num2)&#123; return num1+num2;&#125;//箭头函数let sum=(num1,num2)=&gt;&#123; return num1+num2;&#125;//使用Function构造函数，接受任意多个字符串参数，最后一个被当成函数体，前面当成函数参数//会被解释2次，一次是当作js代码，一次是解释传给构造函数的参数字符串let sum=new Function(&quot;num1&quot;,&quot;num2&quot;,&quot;return num1+num2;&quot;); 箭头（胖箭头=&gt;）函数如果只有一个参数，可以不用括号let triple=x=&gt;&#123;return 3*x;&#125;;；只有没有参数或者多个参数的情况下才需要括号 箭头函数也可以不用大括号，那么箭头内只能有一行代码，并且隐式返回这行代码的值 箭头函数不能使用arguments、super、new.target，也不能用作构造函数，也没有prototype属性 函数名函数名就是指向函数的指针 123function sum(num1,num2)&#123;return num1+num2;&#125;let anotherSum=sum; //使用不带括号的函数名会访问函数指针，而不会执行函数sum=null; //anotherSum还是可以正常调用 函数对象都有一个只读的name属性，包含函数的相关信息，一般来说是字符串化的变量名，如果函数没有名称，那么就是空字符串，如果是Function构造函数创建的，那么就是anonymous；如果函数是get函数、set函数，或者使用bind()实例化，那么前面会加上一个前缀 1234567891011121314151617function foo()&#123;&#125;//使用bind实例化foo.bind(null).name //bound foo//get、set函数let dog=&#123; years:1, get age()&#123; return this.years; &#125;, //set方法必须要有一个参数 set age(newAge)&#123; this.years=newAge; &#125;&#125;let propertyDescriptor=Object.getOwnPropertyDescriptor(dog,&quot;age&quot;);propertyDescriptor.get.name //get agepropertyDescriptor.set.name //set age 理解参数JS函数的参数在内部表现为一个数组，被调用时总会接受一个数组，但是不关心数组内包含什么，内容长度也不关心。在使用function定义（非箭头）函数时，可以在内部访问arguments对象来获得参数 arguments是一个类数组对象（下标从0开始，不是Array的实例），可以使用下标访问对应元素，还有对应的length属性 函数参数只是为了方便才写出来的，并不是必须的；在JS中的命名参数不会创建让之后的调用必须匹配的函数签名，因为根本不存在验证命名参数的机制 arguments对象可以和命名参数一起使用，并且它的值始终与对应的命名参数同步（但访问的是不同的内存地址，只不过会保持同步而已）；修改arguments的值会对应修改命名参数，不过需要注意的是，arguments对象的长度是根据传入的参数个数确定的，而非定义函数时给出的命名参数的个数确定的（所以定义2个命名参数，实际上传了1个参数，定义arguments[1]之后第2个命名参数还是undefined） 严格模式下，arguments对象改变不会影响命名参数；在函数中重写arguments对象会导致语法错误","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"前端","slug":"前端","permalink":"http://ydl8686.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"算法#10","slug":"算法-10","date":"2021-05-18T01:51:01.000Z","updated":"2021-05-18T10:46:31.691Z","comments":true,"path":"2021/05/18/算法-10/","link":"","permalink":"http://ydl8686.github.io/2021/05/18/%E7%AE%97%E6%B3%95-10/","excerpt":"","text":"闲暇时刻来点easy难度的题目写着试试练练手 只出现一次的数字 这道题在面试腾讯文档的时候提到了！！！还有进阶版本的，目前也不知道要怎么解决。。希望能在之后遇到 12345678// 相同为0，不同为1var singleNumber = function(nums) &#123; let t=0; for(let i=0;i&lt;nums.length;i++)&#123; t=t^nums[i]; &#125; return t;&#125;; 外观数列 12345678910111213141516171819202122232425262728var countAndSay = function(n) &#123; if(n===1)&#123; return &#x27;1&#x27;; &#125; else&#123; let str=countAndSay(n-1); let t=0; let tempResult=[]; let tempArray=[]; tempArray.push(str.charAt(0)); for(let i=0;i&lt;str.length-1;i++)&#123; if(str.charAt(i+1)===str.charAt(i))&#123; tempArray.push(str.charAt(i+1)); &#125; else&#123; tempResult.push(tempArray); tempArray=[]; tempArray.push(str.charAt(i+1)); &#125; &#125; tempResult.push(tempArray); let resultStr=&quot;&quot;; for(let i=0;i&lt;tempResult.length;i++)&#123; resultStr=resultStr+tempResult[i].length+tempResult[i][0]; &#125; return resultStr; &#125;&#125;; 最后一个单词的长度 12345678910var lengthOfLastWord = function(s) &#123; s=s.trim(); let result=0; let i=s.length-1; while(i&gt;=0 &amp;&amp; s.charAt(i)!==&#x27; &#x27;)&#123; result++; i--; &#125; return result;&#125;;","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"http://ydl8686.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"递归","slug":"递归","permalink":"http://ydl8686.github.io/tags/%E9%80%92%E5%BD%92/"}]},{"title":"项目小结#1","slug":"项目小结-1","date":"2021-05-16T12:08:44.000Z","updated":"2021-05-16T12:09:51.945Z","comments":true,"path":"2021/05/16/项目小结-1/","link":"","permalink":"http://ydl8686.github.io/2021/05/16/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93-1/","excerpt":"","text":"mounted的钩子函数里是可以拿到data里面的数据的（生命周期相关顺序），this指向即可 使用mapGetters获取的数据在使用watch进行监听时不需要使用this 设置背景图片，发现浏览器默认会有margin: 8px的样式，可以在项目中的index.html中设置body:{margin:0}来覆盖默认样式 v-model可以直接绑定到一个对象里的某个属性 路由 hash模式里的#其实是类似于Jump的锚点，可以做到URL发生变化，但页面不跳转；为了减轻后端服务器的压力，利用AJAX可以在不重新载入页面的情况下刷新数据；使用hash模式（改变URL而不请求后端）可以实现页面的整体变化而不发起请求 hash模式：监听#后内容的变化从而动态改变页面内容，#后的地址称为hash history模式：使用History API（针对历史记录的API），先把页面的状态保存到一个对象(state)里，当页面的URL变化时找到对应的对象，从而还原页面（设计之初是为了方便浏览器前进后退的） 在router/index.js中的new VueRouter里面添加mode:history就可以把hash模式改成history模式了 JSON.parse(text)方法可以将JSON字符串转换成JSON对象；JSON.stringify(obj)可以将JSON对象转换成JSON字符串。之所以要经历这几部分，是因为localStorage只能存储字符串（实现了使用localStorage来记住登陆，除非用户清除缓存） 实现前端路由拦截 在router/index.js中将对应的路由词条设置meta 在main.js中添加钩子函数来进行路由跳转前的判断 App.vue是所有组件的父组件","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"vue","slug":"vue","permalink":"http://ydl8686.github.io/tags/vue/"},{"name":"项目","slug":"项目","permalink":"http://ydl8686.github.io/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"git使用","slug":"git使用","date":"2021-05-14T01:45:52.000Z","updated":"2021-05-14T01:49:27.904Z","comments":true,"path":"2021/05/14/git使用/","link":"","permalink":"http://ydl8686.github.io/2021/05/14/git%E4%BD%BF%E7%94%A8/","excerpt":"","text":"分支创建新分支git branch branchName 创建新分支并并切换到新分支git checkout -b branchName 查看所有分支git branch -a 本地删除分支git branch -d branchName 远程删除分支git push origin :branchName 分支名前的冒号表示删除","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"git","slug":"git","permalink":"http://ydl8686.github.io/tags/git/"}]},{"title":"电子商务复习总结","slug":"电子商务复习总结","date":"2021-04-23T09:01:26.000Z","updated":"2021-05-06T10:21:06.415Z","comments":true,"path":"2021/04/23/电子商务复习总结/","link":"","permalink":"http://ydl8686.github.io/2021/04/23/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/","excerpt":"","text":"电子商务定义EC：利用包括互联网在内的计算机网络，实现商品买卖、交换、配送、服务、信息的过程 EB：不仅仅是指商品、服务的买卖，也包括客户服务，与商业伙伴的协调、合作，利用网络开展学习活动，以及组织内部的电子信息交换 电子商务是商务的电子化，而不是电子的商务化，商务是根本和源，电子是工具和手段 电子商务的三个维度 商品数字化：产品、服务本身的数字化 商务流程数字化：订单系统数字化 配送方式数字化 满足其中一个就是部分电子商务，都满足就是完全电子商务，都不满足就是传统商务 电子商务框架 应用层 5大支持服务领域（人员、公共政策、营销与广告、支持服务、业务伙伴）人工赢之夜 5大基础设施（普通商务服务、信息传递、多媒体和网络出版、网络、界面）普信多网界 电子商务分类B2B、B2C、B2B2C、C2B、C2C、intrabusiness EC、B2E、c-commerce、EG 商业环境推动电子商务发展市场、技术和企业的经营压力（根本）成为推动电子商务的发展动力 什么是商业模式指一个完整的产品、服务和信息流体系，包括每一个参与者和其在其中起到的作用，以及每一个参与者的潜在利益和相应的收益来源和方式 商业模式包含4个方面、9个要素4个方面 客户 提供物（产品/服务） 基础设施 财务 9个要素 价值主张 渠道通路（看看内容） 客户关系 收入来源 成本结构 核心资源 关键业务 重要合作 客户细分 （商业模式对产品开发的影响） 商业模式促进新技术产业化 商业模式影响信息产业 商业模式影响产品开发 （市场三个功能） 匹配买方和卖方 促进与交易有关的信息、货物、服务和资金的交换 提供制度支持以规范市场、提升市场效率 （电子商务的消费者） 个体消费者关注媒体，不仅仅是报纸电视，对他人可能产生影响的都是媒体 组织机构采购者按照购物金额，是最大的在线购物群体，关注过程 消费者购物决策过程中的角色 发起人 影响人 决定者 购买者 用户 个体消费者网上消费行为影响因素 卖方不可控因素 消费者特征 环境特征 零售商和中间商特征 卖方可控因素 产品和服务特征，包括市场激励 电子商务系统 消费者购买决策的制定过程传统购买决策模型适用在线购买决策，传统的购买决策模型包括5个阶段（可能不完整，顺序甚至可能颠倒） 需求识别 信息收集 产品、商家评估 购买与配送 购后行为 B2B电子商务的基本概念、主要特征B2B电子商务是指企业与供应商之间，通过网络开展交易和协作活动，企业指各类组织 主要特征：企业通过网络开展自动化交易，或者通过网络进行沟通、协作，目的是对经营、管理的持续优化 B2B交易活动的四种类型，对应产生三种市场和服务四种类型 以卖方为主：一个卖家，多个买家 以买方为主：一个买家，多个卖家 多方交易：多个卖家和买家 供应链优化及协同商务 三种市场和服务 一对多、多对一网络市场 多对多网络市场 供应链优化与协同商务 B2B交易平台的三大功能 匹配功能：撮合买方和卖方（例如提供商品、分类展示商品） 为交易提供便利功能：促进交易（例如提供账单和支付信息） 制定交易规则、维护交易平台基础设施功能","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"NJUSE","slug":"NJUSE","permalink":"http://ydl8686.github.io/tags/NJUSE/"},{"name":"电子商务","slug":"电子商务","permalink":"http://ydl8686.github.io/tags/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1/"}]},{"title":"数据库事务隔离","slug":"数据库事务隔离","date":"2021-04-23T02:30:29.000Z","updated":"2021-05-06T10:23:11.906Z","comments":true,"path":"2021/04/23/数据库事务隔离/","link":"","permalink":"http://ydl8686.github.io/2021/04/23/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/","excerpt":"","text":"事务并发可能出现的问题数据 脏读一个事务读到了另一个未提交事务修改过的数据 会话B开启一个事务，把id=1的name为武汉市修改成温州市，此时另外一个会话A也开启一个事务，读取id=1的name，此时的查询结果为温州市，会话B的事务最后回滚了刚才修改的记录，这样会话A读到的数据是不存在的，这个现象就是脏读。（脏读只在读未提交隔离级别才会出现） 不可重复读一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。 会话A开启一个事务，查询id=1的结果，此时查询的结果name为武汉市。接着会话B把id=1的name修改为温州市（隐式事务，因为此时的autocommit为1，每条SQL语句执行完自动提交），此时会话A的事务再一次查询id=1的结果，读取的结果name为温州市。会话B再此修改id=1的name为杭州市，会话A的事务再次查询id=1，结果name的值为杭州市，这种现象就是不可重复读。 幻读一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。 会话A开启一个事务，查询id&gt;0的记录，此时会查到name=武汉市的记录。接着会话B插入一条name=温州市的数据（隐式事务，因为此时的autocommit为1，每条SQL语句执行完自动提交），这时会话A的事务再以刚才的查询条件（id&gt;0）再一次查询，此时会出现两条记录（name为武汉市和温州市的记录），这种现象就是幻读 事务的隔离级别MySQL的事务隔离级别一共有四个，分别是读未提交、读已提交、可重复读以及可串行化。 MySQL的隔离级别的作用就是让事务之间互相隔离，互不影响，这样可以保证事务的一致性。 隔离级别比较：可串行化&gt;可重复读&gt;读已提交&gt;读未提交 隔离级别对性能的影响比较：可串行化&gt;可重复读&gt;读已提交&gt;读未提交 由此看出，隔离级别越高，所需要消耗的MySQL性能越大（如事务并发严重性），为了平衡二者，一般建议设置的隔离级别为可重复读，MySQL默认的隔离级别也是可重复读。 读未提交 在读未提交隔离级别下，事务B可以读取到事务A修改过但未提交的数据。 可能发生脏读、不可重复读和幻读问题，一般很少使用此隔离级别。 读已提交 在读已提交隔离级别下，事务B只能在事务A修改过并且已提交后才能读取到事务B修改的数据。 读已提交隔离级别解决了脏读的问题，但可能发生不可重复读和幻读问题，一般很少使用此隔离级别。 可重复读 在可重复读隔离级别下，事务B只能在事务A修改过数据并提交后，自己也提交事务后，才能读取到事务B修改的数据。 可重复读隔离级别解决了脏读和不可重复读的问题，但可能发生幻读问题。 提问：为什么上了写锁（写操作），别的事务还可以读操作？ 因为InnoDB有MVCC机制（多版本并发控制），可以使用快照读，而不会被阻塞。 可串行化 在可串行化级别下，只有读读不会阻塞 各种问题（脏读、不可重复读、幻读）都不会发生，通过加锁实现（读锁和写锁）。 隔离级别表","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"NJUSE","slug":"NJUSE","permalink":"http://ydl8686.github.io/tags/NJUSE/"},{"name":"数据库开发","slug":"数据库开发","permalink":"http://ydl8686.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91/"}]},{"title":"服务端开发总结","slug":"服务端开发总结","date":"2021-04-23T02:23:11.000Z","updated":"2021-05-06T10:21:45.640Z","comments":true,"path":"2021/04/23/服务端开发总结/","link":"","permalink":"http://ydl8686.github.io/2021/04/23/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/","excerpt":"","text":"web开发处理请求过程来自浏览器的请求从web容器到dispatcherServlet中（不过不是所有请求都会到servlet中，静态页面就不是） 然后到handler mapping（维护了请求和controller的对应关系）中找到对应的controller 把请求传到controller中，在controller里参数转换成java对象，然后把java对象和请求扔给service 最后controller返回数据和逻辑视图名到dispatcherServlet中 dispatcherServlet再拿着model到视图解析器里进行解析视图，得到如html类型的视图 最后作为response body返回到浏览器端 还有一种是在controller中java对象被转换成json对象就直接返回（restful） 还有一种是不同的model表达方式导致有不同的视图解析器 web应用程序的分层 view视图层，主要负责前台页面的表示 model模型 controller控制层，负责具体的业务模块流程的控制 service业务层，主要负责业务模块的逻辑应用设计 domain实体 dao数据访问层，主要负责数据的持久化，与数据库进行联络的一些任务都封装在此 微服务相对于传统单体应用程序有哪些优势，单体应用有什么不足微服务优势 应用程序分解为具有明确定义了职责范围的细粒度组件 完全独立部署和测试，可复用性更强 使用轻量级通信协议，HTTP和JSON，更低的耦合性 服务实现可使用多种编程语言和技术 将大型团队划分成多个小型开发团队，每个团队只负责各自的任务 单体不足 数据库的表对所有模块可见 一个人的修改整个应用都要重新构建、测试、部署 整体复制分布式部署，不能拆分按需部署 服务开发和注册的好处 快速水平伸缩（增加或减少服务器数），而不是垂直伸缩（增加或减少硬件），不影响客户端 提高应用程序的弹性（分布式系统中对问题的容错性） Eureka、Ribbon、Feign和Zuul的相互关系Eureka 负责服务的注册与发现，向一些服务提供已经注册的服务的相关信息，比如有哪些服务、服务有哪些实例、实例的 IP 地址、端口号等等。Eureka 分为 server 端和 client 端（服务消费方和提供方都是 client 端），一般来说 server 端进行多个实例的部署 Ribbon 部署在服务的消费端，需要向 Eureka 获取已部署的服务信息，将这些信息缓存在本地，并提供负载均衡策略来访问这些服务 Zuul 是总的入口，需要向 Eureka Server 获取当前系统中部署的服务和其状态。针对于已处于 up 状态的，Zuul 会建立相应的路由，路由方式有静态路由等。由 Zuul 来代为访问目标服务，借助 Ribbon 做负载均衡 Feign 提供了客户端访问目标服务的一种简化的开发方式，只需要定义一个加上 @FeignClient 注解的接口，将其注入到代码中，然后调用该接口的方法即可。Feign 借助于 Ribbon，简化了客户端的调用方式","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"NJUSE","slug":"NJUSE","permalink":"http://ydl8686.github.io/tags/NJUSE/"},{"name":"服务端开发","slug":"服务端开发","permalink":"http://ydl8686.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"}]},{"title":"面试all","slug":"面试all","date":"2021-04-07T06:56:59.000Z","updated":"2021-05-06T10:22:46.011Z","comments":true,"path":"2021/04/07/面试all/","link":"","permalink":"http://ydl8686.github.io/2021/04/07/%E9%9D%A2%E8%AF%95all/","excerpt":"","text":"原型、原型链每个函数（并不是所有的函数都是构造函数，只有当一个函数通过new关键字调用的时候才叫做构造函数）都有一个prototype属性，叫显式原型。假设父类是师父，子类是徒弟，徒弟还能再收徒弟，那么师父想要传给后代徒弟、徒弟的徒弟的武功，都可以放到prototype属性里面，有了prototype，就不需要为每一个实例创建重复的属性方法，后代都能够使用，而那些不需要共享的才创建在构造函数中 _proto_则是访问prototype的唯一方式，叫隐式原型，是对象（包括函数）独有的；一个对象通过._proto_来访问上一级某个属性，如果没有就再._proto_到上一级，这种链式就叫做原型链，万物都是继承自Object，如果Object.prototype里面没有就返回null，Object.prototype._proto_是null；利用instance of判断一个对象是不是数组就是通过不停的._proto_来判断是否会等于Array.prototype，如果一直到null都不等于，那么就不是数组 只有prototype才有constructor，和构造函数和prototype反过来的 12p1.hasOwnProperty(&#x27;constructor&#x27;) // falseParent.prototype.hasOwnProperty(&#x27;constructor&#x27;) // true ._proto_与其说是属性，更类似于getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。 JS继承原型链继承（不可以实现多继承）1Student.prototype = new Person() // 子类型的原型为父类型的一个实例对象 子类继承父类的属性和方法是将父类的私有属性和公有方法都作为自己的公有属性和方法，子类1改变父类的引用类型因为操作的是地址，会影响到子类2 需要在子类中添加新的方法或者是重写父类的方法时候，一定要放到替换原型的语句之后，因为上面的赋值会改变Student的原型指向 与其说是继承，更相当于是委托，因为并没有拷贝一份代码给子类，而是子类中包含了父类对象 构造函数继承（可以实现多继承）通过call调用父类型构造函数，只实现了部分继承，如果父类的原型中还有属性和方法，那么子类是拿不到的 class继承（ES6）用法和Java很类似 ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.call(this)）. ES6的继承有所不同，实质上是先创建父类的==实例对象this==，然后再用==子类的构造函数==修改this。因为子类没有自己的this对象，所以必须先调用父类的super()方法，否则新建实例报错。 作用域、作用域链？？？？?当执行一段js可执行代码时，会创建对应的执行上下文，包括变量对象，作用域链和this。当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从外层执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。 闭包？？？?理论上是指能够访问自由变量（在函数中使用的，既不是函数参数，也不是函数局部变量的变量）的函数，也就是所有函数都是闭包；但实践上是指，即使创建函数的上下文被销毁，但这个函数仍然存在，这样的函数就是闭包；阮一峰教程的理解是“定义在一个函数内部的函数” 用处是可以读取函数内部的变量；让这些变量的值始终保持在内存中 this 这里的null不是对象～ bind、call、apply这三个函数都能够改变this指针的指向，不过会有一些小的差别。除了第一个参数以外，call可以接受一个参数列表，但apply只能接受一个数组作为参数；bind则是返回了一个新的函数 浅拷贝赋值形式拷贝引用对象，指向同一个地址，修改时原对象也会受到影响 实现：1.var obj1 = Object.assign({},obj);；2.for in 1234567function simpleCopy(obj1) &#123; var obj2 = Array.isArray(obj1) ? [] : &#123;&#125;; for (let i in obj1) &#123; obj2[i] = obj1[i]; &#125; return obj2;&#125; 深拷贝完全拷贝新对象，修改时原对象不再受到影响 可以通过 JSON.parse(JSON.stringify(object)) 来解决 问题：会忽略undefined、symbol、函数，遇到循环引用的对象会报错 如果遇到上面这几种，可以使用lodash来进行深拷贝 1234567891011121314151617181920212223function clone(target, map = new Map()) &#123; if (typeof target === &#x27;object&#x27;) &#123; let cloneTarget = Array.isArray(target) ? [] : &#123;&#125;; if (map.get(target)) &#123; return target; &#125; map.set(target, cloneTarget); for (const key in target) &#123; cloneTarget[key] = clone(target[key], map); &#125; return cloneTarget; &#125; else &#123; return target; &#125;&#125;;var _ = require(&#x27;lodash&#x27;);var obj1 = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3]&#125;;var obj2 = _.cloneDeep(obj1); 解决异步的方法 回调函数（回调地狱） 事件监听（事件驱动模式） 发布/订阅模式，相比于事件监听，可以通过查看消息中心了解存在多少信号、每个信号有多少订阅者 Promises 跨域如果url中协议、域名、端口中有一个不同就是跨域，同源策略限制了Cookie、LocalStorage、IndexDB无法读取，DOM和JS对象无法获得，AJAX请求不能发送 jsonp可以在&lt;script&gt;标签来指向一个需要访问的地址，并提供一个回调函数来接收数据，不过只支持get请求 123456&lt;script src=&quot;http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp&quot;&gt;&lt;/script&gt;&lt;script&gt; function jsonp(data) &#123; console.log(data) &#125;&lt;/script&gt; CORS普通跨域请求只需要服务端来设置Access-Control-Allow-Origin；若要带cookie请求，前端需要设置xhr.withCredentials=true；使用vue axios需要设置axios.defaults.withCredentials=true document.domain只适用于二级域名相同的情况下，例如a.test.com和b.test.com，设置document.domain=’test.com’来解决跨域问题 WebSocketnginx代理HTTP缓存http缓存都是从第二次请求开始的。第一次请求资源时，服务器返回资源，并在respone header头中回传资源的缓存参数；第二次请求时，浏览器判断这些请求参数，命中强缓存就直接使用缓存数据，否则就把请求参数加到request header头中传给服务器，看是否命中协商缓存，命中则返回304，否则服务器会返回新的资源。强制缓存（不能及时更新）和协商缓存（与后端交互性能不好）区别在于是否需要重新向服务器发起请求。 强制缓存：Cache-Control的max-age没有过期或者Expires的缓存时间没有过期 如果强制缓存过期或者被设置为no-cache，那么就采用协商缓存，服务端返回ETag/Last-Modified（不能判断1秒内的变化），请求头发送If-Not-Match/If-Modified-Since Cache-Control public &amp; private包含public指令的响应资源表示允许被任何==中间者（可能是代理服务器、类似于 cdn 网络）==缓存。这个指令通常不需要在响应头中用到，因为其他指令已经表明了响应资源是否可以被缓存（例如：max-age）。 private 指令表示响应资源仅仅只能被获取它的浏览器端缓存。它不允许任何中间者（intermediate）缓存响应的资源。 XSS攻击跨站脚本攻击是指通过巧妙的方法来注入恶意代码到网页，然后用户打开网页或者点击按钮就会加载并执行攻击者恶意制造的网页程序，攻击成功后可以得到一些私密网页内容、会话和cookie等内容，所以需要通过设置http-only来禁止通过js访问cookie CSRF攻击跨站请求伪造是指黑客诱导受攻击者进入第三方网站，然后向被攻击网站发送请求，利用受攻击者在被攻击网站已经获取的凭证如cookie来绕过后台用户验证，从而实现冒充用户来对被攻击网站执行某项操作的目的，可以设置cookies属性same-site为strict来规定不能在跨域请求中携带cookie，减少攻击 https加密 HTTPHTTP/1相对于HTTP 0.9最传统的request-response只支持GET方法，HTTP 1.0在请求中加入了HTTP版本号，请求和响应都有header，增加了HTTP Status Code状态码，还有Content-Type 但是每请求一个资源都要新建一个TCP连接，而且是串行请求 HTTP/1.1可以设置keepalive来重用TCP连接，减少握手的巨大开销；支持pipeline网络传输，只要第一个请求发送出去，不必等其回来就可以发送第二个请求，提高并行化；在Response时不说明Content-Length，客户端就不能断开连接，得等到收到服务端的EOF标识才行，这就叫server push；增加了cache control机制；增加了host，可以知道具体请求的是哪个域名 请求依旧是串行的；传输的数据是文本 HTTP/2前身是Google的SPDY；可以在一个TCP连接中并发发送多个HTTP请求；多个请求头相同时会压缩头部；服务端push，即使没有请求依赖，也会返回依赖到浏览器本地缓存中 HTTP/3QUIC，把底层的TCP协议换成了UDP tcp三次握手和四次挥手的原因主要是为了解决两军问题，第三次握手是为了防止客户端可能因为网络不稳定发送的无效请求到服务端导致服务端建立多个连接、资源浪费；第四次挥手是为了确保服务端传给客户端的数据发送完毕 客户端断开连接还需要等待2MSL：确保最后一个报文能够到达（如果B没收到会重新发送连接释放请求报文）；让本连接所产生的所有报文从网络中消失，使得下一个新的连接不会出现旧的连接请求报文 排序原理进程和线程的区别进程是资源分配的最小单位，线程是CPU调度的最小单位；进程有独立的地址空间，但线程之间没有单独的地址空间；一个程序至少有一个进程，一个进程至少有一个线程；线程的粒度比进程更小；线程不能够独立执行 Vue数据双向绑定（视图和数据的双向绑定）的原理数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的 双向绑定：从view更新data可以通过事件监听，data更新view则可以通过Object.defineProperty( )对属性设置一个set函数，当数据改变了就会来触发这个函数，所以只要将一些需要更新的方法放到这里面就可以实现data更新view了。 发布-订阅者模式中数据变化为“发布者”，负责劫持并监听所有属性，依赖对象为“订阅者”；Dep消息订阅器主要负责收集所有的订阅者，数据变化后执行对应订阅者的更新函数；Compile编译解析器则可以绑定watcher里的更新函数，并且初始化View 不过Object.defineProperty还是有一些缺陷的，例如只能对属性进行数据劫持，所以需要深度遍历整个对象；对于数组不能监听到数据的变化；所以Vue3使用Proxy来替代了，优点在于可以直接监听对象而不是属性，可以直接监听数组的变化 display none（占据的空间消失）visibility/overflow：hidden（占据空间不消失，无法响应事件） opacity：0（不消失，可以响应事件） z-index：-10000（层叠格式化上下文） block inline inline-block（像行内元素一样显示，但其内容像块类型元素一样显示。） table 居中布局水平居中 行内元素：text-align：center 块级元素：margin：0 auto flex：justify-content：center 垂直居中 line-height：height display：table flex：align-items：center 水平垂直居中 flex：justify-content+align-items absolute+transform 盒模型分为两种，标准盒模型content-box和IE盒模型border-box，都包括margin、border、padding、content，区别在于标准盒模型中width、height指的是content的宽和高，增加margin、border、padding不会影响width、height，会影响整个盒子的尺寸；而IE盒模型的width、height则是content+border+padding （顺时针赋值） CSS选择器简单选择器（元素选择器、类选择器、ID选择器、通用*选择器、组合选择器（如’ ‘,’&gt;’,’+’,’~’）） 属性选择器（如[attr]、[attr=val]） 伪类和伪元素选择器（元素在特定状态下更改的样式） 选择器优先级!important&gt;行内样式&gt;#id&gt;.class&gt;tag&gt;*&gt;继承&gt;默认 !important &gt;（a是否内联，b ID选择器出现次数，c 类选择器/属性选择器/伪类次数，d 标签选择器/伪元素选择器） BFC块级格式化上下文，一块独立的渲染区域，内部元素与外部元素相互隔离，定位不会相互影响 触发条件： html根元素 position：absolute/fixed display：inline-block/table/flex float overflow！=visible 规则：1.不同BFC的两个Box垂直排列，且margin不会重叠；2.计算BFC高度时，浮动子元素也参与计算，可以解决高度塌陷问题（子元素float脱离了正常文档流之后，父元素就没有内容了）；3.阻止BFC被浮动元素覆盖（去掉文字浮动效果） position默认是static；relative是相对于原来位置的position，利用top/bottom/left/right来相对反过来推；absolute不再存在于正常文档布局流中，元素是相对于html元素或最近的定位祖先的top/bottom/left/right；fixed是相对于浏览器窗口；stiky就像便签一样，在阈值内和正常的一样，超过某个阈值可能就像粘贴在窗口边栏","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"面试","slug":"面试","permalink":"http://ydl8686.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"前端","slug":"前端","permalink":"http://ydl8686.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"项目问答","slug":"项目问答","date":"2021-04-07T06:56:59.000Z","updated":"2021-05-06T10:25:03.011Z","comments":true,"path":"2021/04/07/项目问答/","link":"","permalink":"http://ydl8686.github.io/2021/04/07/%E9%A1%B9%E7%9B%AE%E9%97%AE%E7%AD%94/","excerpt":"","text":"秒杀系统CDN用户发起请求，域名解析会交给CDN专用的DNS解析器，然后返回全局、区域负载均衡设备ip，根据位置、服务情况等返回合适的CDN缓存服务器，增加静态资源访问速度，提高用户访问体验 验证码防止使用机器进行大规模的恶意请求，chrome判断流量是否异常 秒杀链接加盐url动态化来解决链接暴露的问题 解决用户重复点击方法一：在vue data里面添加一个标志位，然后点击调用对应的方法的时候，先判断这个标志位，每次点击过后等所有操作结束后才释放变量 防抖的原理就是：你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行，真是任性呐! 方法二：防抖，用来限制重复事件频繁发生，经常用在scroll和resize事件上（不过如果对应事件包含异步操作，好像会出问题，没办法限制弱网下重复点击的情况，例如防抖时间为1s，但是请求需要2s，时间差导致用户可以重复调用函数） 1234567891011121314151617181920212223//如果没有immediate的话，那么秒杀时点的越快反而请求越发不出去function debounce(func, wait, immediate) &#123; var timeout; return function () &#123; //不这样，那么this指向的是window，而不是绑定的元素 var context = this; var args = arguments; if (timeout) clearTimeout(timeout); if (immediate) &#123; // 如果已经执行过，不再执行 var callNow = !timeout; timeout = setTimeout(function()&#123; timeout = null; &#125;, wait) if (callNow) func.apply(context, args) &#125; else &#123; timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; &#125;&#125; 限流卖1000，访问10万，在前端放1万流量到后端 风控之所以不是在前端刚好放1000流量给后端，是为了在这1万流量中还要继续筛选一些薅羊毛的用户（判断是不是真实用户还是类似于微博僵尸粉） 深拷贝123456789101112131415function clone(target, map = new Map()) &#123; if (typeof target === &#x27;object&#x27;) &#123; let cloneTarget = Array.isArray(target) ? [] : &#123;&#125;; if (map.get(target)) &#123; return target; &#125; map.set(target, cloneTarget); for (const key in target) &#123; cloneTarget[key] = clone(target[key], map); &#125; return cloneTarget; &#125; else &#123; return target; &#125;&#125;; 加盐哈希明文存储，hash存储（虽然有sha1、sha2、sha3，但由于彩虹表的存在，事先构建一个明文到密文的对应关系，再加上GPU和特定的硬件可以每秒进行十亿次哈希计算，所以还是不安全），加盐哈希（哈希之前将另一个字段盐加到密码前），Argon2除了实现加盐哈希以外，还实现了慢哈希，也就是迭代进行很多次hash运行，官方建议迭代十万次 相对于普通的hash，加盐hash能够抵御彩虹表，因为彩虹表在生成的过程中，针对的是特定的函数H，H如果发生了改变，则已有的彩虹表数据就完全无法使用。如果每个用户都用一个不同的盐值，那么每个用户的H函数都不同，则必须要为每个用户都生成一个不同的彩虹表。大大提高了破解难度。 明水印生成和图片大小一样的shadow遮罩层来覆盖在图片上，但是可以直接通过开发者模式来删除对应的dom元素，利用mutation observer来进行节点监听，不过还是有解决方案。。在删除dom前禁用浏览器的Javascript 123456789101112131415161718// 观察器的配置（需要观察什么变动）const config = &#123; attributes: true, childList: true, subtree: true &#125;;// 当观察到变动时执行的回调函数const callback = function (mutationsList, observer) &#123; for (let mutation of mutationsList) &#123; mutation.removedNodes.forEach(function (item) &#123; if (item === watermakr) &#123; document.getElementById(&#x27;app&#x27;).appendChild(watermakr); &#125; &#125;); &#125;&#125;;// 监听元素const targetNode = document.getElementById(&#x27;app&#x27;);// 创建一个观察器实例并传入回调函数const observer = new MutationObserver(callback);// 以上述配置开始观察目标节点observer.observe(targetNode, config); 懒加载利用getBoundingClientRect来判断当前图片元素是否在视窗内来决定是否加载，原理和分页、虚拟列表相似都是按需加载，相对于视图窗口的左上角 lazyImage.getBoundingClientRect().top &lt;= window.innerHeight &amp;&amp; lazyImage.getBoundingClientRect().bottom &gt;= 0 响应式布局123456789101112131415mounted() &#123; if(window.innerWidth &lt; 992)&#123; this.showModal = true; &#125; else &#123; this.showModal = false; &#125; window.addEventListener(&#x27;resize&#x27;, ()=&gt;&#123; //这里也可以使用防抖来防止不断的回流 if(window.innerWidth &lt; 992)&#123; this.showModal = true; &#125; else &#123; this.showModal = false; &#125; &#125;); &#125; px、em、rempx像素是相对于显示器屏幕分辨率而言的，但是四大内核Trident、Blink、Gecko、Webkit对px的渲染策略不一样，像国内使用比较多的百度就是Trident（360:Trident+Blink），无法调整px作为单位的字体大小 em会继承父级元素的字体大小，如果没有设置，那么就是相对于浏览器的默认字体大小 rem是css3新增的单位root em，是相对于HTML根元素的大小，可以做到只修改根元素就成比例地调整所有字体大小，避免了字体大小逐层复合的连锁反应 使用token来记住用户登录使用JSON.stringfy来将JSON转换成JSON字符串再存到localStorage里，再通过JSON.parseIn来将JSON字符串转换成JSON对象 广度遍历123456789101112131415function breadthFirstSearch(node) &#123; var nodes = []; if (node != null) &#123; var queue = []; queue.unshift(node); while (queue.length != 0) &#123; var item = queue.shift(); nodes.push(item); var children = item.children; for (var i = 0; i &lt; children.length; i++) queue.push(children[i]); &#125; &#125; return nodes; &#125;","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"面试","slug":"面试","permalink":"http://ydl8686.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"前端","slug":"前端","permalink":"http://ydl8686.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"算法#9","slug":"算法-9","date":"2021-04-05T11:40:36.000Z","updated":"2021-05-06T10:24:53.440Z","comments":true,"path":"2021/04/05/算法-9/","link":"","permalink":"http://ydl8686.github.io/2021/04/05/%E7%AE%97%E6%B3%95-9/","excerpt":"","text":"返回数组中第k大元素 12345678var findKthLargest = function(nums, k) &#123; // 注意这里的写法，对原数组进行升序排列 // b-a就是降序排列 nums.sort((a,b)=&gt;&#123; return a-b; &#125;) return nums[nums.length-k];&#125;; 合并两个有序数组 123456789101112131415161718192021222324252627282930// 核心思想就是从后面开始填var merge = function (nums1, m, nums2, n) &#123; if (n === 0) &#123; return; &#125; let i = m - 1; let j = n - 1; let k = m + n - 1; while (k &gt;= 0) &#123; if (i &lt; 0) &#123; nums1[k] = nums2[j]; j--; k--; continue; &#125; else if (j &lt; 0) &#123; nums1[k] = nums1[i]; i--; k--; continue; &#125; else &#123; nums1[k] = nums1[i] &gt;= nums2[j] ? nums1[i] : nums2[j]; k--; if (nums1[i] &gt;= nums2[j]) &#123; i--; &#125; else &#123; j--; &#125; &#125; &#125;&#125;; 具有给定数值的最小字符串 123456789101112131415161718192021222324//先让所有都是&#x27;a&#x27;，然后为了字典序最小，把&#x27;z&#x27;放到最后面，中间插一个既非&#x27;a&#x27;也非&#x27;z&#x27;的字符var getSmallestString = function(n, k) &#123; let zl=Math.floor((k-n)/25); //z的个数 let r=(k-n)%25; //不是a、z的那个字符，但其实还是可能是z //防止出现全是z的情况 if(n-zl-1&lt;0)&#123; let result=&quot;&quot;; for(let i=0;i&lt;n;i++)&#123; result+=&#x27;z&#x27;; &#125; return result; &#125; else&#123; let result=&quot;&quot;; for(let i=0;i&lt;n-zl-1;i++)&#123; result+=&#x27;a&#x27;; &#125; result+=String.fromCharCode(97+r); for(let i=n-zl;i&lt;n;i++)&#123; result+=&#x27;z&#x27;; &#125; return result; &#125;&#125;;","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"http://ydl8686.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"贪心","slug":"贪心","permalink":"http://ydl8686.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"数字数组排序","slug":"数字数组排序","permalink":"http://ydl8686.github.io/tags/%E6%95%B0%E5%AD%97%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/"}]},{"title":"算法#8","slug":"算法-8","date":"2021-03-30T00:08:10.000Z","updated":"2021-05-06T10:24:45.646Z","comments":true,"path":"2021/03/30/算法-8/","link":"","permalink":"http://ydl8686.github.io/2021/03/30/%E7%AE%97%E6%B3%95-8/","excerpt":"","text":"斐波那契数列 12345678910//根据题目的意思用递归来实现var fib = function(n) &#123; if(n===0)&#123; return 0; &#125; if(n===1)&#123; return 1; &#125; return fib(n-1)+fib(n-2);&#125;; 合并两个排序链表 123456789101112131415161718192021222324252627282930313233//新增一个伪头节点来做//还有，变量都是用var来声明的，不像java是NodeListvar mergeTwoLists = function(l1, l2) &#123; var realHead=new ListNode(-999); if(l1===null &amp;&amp; l2===null)&#123; return null; &#125; if(l1===null)&#123; return l2; &#125; if(l2===null)&#123; return l1; &#125; var p=realHead; while(l1!==null &amp;&amp; l2!==null)&#123; if(l1.val&lt;=l2.val)&#123; p.next=l1; l1=l1.next; &#125; else&#123; p.next=l2; l2=l2.next; &#125; p=p.next; &#125; if(l1===null &amp;&amp; l2!==null)&#123; p.next=l2; &#125; else if(l2===null &amp;&amp; l1!==null)&#123; p.next=l1; &#125; return realHead.next;&#125;; 有效的括号字符串给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则： 任何左括号 ( 必须有相应的右括号 )。 任何右括号 ) 必须有相应的左括号 ( 。 左括号 ( 必须在对应的右括号之前 )。 * 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。 一个空字符串也被视为有效字符串。 123456789101112131415161718192021222324252627282930313233343536var checkValidString = function (s) &#123; var left=[]; var star=[]; //先在这个循环里面把所有的右括号处理掉 for(let i=0;i&lt;s.length;i++)&#123; if(s[i]===&#x27;(&#x27;)&#123; left.push(i); &#125; else if(s[i]===&#x27;*&#x27;)&#123; star.push(i); &#125; else&#123; if(left.length!==0)&#123; left.pop(); &#125; else if(star.length!==0)&#123; star.pop(); &#125; else&#123; return false; &#125; &#125; &#125; //再把星号处理一下 while(star.length!==0 &amp;&amp; left.length!==0)&#123; if(star.pop()&lt;left.pop())&#123; return false; &#125; &#125; //如果还有剩的左括号就false if(left.length!==0)&#123; return false; &#125; //没有就true return true;&#125;;","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"http://ydl8686.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"js算法常用API","slug":"js算法常用API","date":"2021-03-24T06:05:09.000Z","updated":"2021-04-22T16:37:33.886Z","comments":true,"path":"2021/03/24/js算法常用API/","link":"","permalink":"http://ydl8686.github.io/2021/03/24/js%E7%AE%97%E6%B3%95%E5%B8%B8%E7%94%A8API/","excerpt":"总结了一些比较常用的数据结构以及对应的API","text":"总结了一些比较常用的数据结构以及对应的API 数组js数组里面的元素类型可以都不一样 123456789101112131415161718192021222324var a=new Array()var a=[1,2,3]a.length //NumberArray.isArray(a) //truea.toString() //返回数组的字符串形式&quot;1,2,3&quot;a.push(value,vlaue....) //在数组的末端添加一个或多个元素，并返回添加后的数组长度。pop() //用于删除数组的最后一个元素，并返回该元素shift() //用于删除数组的第一个元素，并返回该元素unshift(value) //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。join() //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。concat() //将参数数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。reverse() //用于颠倒数组中元素的顺序，改变了原数组slice(start_index, upto_index); //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。splice(index, count_to_remove, addElement1, addElement2, ...); //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。sort() //对原数组成员进行排序，默认是按照字典顺序排序。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。map() //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。forEach() //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。filter() //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。some() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。every() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。reduce() //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员）reduceRight() //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员）indexOf(s) //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置lastIndexOf(s) //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。 map123456789//传入函数的形式不同a.map((x)=&gt;&#123; return -x;&#125;) //把a数组里的所有元素取反，返回新数组a.map(function(x)&#123; return Math.abs(x)&#125;) //取绝对值 forEach123a.forEach((x,y,z)=&gt;&#123; console.log(x,y,z)&#125;) filter12345678arr.filter(x=&gt;&#123; if(x===&#x27;2&#x27;)&#123; return true &#125; else&#123; return false &#125;&#125;) //把符合条件的元素返回组成一个新数组 some every1234567891011121314151617arr.some(x=&gt;&#123; if(x===&#x27;2&#x27;)&#123; return true &#125; else&#123; return false &#125;&#125;) //arr[1,2,&#x27;1&#x27;,&#x27;2&#x27;] truearr.every(x=&gt;&#123; if(x===&#x27;2&#x27;)&#123; return true &#125; else&#123; return false &#125;&#125;) //false reduce12345678910//z是索引，w是原数组t.reduce((x,y,z,w)=&gt;&#123; console.log(z) // 1 2 return x*y;&#125;) //arr[1,2,3] 6t.reduce((x,y,z,w)=&gt;&#123; console.log(z) // 0 1 2 return x*y;&#125;,0) 0 String12345678910111213141516171819var s=new String()var s=&quot;12345&quot;var str=String.fromCharCode(97); //str=&#x27;a&#x27;s.lengths.chatAt(index) //返回指定位置的字符s.concat(s2) //返回新的连接后的字符串s.slice(start,end) //用于从原字符串取出子字符串并返回新字符串，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。s.substring(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。s.substr(start,length) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。s.indexOf(s) //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 s.lastIndexOf() //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。s.trim() //用于去除字符串两端的空格，返回一个新字符串s.toLowerCase() //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。s.toUpperCase() //全部转为大写s.localeCompare(s2) //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。s.match(regexp) //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。s.search() //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。s.replace(oldValue,newValue) //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。s.split() //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。 Map123456789var m = new Map(); // 空Mapm.set(&#x27;Adam&#x27;, 67); // 添加新的key-valuem.has(&#x27;Adam&#x27;); // 是否存在key &#x27;Adam&#x27;: truem.get(&#x27;Adam&#x27;); // 67m.delete(&#x27;Adam&#x27;); // 删除key &#x27;Adam&#x27;//遍历mapfor([key,value] of map)&#123; console.log(key,value)&#125; Set123456var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3, 3]); // &#123;1, 2, 3&#125;s.add(4);s; // Set &#123;1, 2, 3, 4&#125;s.delete(3);s; // Set &#123;1, 2, 4&#125;","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"js","slug":"js","permalink":"http://ydl8686.github.io/tags/js/"},{"name":"API","slug":"API","permalink":"http://ydl8686.github.io/tags/API/"}]},{"title":"快捷键","slug":"快捷键","date":"2021-03-24T02:57:01.000Z","updated":"2021-04-22T16:41:39.676Z","comments":true,"path":"2021/03/24/快捷键/","link":"","permalink":"http://ydl8686.github.io/2021/03/24/%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"mac下的chrome12341.command+n：打开新窗口2.command+t：打开新标签页3.command+option+左/右：切换前/后标签页4.command+w：关闭当前标签页 mac下的网易云12341.ctrl+command+左右：切换上下一首歌2.ctrl+command+r：顶栏是否显示歌词3.ctrl+command+t：暂停/播放上面的这些快捷键需要自定义，默认的会和chrome的冲突 mac下的vscode1234567891.ctrl+反引号：显示终端2.command+ctrl+f：全屏/退出全屏3.option+点击：插入多个光标4.command+i：选中当前行5.command+shift+k：删除当前行6.option+上/下：移动上下行7.command+enter：下一行插入8.command+shift+enter：上一行插入9.shift+option（ALT）+f：格式化代码 mac121.ctrl+左/右：切换左右桌面2.ctrl+command+q：锁屏","categories":[],"tags":[{"name":"实用技巧","slug":"实用技巧","permalink":"http://ydl8686.github.io/tags/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}]},{"title":"面试字节","slug":"面试字节","date":"2021-03-23T03:51:10.000Z","updated":"2021-05-06T10:22:35.379Z","comments":true,"path":"2021/03/23/面试字节/","link":"","permalink":"http://ydl8686.github.io/2021/03/23/%E9%9D%A2%E8%AF%95%E5%AD%97%E8%8A%82/","excerpt":"","text":"CSS层叠上下文触发条件：1.html；2.position；3.flex/transform/opacity/filter/will-change 去除浮动，防止父级高度塌陷 增加尾元素:after/&lt;br&gt;:clear:both 创建父级BFC 父级设置高度 link与@import区别 link功能较多，可以加载RSS等，而@import只能加载css 解析link时页面会同步加载所引入的css，而@import所引用的css等到页面加载完成才会被加载 @import在IE5以上才能使用 link可以用js动态引入，而@import不行 CSS预处理器（Sass/Less/postcss）将类css语言通过webpack编译成浏览器可读的真正CSS，从而赋予CSS如嵌套、变量、循环/条件、自动前缀等功能 JS执行上下文可以理解为一个对象，包含：变量对象（所有变量和函数声明），作用域链，this指向三部分，分为全局/函数/eval 执行过程： 创建全局上下文 全局上下文自上而下执行，遇到函数就把函数执行上下文push到执行栈顶层 函数执行上下文成为active EC开始执行，全局上下文被挂起 函数执行完后，函数上下文被pop出栈，控制权交还给全局上下文继续执行 作用域特性：1.声明提升；2.非匿名立即执行函数，函数变量为只读，不可修改 作用域链是一组对象列表，包括父级和自身的变量对象，由[[scope]]（指向父级变量对象和作用域链）和AO（自身活动对象）组成 闭包属于静态作用域，可以理解为，父函数销毁后，返回的子函数的[[scope]]仍然保留着父级变量对象和作用域链，所以可以继续访问父级的变量对象，这样的函数就是闭包 问题：不同子函数的[[scope]]都是指向父级，那么父级变量对象修改时，所有子函数都会受到影响 解决：1.使用块级作用域，让父级变量变成自己上下文的属性，避免共享；2.变量可以通过函数参数的形式传入，从而避免使用默认的[[scope]]向上查找 script引入方式 html静态引入 js动态插入 &lt;script defer&gt;：延迟加载，元素解析完成后执行 &lt;script async&gt;：异步加载，但会阻塞元素的渲染 new运算符的执行过程1.新生成一个对象；2.链接原型obj._proto_=Object.prototype；3.绑定thisapply；4.返回新对象 instanceofinstance._proto_._proto===Array.prototype（arr.constructor.prototype） 代码复用1.函数封装；2.继承；3.extend；4.mixin；5.aplly/call 继承类型转换-、*、/、%都转成数字 +：1.数字+字符串=字符串；2.数字+对象=字符串，先调用对象.valueOf再.toString()；3.数字+boolean/null=数字；4.数字+undefined=NaN；5.NaN！==NaN 类型判断1.对于null使用String(null)；2.对于基本类型：typeof；3.其余类型：Object.prototype.toString.call(boj) 模块化通常在浏览器中使用ES6，在Node中使用CommonJS的模块化支持 es6:import/export；commonjs：require/exports/module.exports 区别： 1.require是值拷贝，导出值变化不会影响导入值；import指向内存地址，会变化；2.require是同步导入，import是异步导入；3.require能动态导入，import不支持；4.exports只会导出一次，之后就是利用缓存值；而export则不是 防抖、节流防抖：多次高频操作优化为只在最后一次执行（用户输入后做校验）；节流：每隔一段时间后执行一次（resize、搜索推荐） ES6/ES7声明let/const：块级作用域、不存在变量提升、暂时性死区、不允许重复声明；const：无法修改 解构赋值class/extend：类声明与继承Set/Map异步解决方案1.Promise；2.generator await/async语法糖，基于promise实现 babel编译原理1.babylon将ES6/7代码解析成AST；2.babel-traverse对AST进行遍历转译得到新AST；3.新AST通过babel-generator转换成ES5 函数柯里化在一个函数中首先填充几个参数，然后再返回一个新函数的技术，可以用于在不侵入函数的前提下，为函数预置通用参数，供多次重复调用 12345678910const add = function add(x) &#123; return function (y) &#123; return x + y &#125;&#125;const add1 = add(1)add1(2) === 3add1(20) === 21 数组乱序12345var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];//没有参数！！！arr.sort(function () &#123; return Math.random() - 0.5;&#125;); 浏览器跨标签页通讯运用一些可以共享的中间介质，例如1.==设置同域下共享的localStorage与监听window.onStorage==（重复写入相同的值无法触发，会受到隐身模式等限制）；2.==设置共享cookie与setInterval不断轮询脏检查==；3.借助服务端或中间层实现；4.父页面windows.open()和子页面postMessage 浏览器下事件循环微任务：promise/ajax；宏任务：setTimeout/script/IO/UI Rendeing 输入URL到展示的过程 DNS解析，先到浏览器缓存中找，再到操作系统缓存中找，再到本机hosts文件中找，都没有去问ISP的DNS解析，递归或迭代查询都可，然后返回ip给客户端 TCP三次握手建立连接，如果是HTTPS的话，还多了一层TLS，服务端收到客户端https连接请求之后，会向客户端发送网站支持的证书信息包含公钥和CA；客户端把用服务端的公钥加密后的对称密钥发送给服务端，然后就可以通过对称密钥加密的密文通信 服务端返回请求的文件 浏览器渲染 重绘与回流重绘：元素样式改变不影响布局，只需要UI层面的重新像素绘制；回流：元素尺寸、结构改变时，浏览器重新计算页面布局、渲染页面的操作称为回流（例如：浏览器窗口大小改变、元素字体大小改变、添加删除可见dom、激活CSS伪类） 回流一定重绘，重绘不一定回流；避免使用table布局，尽量使用class进行样式修改，减少dom增删次数，先设置display:none再修改 浏览器存储cookie、localStorage、sessionStorage、indexDB Web Worker现代浏览器为JS创造的多线程环境，可以新建并将部分任务分配到worder线程并行运行，两个线程独立运行，互不干扰。可通过postMessage、onMessage来进行线程间通信 限制：同源限制、无法使用document/window/alert/confirm、无法加载本地资源 V8垃圾回收机制垃圾回收是指将内存中不再使用的数据进行清理释放内存空间，V8将内存分为新生代空间和老生代空间 新生代空间用于存活较短的对象，分成from和to空间，Scanvenge算法是指，当from空间被占满时，存活的对象从from space转移到to space，然后清空from space，from 和to互换 老生代空间用于存活时间较长的对象，当to space体积超过25%，经历过一次以上Scavenge的对象就会从新生代空间转到老生代空间，然后标记清除算法是指标记存活的对象，未被标记的会被释放；压缩算法是指将内存清楚后的碎片对象往内存的一端移动来解决内存的碎片化问题 内存泄漏1.全局变量没有被回收；2.闭包会导致父级中的变量无法释放；3.事件监听没有被正确销毁 网络TCP流量控制：滑动窗口；拥塞处理：慢开始，拥塞避免，快重传，快恢复","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"面试","slug":"面试","permalink":"http://ydl8686.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"前端","slug":"前端","permalink":"http://ydl8686.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"面试","slug":"面试","date":"2021-03-22T06:08:11.000Z","updated":"2021-05-06T10:22:20.789Z","comments":true,"path":"2021/03/22/面试/","link":"","permalink":"http://ydl8686.github.io/2021/03/22/%E9%9D%A2%E8%AF%95/","excerpt":"","text":"GET和POST链接 null和undefined区别undefined==null为true，在判断语句里都会被认为是false 最开始只设置了null表示“无”，但是null的类型为object，js的开发者觉得表示“无”的值最好不是对象，而且如果null自动转化为0很不容易发现错误，所以又引入了undefined 最初设计null表示“无”的对象，转为数值为0；undefined表示“无”的基本数据，转为数值时为NaN 现在null表示“没有对象”，此处不应该有值，例如对象原型链的终点Object.prototype._proto_就是null；而undefined表示“缺少值”，此处应该有值，但是还没有定义，例如被声明但还没有赋值，没有返回值时函数默认返回undefined 0.1+0.2!=0.3给数字添加千分位符123字符串分析，每隔3位加&#x27;,&#x27;数字分析，%1000然后加&#x27;,&#x27;(12345678).toLocaleString(&quot;en-US&quot;) =&gt; &quot;12,345,678&quot; 面向对象和面向过程区别caculate(position1,position2)和position1.caculate(position2) PromisePromise对象用于异步操作，它表示一个尚未完成且预计在未来完成的异步操作。 HTML、XML、XHTML、JSON从输入URL到页面展示发生了什么浏览器如何通过域名来查询URL对应的IP先是到浏览器缓存（浏览器会按照一定的频率来缓存DNS记录）中找 然后到操作系统缓存中找 或者到路由缓存中 都没有就去ISP的DNS服务器中查，最后到根服务器中找 DNS解析DNS解析分成两种，一种是递归查询（甩手掌柜），一种是迭代查询（自己去问） 首屏和白屏时间Diff算法Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。 Vue3.x则借鉴了 ivi算法和 inferno算法。 前端模块化CommonJS和ES6其实还有AMD、CMD、UMD。。。 模块化 模块化优点解决了命名冲突、文件依赖、代码复用的痛点","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"面试","slug":"面试","permalink":"http://ydl8686.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"前端","slug":"前端","permalink":"http://ydl8686.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"前端面试准备#Vue","slug":"前端面试准备-Vue","date":"2021-03-19T11:05:56.000Z","updated":"2021-05-06T10:23:03.651Z","comments":true,"path":"2021/03/19/前端面试准备-Vue/","link":"","permalink":"http://ydl8686.github.io/2021/03/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-Vue/","excerpt":"","text":"Vue生命周期beforeCreate、created（这个时候能够拿到props data）、beforeMount（开始创建VDOM并替换成真实DOM，递归挂载子组件，子组件结束后才执行根组件的挂载函数）、mounted、（当data中的数据发生改变时，就会触发对应组件的重新渲染，调用下面这两个）beforeUpdate、updated、beforeDestroy（先递归销毁子组件，最后销毁父组件）、destroyed v-model原理其实是语法糖，v-model在模版编译的时候转换代码，本质是：value和v-on computed和watchcomputed是计算属性，会根据所依赖的数据动态显示新的计算结果，结果在getter执行后会被缓存，只有依赖的数据发生改变时才会重新调用getter计算最新的结果 watch是一个对data的数据监听回调，当监听的数据变化时会执行回调，传入newVal和oldVal两个参数；比较适合用于数据变化时执行异步或开销较大的操作 如果watch一个变量并且在其他地方使用了watch的返回值，在第一次初始化页面时是不会执行返回的；在watch里的handler方法和immediate属性就是为了解决这种情况 如果监听的是一个对象，但是变化的只是对象中的某个值，那么handler函数是不会执行的，因为受Js限制，Vue无法检测到对象属性的添加删除修改，只能监听到对象的变化例如赋值；为了解决这种情况，可以设置deep为true开启深度监听（遍历对象所有的属性），也可以直接监听对象的某个属性 组件信息传递父传子：props 子传父：$emit 兄弟间：$refs vue router中的history mode和hash modehistory mode利用了BOM里的window.history的pushState和replaceState方法，通过这两个方法更改url访问同域下不同的url，会触发popstate事件，通过监听popstate事件来实现前端路由； ‘#’后面的是hash值，改变hash值不会向服务器发出请求，所以也不会刷新页面；每次hash值发生变化时会触发hashchange事件，通过监听hashchange事件来实现前端路由 history mode利用BOM里的history，hash mode利用BOM里的location；history修改的url可以是同域的url，hash则只能是同文档的url；history需要后端支持，hash模式下，如果把url传给后端，只处理#前的url，可能会产生参数内容丢失的问题 BOM对象document、window、navigator、screen、location、history Virtual DOM最好不要直接操作DOM，因为DOM对象很大，而且DOM操作会引发restyle/reflow/repaint耗费性能，所以可以考虑通过JS来模拟和渲染DOM，而且VDOM好像能够跨平台 算法主要是以下三步：通过JS来模拟创建DOM对象；判断两个对象的差异（如果是完整对比的话，复杂度是ON3，react优化之后是ON，关键在于值对比同层的节点，而不是跨层对比，因为实际业务中很少会去跨层移动DOM元素）；渲染差异 首先树的递归比对两个节点，如果key或tagname不同，那么替换旧节点，同时不需要再继续遍历当前节点的子节点；如果相同则遍历；如果没有新节点则什么都不做 然后判断属性是否更改，先遍历旧的属性列表，看每个属性是否都在新属性列表中；遍历新属性列表看看相比旧列表有没有多的属性，然后判断新旧属性列表值是否变化 然后判断列表差异，遍历旧的节点列表，查看每个节点是否存在于新的节点列表中；遍历新节点列表判断是否有新节点和节点是否有移动（只对有key的节点做处理） 然后遍历子元素打标识，给节点打上标记 最后渲染差异，深度遍历将需要做变更的节点取出来局部更新DOM","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"面试","slug":"面试","permalink":"http://ydl8686.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Vue","slug":"Vue","permalink":"http://ydl8686.github.io/tags/Vue/"}]},{"title":"前端面试准备#Js","slug":"前端面试准备-Js","date":"2021-03-18T01:21:32.000Z","updated":"2021-05-06T10:22:55.039Z","comments":true,"path":"2021/03/18/前端面试准备-Js/","link":"","permalink":"http://ydl8686.github.io/2021/03/18/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87-Js/","excerpt":"","text":"变量提升js生成执行环境时，分为两个阶段。第一个阶段js解释器会找出需要提升的变量和函数，给他们提前在内存中开辟空间，函数是将整个代码块存入内存，变量只声明并且赋值为undefined；到第二个阶段代码执行阶段就可以提前使用 如果出现相同名称的函数、变量，那么后一个函数会覆盖上一个，并且函数提升的优先级高于变量的优先级 var可能会产生一些错误，所以ES6引入let，但其实let也在第一阶段为它在内存中开辟了空间，只是不能在声明前使用 判断对象是否是数组 a instanceof Array instanceof运算符用来检测Array.prototype属性是否存在于变量a的原型链上，也就是a._proto_.balabala._proto_能不能等于Array.prototype a.constructor===Array Object.prototype.toString.call(a)===&#39;[object Array]&#39; Array.isArray()ES5才提出 *箭头函数常规函数的this指针指向只有在运行时才能确定，并且可以通过call、apply、bind来进行修改；但是箭头函数其实没有this指针，它里面的this指向取决于他外面的第一个不是箭头函数的函数的 this，在运行时就已经确定了，并且不能被修改， async、await优缺点ES7提出，解决了回调地狱的问题，相比直接使用Promise而言，代码可读性更强，并且已经被浏览器原生支持 滥用或者错误使用async、await可能会造成性能降低，因为await会阻塞代码，例如两个没有什么关系的await会把可以异步执行的语句强行串行化，增加了执行时间，不利于并行执行 async、await更类似于语法糖，依赖的仍旧是promise （在执行到async标识的函数里的await的时候，会跳出这个async标识的函数，先去执行同步代码） *generator原理（ES6）嘤嘤嘤好难 PromisePromise可以看成一个有限状态机FSM，开始是pending，然后通过resolve和reject函数分别可以转换成resolved和rejected状态，然后就不能变更状态了 *实现Promise==和=====是相等运算符，===是严格运算符；前者表达式两边类型不同时会先进行类型转换再判断值是否相同，而===不仅要求值相同，类型也要相同 ==不具有传递性，比如 0 == ‘0’ ，0 == ‘’，但是 ‘0’ != ‘’。最好只有在检测 null/undefined 的时候才使用 x == null ，因为通常我们不区分 null 和 undefined ，即将 x == null 作为 x === null || x === undefined 的缩写 *垃圾回收解决 var 定义函数的问题12345for ( var i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 );&#125; 使用闭包 12345678//感觉又有点像立即执行函数for (var i = 1; i &lt;= 5; i++) &#123; (function(j) &#123; setTimeout(function timer() &#123; console.log(j); &#125;, j * 1000); &#125;)(i);&#125; 使用let来取代var 使用setTimeout第三个参数 12345for ( var i=1; i&lt;=5; i++) &#123; setTimeout( function timer(j) &#123; console.log( j ); &#125;, i*1000, i);&#125; 基本数据类型和引用类型在存储上的区别 前者存在栈中，后者在堆中 EventLoopjs是一门非阻塞单线程语言，在执行时会产生执行环境，依此被加入到执行栈中；但是遇到异步的代码会被挂起并加入到宏任务task或微任务job队列里。像setTimeout、setInterval会进入宏队列，Promise、observe会进入微队列。资料 浏览器EventLoop具体在运行时，先运行全局同步代码，遇到异步代码会被挂起放到相应的队列中，等同步执行完以后，从微队列中依次取出头部的代码执行；等到微队列为空时，取宏队列中头部代码执行，这个代码执行完之后再取微队列里面代码执行，循环往复。如果在执行微任务的时候又产生了微任务，那么就把产生的微任务继续添加到微队列中等待执行。 NodeJS EventLoop setTimeout倒计时误差JS 是单线程的，所以 setTimeout 的误差其实是无法被完全解决的，原因有很多，可能是回调中的，有可能是浏览器中的各种事件导致 防抖(debounce)和节流(throttle)都是性能优化的知识 防抖：对于短时间内连续触发的事件（上面的滚动事件），防抖的含义就是让某个时间期限（如上面的1000毫秒）内，事件处理函数只执行一次。 下面是延迟执行的防抖函数，还有立即执行的防抖函数 12345678910111213141516/*****************************简化后的分割线 ******************************/function debounce(fn,delay)&#123; let timer = null //借助闭包 return function() &#123; if(timer)&#123; clearTimeout(timer) &#125; timer = setTimeout(fn,delay) // 简化写法 &#125;&#125;// 然后是旧代码function showTop () &#123; var scrollTop = document.body.scrollTop || document.documentElement.scrollTop; console.log(&#x27;滚动条位置：&#x27; + scrollTop);&#125;window.onscroll = debounce(showTop,1000) // 为了方便观察效果我们取个大点的间断值，实际使用根据需要来配置 节流：类似于王者的技能CD，函数执行了一次之后，在指定时间期限内进入冷却期 1234567891011121314151617181920212223242526function throttle(fn,delay)&#123; let valid = true return function() &#123; if(!valid)&#123; //休息时间 暂不接客 return false &#125; // 工作时间，执行函数并且在间隔期内把状态位设为无效 valid = false setTimeout(() =&gt; &#123; fn() valid = true; &#125;, delay) &#125;&#125;/* 请注意，节流函数并不止上面这种实现方案, 例如可以完全不借助setTimeout，可以把状态位换成时间戳，然后利用时间戳差值是否大于指定间隔时间来做判定。 也可以直接将setTimeout的返回的标记当做判断条件-判断当前定时器是否存在，如果存在表示还在冷却，并且在执行fn之后消除定时器表示激活，原理都一样 */// 以下照旧function showTop () &#123; var scrollTop = document.body.scrollTop || document.documentElement.scrollTop; console.log(&#x27;滚动条位置：&#x27; + scrollTop);&#125;window.onscroll = throttle(showTop,1000) 搜索框输入的时候可以使用节流函数，每隔一段时间查询相关内容作为推荐搜索 页面resize进行dom渲染的时候可以使用防抖函数，只需要判断最后一次变化的情况 不停点击按钮则是防抖函数 数组降维12345const flattenDeep = (arr) =&gt; Array.isArray(arr) ? arr.reduce( (a, b) =&gt; [...a, ...flattenDeep(b)] , []) : [arr]flattenDeep([1, [[2], [3, [4]], 5]]) 基本数据类型undefined、null、boolean、string、number、object、symbol（ES6，表示独一无二的值） typeof、instanceoftypeof对于基本类型除了null这个基本类型会返回object错误结果之外，其他都是对的； 对于对象，除了函数会返回function以外，其他都是object 在 JS 的最初版本中，使用的是 32 位系统，为了性能考虑使用低位存储了变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。 instanceof则是通过判断对象的原型链中能不能找到某个类型的prototype 123456789101112131415//实现instanceoffunction instanceof(left, right) &#123; // 获得类型的原型 let prototype = right.prototype // 获得对象的原型 left = left.__proto__ // 判断对象的类型是否等于类型的原型 while (true) &#123; if (left === null) return false if (prototype === left) return true left = left.__proto__ &#125;&#125; 使用cookie注意事项由服务器生成，可以设置过期时间，最大为4K，像localStorage、sessionStorage则是5M；会携带在header中，影响请求性能 判断页面加载完成DOMContentLoaded 事件触发代表DOM被完全解析，此时CSS，JS，图片等还未加载 Load事件触发则是所有的都加载完毕 事件委托/代理事件代理就是指利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件，例如委托父级代为执行事件。就好比每个公司员工都亲自去取快递和安排一个前台来负责快递签收和分发给员工，并且加入新的员工也可以被帮助签收和分发。 在js中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排（回流）的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；而且每个函数都是一个对象，对象越多，内存占用率就越大，自然性能就越差；如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了；而且不需要给子节点注销事件 可以用target来获得当前事件绑定的标签名，从而实现虽然绑定到了ul，但是只有点击li才会触发事件，并且每次只执行一次dom操作 缺点：事件委托基于冒泡，对于不冒泡的事件不支持；层级过多，冒泡过程中，可能会被某层阻止掉 重绘、回流重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘；布局或者几何属性需要改变就称为回流。回流一定会重绘，重绘不一定回流；这两个操作都和EventLoop有关 减少办法：使用translate代替top、使用visibility代替display：none、把DOM离线后修改（先display：none，再修改再显示）、不使用table、CSS选择符从右向左匹配（避免DOM深度过深） CDN内容分发网络，静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"面试","slug":"面试","permalink":"http://ydl8686.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"前端","slug":"前端","permalink":"http://ydl8686.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Java面试","slug":"Java面试","date":"2021-03-09T00:21:15.000Z","updated":"2021-04-22T16:39:47.120Z","comments":true,"path":"2021/03/09/Java面试/","link":"","permalink":"http://ydl8686.github.io/2021/03/09/Java%E9%9D%A2%E8%AF%95/","excerpt":"","text":"Set和Map容器都有基于==哈希存储==和==排序树==的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。 ArrayList和Vector都是基于数组的底层方式实现，但是Vector方法添加了synchronized关键字修饰，是线程安全的容器，但性能上较ArrayList差；LinkedList使用双向链表实现（比ArrayList更占内存）。ArrayList和LinkedList都是非线程安全的，可以通过Collections中的synchronizedList方法将其转成线程安全的容器后再使用（装潢模式） 常用集合抽象类有List、Set、Map，前两个继承自Collection接口；然后List具体实现有ArrayList、LinkedList和Vector，Map集合用于存储元键值对（一对一，多对一） HashMap和HashTable都实现了Map接口；但Map允许键和值为null，而table两个都不能为null；table是同步的，而Map不是，所以table更适合多线程环境。HashMap是快速失败的，并且提供了对键的枚举。 具有快速失败特性的集合在用迭代器遍历集合对象时，如果集合对象的内容发生了修改，那么会抛出Concurrent Modification Exception，内部会有一个modCount变量来检测内容是否发生变化，modCount!=expectedmodCount就抛出异常；而安全失败则不会。","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"面试","slug":"面试","permalink":"http://ydl8686.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"计算机网络","slug":"计算机网络","date":"2021-03-06T08:45:19.000Z","updated":"2021-05-06T10:22:02.289Z","comments":true,"path":"2021/03/06/计算机网络/","link":"","permalink":"http://ydl8686.github.io/2021/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错（FCS），不能跨网段 CSMA/CD：载波侦听多路访问/冲突检测，当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定 MAC地址用来唯一标识网卡，48位，一般笔记本有有线和无线两个网卡也即两个MAC地址 主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术 交换机不能划分网段但是可以划分vlan，而路由器是则两个都可以划分（802.1Q） ARP 实现由 IP 地址得到 MAC 地址 交换机能够隔离冲突域，但是不能隔离广播域；路由器都行 Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。 Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。 数据链路层只负责本网段的链路通信，网络层只把分组（Packets）发送到目的主机，但是真正通信的并不是主机而是主机中的进程，传输层提供了进程间的逻辑通信 TCP 使用超时重传来实现可靠传输","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"计网","slug":"计网","permalink":"http://ydl8686.github.io/tags/%E8%AE%A1%E7%BD%91/"}]},{"title":"Java基础知识","slug":"Java基础知识","date":"2021-03-06T07:23:09.000Z","updated":"2021-04-22T16:39:54.226Z","comments":true,"path":"2021/03/06/Java基础知识/","link":"","permalink":"http://ydl8686.github.io/2021/03/06/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为： this.func(this) super.func(this) this.func(super) super.func(super) 重写override–父类子类 重写有三个限制 子类方法的访问权限必须大于等于父类方法； 子类方法的返回类型必须是父类方法返回类型或为其子类型。 子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。 重载overload–同一类里的不同方法–名称相同，但参数类型、个数、顺序至少有一个不同（和返回值无关） 泛型防止了在集合中存储对象并在使用前进行类型转换是多么的不方便的发生。它提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException。 泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型 有两种限定通配符，一种是&lt;? extends T&gt;它通过确保类型必须是T的子类来设定类型的上界，另一种是&lt;? super T&gt;它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面&lt;?&gt;表示了非限定通配符，因为&lt;?&gt;可以用任意类型来替代。 Array事实上并不支持泛型，这也是为什么Joshua Bloch在Effective Java一书中建议使用List来代替Array，因为List可以提供编译期的类型安全保证，而Array却不能。 1234int[] array=new int[5];array[0]=1;array[1]=&#x27;1&#x27;;//这样并不报错 ref：10 道 Java 泛型面试题 Java基础知识","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Java","slug":"Java","permalink":"http://ydl8686.github.io/tags/Java/"}]},{"title":"maven#2","slug":"maven-2","date":"2021-03-04T07:22:16.000Z","updated":"2021-04-22T16:39:33.812Z","comments":true,"path":"2021/03/04/maven-2/","link":"","permalink":"http://ydl8686.github.io/2021/03/04/maven-2/","excerpt":"","text":"常用命令命令格式：mvn [plugin-name]:[command-name] 命令参数-D传入属性参数mvn package -Dmaven.test.skip=true以-D开头，将对应属性参数设为true，告诉maven打包时跳过单元测试。同理mvn deploy -Dmaven.test.skip=true代表部署项目并跳过单元测试。 -P使用指定的Profile配置项目开发有多个环境，一般包括开发、测试、预发、正式四个。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;env&gt;dev&lt;/env&gt; &lt;/properties&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;qa&lt;/id&gt; &lt;properties&gt; &lt;env&gt;qa&lt;/env&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;pre&lt;/id&gt; &lt;properties&gt; &lt;env&gt;pre&lt;/env&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;prod&lt;/id&gt; &lt;properties&gt; &lt;env&gt;prod&lt;/env&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;profiles&gt;&lt;build&gt; &lt;filters&gt; &lt;filter&gt;config/$&#123;env&#125;.properties&lt;/filter&gt; &lt;/filters&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; filters定义了变量配置文件的地址，resources中是定义哪些目录下的文件会被配置文件中定义的变量替换 mvn package -Pdev -Dmaven.test.skip=true表示打包本地环境并跳过单元测试 创建基本Maven项目github地址 Maven仓库基本概念Maven默认从远程库中下载一些核心插件和jar包 仓库分为两类：本地仓库和远程仓库 当maven根据坐标寻找构件时，首先查看本地仓库，如果本地仓库有就直接使用，没有就去远程仓库找；如果远程有，就下载到本地再使用，如果本地和远程都没有，maven就会报错 远程仓库分为三种：中央仓库（默认配置下载jar包的地方）、私服、其他公共库 本地仓库位置：~/.m2/repository 可以直接搜索mvn，然后再搜索对应的依赖，会有直接的代码提示 Maven环境下构建多模块项目1234模块 maven_parent --基模块，常说的parent模块 maven_dao --数据库的访问层，例如jdbc模块 maven_service --项目的业务逻辑层模块 maven_controller --用来接收请求，响应数据 java项目打包压缩成jar包，web项目则是war包","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"maven","slug":"maven","permalink":"http://ydl8686.github.io/tags/maven/"}]},{"title":"算法#7","slug":"算法-7","date":"2021-03-04T01:29:25.000Z","updated":"2021-05-06T10:24:37.741Z","comments":true,"path":"2021/03/04/算法-7/","link":"","permalink":"http://ydl8686.github.io/2021/03/04/%E7%AE%97%E6%B3%95-7/","excerpt":"","text":"day7！冲冲冲 复杂链表的复制 12345678910111213141516171819202122232425262728293031323334//理解一下题目的意思，是要拷贝一个新的链表，不能直接return head，因为返回的是引用不是拷贝public Node copyRandomList(Node head) &#123; if(head==null)&#123; return null; &#125; //先复制 Node realHead=head; while(head!=null)&#123; Node temp=new Node(head.val); temp.next=head.next; head.next=temp; head=temp.next; &#125; //再赋值 Node tem=realHead; while(tem!=null)&#123; if(tem.random==null)&#123; tem.next.random=null; &#125; else&#123; tem.next.random=tem.random.next; &#125; tem=tem.next.next; &#125; //最后拆分 Node cloneHead=realHead.next; tem=realHead; while(tem!=null &amp;&amp; tem.next!=null)&#123; Node t=tem.next; tem.next=tem.next.next; tem=t; &#125; return cloneHead; &#125; 两个链表的第一个公共节点 1234567891011121314151617181920212223//需要注意的是，两个链表也可以在最后的null节点相交public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA==null || headB==null)&#123; return null; &#125; ListNode p=headA; ListNode q=headB; while(p!=q)&#123; if(p==null)&#123; p=headB; &#125; else&#123; p=p.next; &#125; if(q==null)&#123; q=headA; &#125; else&#123; q=q.next; &#125; &#125; return p; &#125;","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"http://ydl8686.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"http://ydl8686.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"maven#1","slug":"maven-1","date":"2021-03-03T08:28:16.000Z","updated":"2021-04-22T16:39:14.975Z","comments":true,"path":"2021/03/03/maven-1/","link":"","permalink":"http://ydl8686.github.io/2021/03/03/maven-1/","excerpt":"","text":"概念Maven（项目构建工具：Ant–&gt;Maven–&gt;Gradle）是项目对象模型，通过其描述信息来管理项目的构建，报告和文档的软件项目管理工具，支持从网络上下载的功能，仍然采用xml作为配置文件格式。Maven专注的是依赖管理，用java编写。 四大特性依赖管理系统Maven为Java引入了一个新的依赖管理系统，升级时修改配置文件即可，用groupid（jar包所在公司）、artifactid（公司的项目）、version（版本）组成的坐标来唯一标识一个依赖。 任何基于Maven构建的项目自身也必须定义这三个属性，生成的包可以是jar包，也可以是war包。 Maven会根据坐标自动来下载依赖。 多模块构建在Maven中定义一个parent POM做为一组module的聚合POM，在该POM中可以使用&lt;modules&gt;标签来定义一组子模块，parent POM不会有什么实际构建产出，而parent POM中的build配置以及依赖配置都会自动继承给子module。 一致的项目结构制定了一套项目目录结构作为标准的Java项目结构，解决了不同ide带来的文件目录不一致的问题 一致的构建模型和插件机制插件和依赖的形式大致类似 项目结构 编译和运行123//项目根目录下mvn compile //编译项目mvn exec:java -Dexec.mainClass=&quot;org.example.App&quot; //执行某个Class","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"maven","slug":"maven","permalink":"http://ydl8686.github.io/tags/maven/"}]},{"title":"算法#6","slug":"算法-6","date":"2021-03-02T00:07:08.000Z","updated":"2021-05-06T10:24:30.800Z","comments":true,"path":"2021/03/02/算法-6/","link":"","permalink":"http://ydl8686.github.io/2021/03/02/%E7%AE%97%E6%B3%95-6/","excerpt":"","text":"Day6…打第五头有点痛……… 反转链表 1234567891011121314151617181920/** * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; *///头插法，嗯背class Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode realHead=new ListNode(999); while(head!=null)&#123; ListNode next=head.next; head.next=realHead.next; realHead.next=head; head=next; &#125; return realHead.next; &#125;&#125; 合并两个排序的链表 123456789101112131415161718//我的做法哈哈哈，果然超出了时间限制。。public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1==null)&#123; return l2; &#125; if(l2==null)&#123; return l1; &#125; ListNode t=l2; while(l2.val&lt;=l1.val)&#123; t=l2; l2=l2.next; &#125; ListNode tem=l1; l1.next=l2; t.next=l1; return mergeTwoLists(tem.next,l1); &#125; 123456789101112131415//没有对比没有思考public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) return l2; if (l2 == null) return l1; if (l1.val &lt;= l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; &#125; 这里和C++不一样，Java传递的是对象的引用，所以作为参数也会更改传进来之前的内容","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"http://ydl8686.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"递归","slug":"递归","permalink":"http://ydl8686.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"链表","slug":"链表","permalink":"http://ydl8686.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"算法#5","slug":"算法-5","date":"2021-03-01T00:28:53.000Z","updated":"2021-05-06T10:24:23.641Z","comments":true,"path":"2021/03/01/算法-5/","link":"","permalink":"http://ydl8686.github.io/2021/03/01/%E7%AE%97%E6%B3%95-5/","excerpt":"","text":"打卡day5！写完这个看一会儿小狼大大直播画画！ 在Java中，数组作为参数传递，传递的是引用而不是拷贝 左旋转字符串 123456789101112131415161718192021222324252627public class Solution &#123; //和上一道题大同小异，复杂度为O(N) public String LeftRotateString(String str,int n) &#123; if(str==null || str.length()==0)&#123; return &quot;&quot;; &#125; char[] arr=str.toCharArray(); int len=str.length(); int x=0,y=n,z=len; for(int i=0;i&lt;n/2;i++)&#123; char t=arr[i]; arr[i]=arr[y-i-1]; arr[y-i-1]=t; &#125; for(int i=y;i&lt;(z-y)/2+y;i++)&#123; char t=arr[i]; arr[i]=arr[z-(i-y)-1]; arr[z-(i-y)-1]=t; &#125; for(int i=0;i&lt;z/2;i++)&#123; char t=arr[i]; arr[i]=arr[z-i-1]; arr[z-i-1]=t; &#125; return new String(arr); &#125;&#125; 从尾到头打印链表 123456789101112131415161718192021222324252627/*** public class ListNode &#123;* int val;* ListNode next = null;** ListNode(int val) &#123;* this.val = val;* &#125;* &#125;**///法一：额外使用栈数据结构import java.util.*;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; Stack&lt;Integer&gt; s=new Stack&lt;&gt;(); ArrayList&lt;Integer&gt; rs=new ArrayList&lt;&gt;(); while(listNode!=null)&#123; s.push(listNode.val); listNode=listNode.next; &#125; while(!s.empty())&#123; rs.add(s.pop()); &#125; return rs; &#125;&#125; 12345678910//法二：递归public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if (listNode != null) &#123; //addAll()方法将给定集合中的所有元素添加到 arraylist 中。 ret.addAll(printListFromTailToHead(listNode.next)); ret.add(listNode.val); &#125; return ret;&#125; 删除链表中重复的节点 123456789101112131415161718192021222324252627282930313233/* public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode deleteDuplication(ListNode pHead) &#123; ListNode realHead=new ListNode(999); //迷惑的地方在于readhead指向的节点不是没有变过么？？？？？ realHead.next=pHead; ListNode extra; extra=realHead; while(pHead!=null &amp;&amp; pHead.next!=null)&#123; if(pHead.val==pHead.next.val)&#123; while(pHead.next!=null &amp;&amp; pHead.val==pHead.next.val)&#123; pHead=pHead.next; &#125; pHead=pHead.next; extra.next=pHead; &#125; else&#123; extra=pHead; pHead=pHead.next; &#125; &#125; return realHead.next; &#125;&#125; 链表中倒数第k个节点 1234567891011121314151617181920212223242526272829303132/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; ListNode result=head; if(head==null || k==0)&#123; return null; &#125; //本来就指向第一个节点了所以k要-1 //往后移k-1个 for(int i=0;i&lt;k-1;i++)&#123; head=head.next; //k==0和这里==null都是为了防止边界出问题 if(head==null)&#123; return null; &#125; &#125; //挪到最后一个节点 while(head.next!=null)&#123; head=head.next; result=result.next; &#125; return result; &#125;&#125; 链表中环的入口节点 123456789101112131415161718192021222324252627282930313233343536/* public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; //先让一个指针两步两步走，一个指针一步一步走，相遇节点记下来 //将其中一个节点放到开头，再同时两个指针一步一步走，相遇的节点就是答案 //需要注意的是，需要判断这个链表中是否有环 public ListNode EntryNodeOfLoop(ListNode pHead) &#123; if(pHead==null || pHead.next==null || pHead.next.next==null)&#123; return null; &#125; ListNode pSlow=pHead; ListNode pFast=pHead; //如果没有环，这里一定会跳出循环，返回null while(pFast.next!=null &amp;&amp; pFast.next.next!=null)&#123; pFast=pFast.next.next; pSlow=pSlow.next; if(pFast==pSlow)&#123; pFast=pHead; while(pFast!=pSlow)&#123; pFast=pFast.next; pSlow=pSlow.next; &#125; return pFast; &#125; &#125; return null; &#125;&#125;","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"http://ydl8686.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"递归","slug":"递归","permalink":"http://ydl8686.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"双指针","slug":"双指针","permalink":"http://ydl8686.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"链表","slug":"链表","permalink":"http://ydl8686.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"算法#4","slug":"算法-4","date":"2021-02-28T02:51:41.000Z","updated":"2021-05-06T10:24:14.736Z","comments":true,"path":"2021/02/28/算法-4/","link":"","permalink":"http://ydl8686.github.io/2021/02/28/%E7%AE%97%E6%B3%95-4/","excerpt":"","text":"打卡day4！！！明天正式开学！ 预备知识12345//String转字符数组String str=&quot;123&quot;;char[] arr=str.toCharArray(); //[&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;]//字符数组转StringString newStr=new String(arr); 滑动窗口的最大值 1234567891011121314151617181920212223import java.util.*;public class Solution &#123; public ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size) &#123; PriorityQueue&lt;Integer&gt; pq=new PriorityQueue&lt;&gt;((o1,o2)-&gt;o2-o1); ArrayList&lt;Integer&gt; result=new ArrayList&lt;&gt;(); //这里也好奇怪，滑动窗口大小为0或者大于数组长度时都返回空集合 if(size==0 || size&gt;num.length)&#123; return result; &#125; for(int i=0;i&lt;size;i++)&#123; pq.add(num[i]); &#125; result.add(pq.peek()); //始终维护一个大小为size的最大堆，滑动窗口移动时用索引删掉/增加相应元素 for(int i=0,j=size;j&lt;num.length;i++,j++)&#123; //remove方法可以删掉对应的元素 pq.remove(num[i]); pq.add(num[j]); result.add(pq.peek()); &#125; return result; &#125;&#125; 和为S的两个数字 1234567891011121314151617181920212223import java.util.ArrayList;//如果多对数字和为S，越靠近中间那对乘积越大，反之第一个符合条件的乘积越小public class Solution &#123; public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) &#123; int i=0,j=array.length-1; ArrayList&lt;Integer&gt; arr=new ArrayList&lt;&gt;(); int result=0; while(i&lt;j)&#123; if((array[i]+array[j])&gt;sum)&#123; j--; &#125; else if((array[i]+array[j])&lt;sum)&#123; i++; &#125; else&#123; arr.add(array[i]); arr.add(array[j]); break; &#125; &#125; return arr; &#125;&#125; 和为S的连续正数序列123456789101112131415161718192021222324252627282930313233import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt; &gt; result = new ArrayList&lt;&gt;(); //两个起点，相当于动态窗口的两边，根据其窗口内的值的和来确定窗口的位置和大小 //之所以选择1和2最小的两个正数，是因为 //两个窗口都是从左边出发，不是两边夹逼。另外，当小于目标数时high++；大于目标数时low++，如果是high--，那么仔细想想，窗口还怎么往后移动，整个结果在第一次大于目标数之后就不会往后移动，相反，而是在在这个low和high之间夹逼试探，最终啥都找不到或者只能找到一个。 int plow = 1,phigh = 2; while(phigh &gt; plow)&#123; //没有想到求和公式我是笨比 //由于是连续的，差为1的一个序列，那么求和公式是(a0+an)*n/2 int cur = (phigh + plow) * (phigh - plow + 1) / 2; //相等，那么就将窗口范围的所有数添加进结果集 if(cur == sum)&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i=plow;i&lt;=phigh;i++)&#123; list.add(i); &#125; result.add(list); //这里无论是plow++还是phigh++其实都一样 //先plow后phigh和先phigh后plow最终效果都是整个窗口往右移 plow++; //如果当前窗口内的值之和小于sum，那么右边窗口右移一下 &#125;else if(cur &lt; sum)&#123; phigh++; &#125;else&#123; //如果当前窗口内的值之和大于sum，那么左边窗口右移一下 plow++; &#125; &#125; return result; &#125;&#125; 翻转单词顺序列 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public String ReverseSentence(String str) &#123; char[] arr=str.toCharArray(); //先整体翻转 for(int i=0;i&lt;(str.length()/2);i++)&#123; char t=arr[i]; arr[i]=arr[str.length()-1-i]; arr[str.length()-1-i]=t; &#125; //双指针定位要翻转的子串 int i=0,j=0; while(j&lt;str.length())&#123; for(;j&lt;str.length();j++)&#123; if(arr[j]==&#x27; &#x27;)&#123; //考虑边界是真的烦😡 for(int x=i;x&lt;((j-i)/2)+i;x++)&#123; char t=arr[x]; arr[x]=arr[j-1-(x-i)]; arr[j-1-(x-i)]=t; &#125; j++; i=j; break; &#125; &#125; &#125; //上面步骤最后一部分子串一定不会被翻转，所以单独翻转 for(int x=i;x&lt;((j-i)/2)+i;x++)&#123; char t=arr[x]; arr[x]=arr[j-1-(x-i)]; arr[j-1-(x-i)]=t; &#125; return new String(arr); &#125;&#125; 这道题的难点就是边界索引值。。。","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"http://ydl8686.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"双指针","slug":"双指针","permalink":"http://ydl8686.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"算法#3","slug":"算法-3","date":"2021-02-27T09:08:13.000Z","updated":"2021-05-06T10:24:04.793Z","comments":true,"path":"2021/02/27/算法-3/","link":"","permalink":"http://ydl8686.github.io/2021/02/27/%E7%AE%97%E6%B3%95-3/","excerpt":"","text":"算法day3打卡！我好菜啊嘤嘤嘤～ 数据结构回忆 那么堆与优先级队列又有什么关系呢，实质上堆可用来实现优先级队列，或者说堆就是一种优先级队列。由于堆的添加元素与删除元素时都会破坏堆结构，所以添加与删除进都要进行结构调整。一般普通的队列添加是在最后加入，但优先级队列却不一定添加到最后，他会按照优先级算法把它插入到队列当中去，出队时还是从第一个（也即最小元素，优先级最高）开始，即取根元素，这样保证了队列中优先级高的先服务，而不是先来先服务了。 Heap类是对PriorityQueue接口的一种高效实现。堆是一种完全二叉树。由于使用基于数组的完全二叉树的表示，可以根据子节点的索引快速计算出你父节点的索引，反之亦然，所以，使用数组来表示堆，它是利用了数组可以根据给定索引随机访问元素的特性。 队列 栈的压入、弹出序列 12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Stack;//这是错误的做法！！！但是牛客网居然判对！public class Solution &#123; public boolean IsPopOrder(int [] pushA,int [] popA) &#123; //如果需要push的元素已经空了但是pushA栈顶和popA指针指向的元素不相等就flase //先用i、j来将一部分数字过滤掉，i越界时，剩下的stack就一定只有一种序列了 Stack&lt;Integer&gt; s=new Stack&lt;Integer&gt;(); int i=0; int j=0; while(i&lt;pushA.length)&#123; if(pushA[i]!=popA[j])&#123; s.push(pushA[i]); i++; &#125; else&#123; i++; j++; &#125; &#125; while(!s.empty())&#123; int t=s.pop(); if(t!=popA[j])&#123; return false; &#125; else&#123; j++; &#125; &#125; return true; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637import java.util.ArrayList;import java.util.Stack;//这个才是正确的方法public class Solution &#123; public boolean IsPopOrder(int [] pushA,int [] popA) &#123; Stack&lt;Integer&gt; s=new Stack&lt;Integer&gt;(); int i=0; int j=0; while(i&lt;pushA.length)&#123; //先判断s栈顶和popA是否相等，然后再判断两个数组关系 //[1,2,3,4,5],[4,3,5,2,1] if(!s.empty() &amp;&amp; s.peek()==popA[j])&#123; s.pop(); j++; &#125; else if(pushA[i]!=popA[j])&#123; s.push(pushA[i]); i++; &#125; else&#123; i++; j++; &#125; &#125; while(!s.empty())&#123; int t=s.pop(); if(t!=popA[j])&#123; return false; &#125; else&#123; j++; &#125; &#125; return true; &#125;&#125; 最小的k个数 12345678910111213141516171819202122232425import java.util.ArrayList;import java.util.PriorityQueue;//复杂度：O(NlogK) + O(K)，K是结果集合的大小常数public class Solution &#123; public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123; //题目的要求真怪，如果有5个元素的数组求前10小元素的返回空集合 if(k&lt;=0 || input.length&lt;k)&#123; return new ArrayList&lt;Integer&gt;(); &#125; //Java中的优先级队列默认是最小堆 //利用lambda表达式来转换成最大堆 PriorityQueue&lt;Integer&gt; maxHeap=new PriorityQueue&lt;Integer&gt;((o1, o2) -&gt; o2 - o1); for(int t:input)&#123; //往优先级队列中添加元素 maxHeap.add(t); if(maxHeap.size()&gt;k)&#123; //把堆顶最大的那个删掉 //会返回被删掉的那个元素 maxHeap.poll(); &#125; &#125; return new ArrayList&lt;&gt;(maxHeap); &#125;&#125; 数据流中的中位数 123456789101112131415161718192021222324252627282930313233343536import java.util.PriorityQueue;//把数据分成两堆，左边是最大堆，右边是最小堆//如果数据量是偶数，分别peek取平均值//反之，根据Insert的第一个判断来确定选左边还是右边的peekpublic class Solution &#123; PriorityQueue&lt;Integer&gt; minHeap=new PriorityQueue&lt;&gt;(); PriorityQueue&lt;Integer&gt; maxHeap=new PriorityQueue&lt;&gt;((o1,o2)-&gt; o2-o1); int n=0; public void Insert(Integer num) &#123; //这个判断是要让两个堆的大小大致相同 //其实先插到左边或右边的顺序无所谓，只是会影响奇数时选取哪一边的peek而已 if(n%2==0)&#123; maxHeap.add(num); minHeap.add(maxHeap.poll()); &#125; else&#123; minHeap.add(num); maxHeap.add(minHeap.poll()); &#125; n++; &#125; public Double GetMedian() &#123; if(n%2==0)&#123; //2.0不是2!!，2的话结果是Integer return (maxHeap.peek()+minHeap.peek())/2.0; &#125; else&#123; //强制类型转换 return (double) minHeap.peek(); &#125; &#125;&#125; 字符流中第一个不重复的数字 1234567891011121314151617181920212223242526272829303132import java.util.Queue;import java.util.LinkedList;public class Solution &#123; //Insert one char from stringstream int[] arr=new int[128]; //注意这里是LinkedList Queue&lt;Character&gt; q=new LinkedList&lt;&gt;(); public void Insert(char ch) &#123; arr[ch]+=1; //add失败时会抛出异常，offer则不会 q.offer(ch); &#125; //return the first appearence once char in current stringstream public char FirstAppearingOnce() &#123; //q.size()==0等价于q.isEmpty() //栈的话则是s.empty() while(q.size()!=0 &amp;&amp; arr[q.peek()]&gt;1)&#123; q.poll(); &#125; //也可以写成return q.size()==0?&#x27;#&#x27;:q.peek(); if(q.size()==0)&#123; return &#x27;#&#x27;; &#125; else&#123; return q.peek(); &#125; &#125;&#125;","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"http://ydl8686.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"栈","slug":"栈","permalink":"http://ydl8686.github.io/tags/%E6%A0%88/"},{"name":"优先级队列","slug":"优先级队列","permalink":"http://ydl8686.github.io/tags/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"},{"name":"最大堆、最小堆","slug":"最大堆、最小堆","permalink":"http://ydl8686.github.io/tags/%E6%9C%80%E5%A4%A7%E5%A0%86%E3%80%81%E6%9C%80%E5%B0%8F%E5%A0%86/"},{"name":"队列","slug":"队列","permalink":"http://ydl8686.github.io/tags/%E9%98%9F%E5%88%97/"}]},{"title":"服务端#3","slug":"服务端-3","date":"2021-02-24T03:53:26.000Z","updated":"2021-02-27T02:53:16.373Z","comments":true,"path":"2021/02/24/服务端-3/","link":"","permalink":"http://ydl8686.github.io/2021/02/24/%E6%9C%8D%E5%8A%A1%E7%AB%AF-3/","excerpt":"","text":"JDBC控制事务事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。 操作： 开启事务 提交事务 回滚事务 使用Connection对象来管理事务 12345开启事务：void setAutoCommit(boolean autoCommit) //调用该方法设置参数为false即开启事务,默认关闭提交事务：void commit()回滚事务：void rollback()","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"服务端开发","slug":"服务端开发","permalink":"http://ydl8686.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JDBC","slug":"JDBC","permalink":"http://ydl8686.github.io/tags/JDBC/"}]},{"title":"想做的事","slug":"想做的事","date":"2021-02-23T07:15:26.000Z","updated":"2021-04-05T13:02:40.369Z","comments":true,"path":"2021/02/23/想做的事/","link":"","permalink":"http://ydl8686.github.io/2021/02/23/%E6%83%B3%E5%81%9A%E7%9A%84%E4%BA%8B/","excerpt":"","text":"去一次狛纳公馆 泡一次汤 去一次Jolin的演唱会 去日本看一次花火祭","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://ydl8686.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"服务端#2","slug":"服务端-2","date":"2021-02-23T03:45:11.000Z","updated":"2021-05-06T10:21:28.200Z","comments":true,"path":"2021/02/23/服务端-2/","link":"","permalink":"http://ydl8686.github.io/2021/02/23/%E6%9C%8D%E5%8A%A1%E7%AB%AF-2/","excerpt":"","text":"JDBC抽取工具类主要是对之前代码的获取资源和释放资源操作进一步的抽象和封装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package cn.itcast.jdbc.util;import java.io.FileReader;import java.io.IOException;import java.net.URL;import java.sql.*;import java.util.Properties;//JDBC工具类public class JDBCUtils &#123; //只有静态成员变量才能被静态代码块和静态方法所访问 //相当于把原来在getConnection()里写固定的参数，通过加载配置文件到静态成员变量，然后静态代码块在加载时初始化给静态方法使用 private static String url; private static String user; private static String password; private static String driver; //对于配置文件的读取，只需要读取一次就可拿到这些参数；可以利用静态代码块，在类加载的时候就只读取一次 static &#123; try &#123; //读取资源文件获取参数给getConnection()使用 //1.创建Properties集合类 Properties pro=new Properties(); //需要注意的是如何获取jdbc.properties的路径 //获取src路径下文件的方式---ClassLoader加载器 ClassLoader classLoader=JDBCUtils.class.getClassLoader();//随便获取一个类的字节码文件 URL res=classLoader.getResource(&quot;jdbc.properties&quot;);//这里的url是相对于src文件的相对路径，返回的是一个URL，需要转换成String String path = res.getPath(); //2.加载配置文件 pro.load(new FileReader(path)); //3.获取数据赋值 url=pro.getProperty(&quot;url&quot;); user=pro.getProperty(&quot;user&quot;); password=pro.getProperty(&quot;password&quot;); driver=pro.getProperty(&quot;driver&quot;); //4.注册驱动 try &#123; Class.forName(driver); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接 * @return 连接对象 */ //需求：不想传递连接数据库的参数，还得保证工具类的通用性 //解决：用配置文件来记录参数，例如jdbc.properties public static Connection getConnection() throws SQLException&#123; return DriverManager.getConnection(url,user,password); &#125; /** * 释放资源 * @param stmt * @param conn */ //如果执行executeUpdate(),需要释放Connection、Statement //如果执行executeQuery(),需要额外释放ResultSet public static void close(Statement stmt,Connection conn)&#123; //先释放后申请的资源，再释放先申请的资源 if(stmt!=null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn!=null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //实现了重载 public static void close(ResultSet rs,Statement stmt, Connection conn)&#123; if(rs!=null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt!=null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn!=null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"服务端开发","slug":"服务端开发","permalink":"http://ydl8686.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JDBC","slug":"JDBC","permalink":"http://ydl8686.github.io/tags/JDBC/"}]},{"title":"算法#2","slug":"算法-2","date":"2021-02-21T02:18:53.000Z","updated":"2021-05-06T10:23:52.976Z","comments":true,"path":"2021/02/21/算法-2/","link":"","permalink":"http://ydl8686.github.io/2021/02/21/%E7%AE%97%E6%B3%95-2/","excerpt":"","text":"打卡day2！ 前置知识StringBuffer replace方法里的（start，end）是左闭右开 12345//String转StringBufferStringBuffer buffer = new StringBuffer(&quot;java&quot;);String str = new String(buffer);//StringBuffer转StringStringBuffer buffer=new StringBuffer(str); Stack 正文替换空格 12345678910111213141516171819202122232425public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; int x=str.length(); for(int i=0;i&lt;x;i++)&#123; if(str.charAt(i)==&#x27; &#x27;)&#123; str.append(&quot;hh&quot;); &#125; &#125; int p1=x-1; int p2=str.length()-1; while(p2&gt;p1 &amp;&amp; p1&gt;=0)&#123; if(str.charAt(p1)!=&#x27; &#x27;)&#123; str.replace(p2,p2+1,&quot;&quot;+str.charAt(p1)); p2--; p1--; &#125; else&#123; str.replace(p2-2,p2+1,&quot;%20&quot;); p2-=3; p1--; &#125; &#125; return new String(str); &#125;&#125; 顺时针打印矩阵 123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; ArrayList&lt;Integer&gt; arr=new ArrayList(); int size1=matrix.length; int size2=matrix[0].length; int r1=0; int r2=size1-1; int c1=0; int c2=size2-1; while(r2&gt;=r1 &amp;&amp; c2&gt;=c1)&#123; //打印最上一行 for(int i=c1;i&lt;=c2;i++)&#123; arr.add(matrix[r1][i]); &#125; //打印最右一行 for(int i=r1+1;i&lt;=r2;i++)&#123; arr.add(matrix[i][c2]); &#125; if(r2!=r1)&#123; //打印最下一行 for(int i=c2-1;i&gt;=c1;i--)&#123; arr.add(matrix[r2][i]); &#125; &#125; if(c1!=c2)&#123; //打印最左一行 for(int i=r2-1;i&gt;=r1+1;i--)&#123; arr.add(matrix[i][c1]); &#125; &#125; r1++; r2--; c1++; c2--; &#125; return arr; &#125;&#125; 顺时针逆时针都只需要改变while循环里的遍历顺序就行，问题关键是考虑边界问题和判断是否重复打印问题 第一个只出现一次的字符位置 1234567891011121314151617public class Solution &#123; public int FirstNotRepeatingChar(String str) &#123; //注意Java声明数组的方式。。。太久没用了 //所有的值都初始化为0 int[] arr=new int[128]; for(int i=0;i&lt;str.length();i++)&#123; //这里的字符被自动看作数字 arr[str.charAt(i)]+=1; &#125; for(int i=0;i&lt;str.length();i++)&#123; if(arr[str.charAt(i)]==1)&#123; return i; &#125; &#125; return -1; &#125;&#125; 用两个栈实现队列 12345678910111213141516171819202122232425import java.util.Stack;public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; //如果stack2是空的，就把stack1的全部倒到stack2再pop if(stack2.empty())&#123; while(!stack1.empty())&#123; int t=stack1.pop(); stack2.push(t); &#125; return stack2.pop(); &#125; //否则就直接从stack2里面pop else&#123; return stack2.pop(); &#125; &#125;&#125; 实现min函数的栈 1234567891011121314151617181920212223242526272829303132import java.util.Stack;public class Solution &#123;//注意声明Stack的方式private Stack&lt;Integer&gt; dataStack=new Stack&lt;&gt;();private Stack&lt;Integer&gt; minStack=new Stack&lt;&gt;(); //push操作会影响当前dataStack里的最小值，pop不会 public void push(int node) &#123; dataStack.push(node); //先判断minStack是否为空，是就可以push，不是的话需要判断node和minStack栈顶的值哪个小 //始终维持minStack栈顶为最小值 if(minStack.empty())&#123; minStack.push(node); &#125; else&#123; minStack.push(node&lt;minStack.peek()?node:minStack.peek()); &#125; &#125; public void pop() &#123; dataStack.pop(); minStack.pop(); &#125; public int top() &#123; return dataStack.peek(); &#125; public int min() &#123; return minStack.peek(); &#125;&#125;","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"http://ydl8686.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"StringBuffer","slug":"StringBuffer","permalink":"http://ydl8686.github.io/tags/StringBuffer/"},{"name":"Stack","slug":"Stack","permalink":"http://ydl8686.github.io/tags/Stack/"}]},{"title":"服务端#1","slug":"服务端-1","date":"2021-02-21T01:17:03.000Z","updated":"2021-04-23T02:24:52.651Z","comments":true,"path":"2021/02/21/服务端-1/","link":"","permalink":"http://ydl8686.github.io/2021/02/21/%E6%9C%8D%E5%8A%A1%E7%AB%AF-1/","excerpt":"","text":"基础概念JDBC：Java DataBase Connectivity，期望使用统一的Java代码来操作所有的关系型数据库（例如Mysql、Oracle） JDBC是由sun公司来定义的一套操作所有关系型数据库的规则（接口），每一个不同的数据库厂商来编写实现类，提供数据库驱动jar包。每一个实现类都实现了接口，我们就只需要使用接口就可以了，真正执行的代码是驱动jar包中的实现类 不同版本的JDBC实现类总称为数据库驱动 快速入门步骤 导入驱动jar包 mysql-connector-java-8.0.23.jar &nbsp;&nbsp;&nbsp;&nbsp;复制jar包到项目的libs目录下 &nbsp;&nbsp;&nbsp;&nbsp;右键libs来add as library 注册驱动（告诉系统用哪个版本的驱动jar包）（mysql5以后可以不用注册驱动） 获取数据库连接对象 Connection 定义sql 获取执行sql语句的对象 Statement（Connection不能直接执行） 执行sql，接收返回结果 处理结果 释放资源（否则可能会造成内存泄漏的问题） 1234567891011121314151617181920212223242526272829package cn.itcast.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.Statement;//JDBC快速入门public class JdbcDemo1 &#123; public static void main(String[] args) throws Exception&#123; //1.导入驱动jar包 //2.注册驱动// Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //3.获取数据库的连接对象 Connection Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/Hotel&quot;, &quot;root&quot;, &quot;ydl2000120368&quot;); //4.定义sql语句 String sql=&quot;update Room set total=600 where id=7&quot;; //5.获取执行sql的对象 Statement Statement stmt = conn.createStatement(); //6.执行sql int count=stmt.executeUpdate(sql); //7.处理结果 System.out.println(count); //8.释放资源 stmt.close(); conn.close(); &#125;&#125;//整体不是很规范，不能直接抛出异常，应该用try-catch-finally；//资源（Connection、Statement、ResultSet）释放得在finally里面 .class是字节码文件，.java是Java源码文件 代码中出现的各个对象DriverManager：驱动管理对象功能： 注册驱动 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;API：static void registerDriver(Driver driver)：注册与给定的驱动程序DriverManager &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写代码使用：Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过查看源码发现在com.mysql.cj.jdbc.Driver类中存在静态代码块来执行上面的API &nbsp;获取数据库连接 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static Connection getConnection(String url,String user,String password) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url：指定连接的路径，不同数据库写法不一样jdbc:mysql://ip地址:端口号/数据库名称 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果连接的是本机mysql服务器且端口为3306，则可以简写为jdbc:mysql:///数据库名称 Connection：数据库连接对象功能： 获取执行sql对象 ​ Statement createStatement() ​ PrepareStatement prepareStatement(String sql) 管理事务（事务：一个业务操作，有多个步骤） ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开启事务：void setAutoCommit(boolean autoCommit)调用该方法设置参数为false即开启事务 ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提交事务：void commit() ​ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回滚事务：void rollback() Statement：执行sql的对象功能：执行sql ​ int executeUpdate(String sql)：执行DML语句（增删改）、DDL语句（创建表、库），返回值：影响的行数 ​ ResultSet executeQuery(String sql)：执行DQL语句（查询） ResultSet：结果集对象，封装查询结果&nbsp;&nbsp;&nbsp;&nbsp;next()：游标（最开始指向表头，并不指向数据）向下移动一行，返回当前行是否是最后一行末尾（已经没有数据了），返回false代表没有数据，true则是有数据 &nbsp;&nbsp;&nbsp;&nbsp;getXxx(参数)：获取数据，Xxx代表数据类型；参数可以接受int代表列的编号（不是从0开始），也可以接受String代表列的名称 123456789//遍历//遍历结果集对象：//1.游标向下移动一行//2.判断是否有数据//3.获取数据while(rs.next())&#123; int price=rs.getInt(&quot;price&quot;); System.out.println(price);&#125; PreparedStatement：执行sql的对象SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接，会造成安全问题；可以通过PreparedStatement对象来解决 静态sql容易产生SQL注入问题，而采用预编译sql则不会，且预编译sql效率更高 预编译的sql中参数是用?作为占位符 123456789101112131415161718192021222324252627282930313233//使用预编译sql来实现登录查询操作 public boolean login(String username, String password)&#123; if(username==null || password==null)&#123; return false; &#125; Connection conn=null; PreparedStatement pstmt=null; ResultSet rs=null; try &#123; conn= JDBCUtils.getConnection(); //定义sql// 静态sql：// &quot;select * from user where username = &#x27;&quot; + username + &quot;&#x27; and password = &#x27;&quot; + password + &quot;&#x27;&quot;// 预编译sql：// &quot;select * from user where username = ? and password = ?&quot; String sql=&quot;select * from user where username=? and password=?&quot;; pstmt=conn.prepareStatement(sql); //一定要记得给PreparedStatement中的?赋值 //参数从1开始编号 pstmt.setString(1,username); pstmt.setString(2,password); rs = pstmt.executeQuery(); return rs.next(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; //PreparedStatement是Statement的子类，所以多态不会出错 JDBCUtils.close(rs,pstmt,conn); &#125; return false; &#125; insert 的时候如果某个key是主键，那么用null来占位就好了，不需要写具体的value","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"服务端开发","slug":"服务端开发","permalink":"http://ydl8686.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"JDBC","slug":"JDBC","permalink":"http://ydl8686.github.io/tags/JDBC/"}]},{"title":"算法#1","slug":"算法-1","date":"2021-02-20T15:06:01.000Z","updated":"2021-05-06T10:23:42.160Z","comments":true,"path":"2021/02/20/算法-1/","link":"","permalink":"http://ydl8686.github.io/2021/02/20/%E7%AE%97%E6%B3%95-1/","excerpt":"","text":"第一天打卡！ 数组中重复的数字 123456789101112131415161718192021222324252627282930313233//超出了时间限制的自己的做法public class Solution &#123; // Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation; // Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++ // 这里要特别注意~返回任意重复的一个，赋值duplication[0] // Return value: true if the input is valid, and there are some duplications in the array number // otherwise false public boolean duplicate(int numbers[],int length,int [] duplication) &#123; if(numbers==null)&#123; return false; &#125; for(int i=0;i&lt;length;i++)&#123; if(numbers[i]!=i &amp;&amp; numbers[numbers[i]]==numbers[i])&#123; duplication[0]=numbers[i]; return true; &#125; else if(numbers[i]!=i &amp;&amp; numbers[numbers[i]]!=numbers[i])&#123; int t; t=numbers[i]; numbers[i]=numbers[numbers[i]]; numbers[numbers[i]]=t; i--; &#125; else if(numbers[i]==i)&#123; &#125; &#125; return false; &#125;&#125; 1234567891011121314151617181920212223//答案做法public class Solution &#123; public boolean duplicate(int numbers[],int length,int [] duplication) &#123; if(numbers==null)&#123; return false; &#125; for(int i=0;i&lt;length;i++)&#123; while(numbers[i]!=i)&#123; if(numbers[i]==numbers[numbers[i]])&#123; duplication[0]=numbers[i]; return true; &#125; else&#123; int t; t=numbers[i]; numbers[i]=numbers[numbers[i]]; numbers[numbers[i]]=t; &#125; &#125; &#125; return false; &#125;&#125; 二维数组中的查找 12345678910111213141516171819202122//自己做法public class Solution &#123; public boolean Find(int target, int [][] array) &#123; //array.length和array[0].length int x=array.length; int y=array[0].length; int m=0; int n=y-1; while(m&lt;x &amp;&amp; n&gt;=0)&#123; if(array[m][n]&gt;target)&#123; n--; &#125; else if(array[m][n]&lt;target)&#123; m++; &#125; else&#123; return true; &#125; &#125; return false; &#125;&#125;","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","permalink":"http://ydl8686.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"git game#1","slug":"git-game-1","date":"2021-02-19T04:10:13.000Z","updated":"2021-04-22T16:40:10.054Z","comments":true,"path":"2021/02/19/git-game-1/","link":"","permalink":"http://ydl8686.github.io/2021/02/19/git-game-1/","excerpt":"","text":"可视化的git教程游戏 branchgit branch newImage可以创建一个叫做newImgae的分支，但是当前箭头指向的并不是这个分支，所以commit提交的是之前的main分支 git checkout newImage就可以将箭头指向newImage这个分支了，再commit就可以将修改保存到新的分支里 merge 决定将当前指向的分支和git merge后的分支合并 rebase也是一种合并分支的方法，实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去 rebase哪个分支，就相当于把哪个分支吞掉（我感觉 相对引用正常情况下，HEAD指向分支，分支指向提交记录，但是利用git checkout也可以使HEAD直接指向提交记录 上图中的C1就是提交记录，但是实际提交记录很长（可以通过git log来查看），可以只输入记录的前几个字符 或者使用相对引用 例如git checkout HEAD^ 移动分支用git branch，移动HEAD用git checkout 撤销变更 使用git reset这种“改写历史”的方法对远程分支是无效的，为了撤销更改并分享给别人，需要使用git revert","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"git","slug":"git","permalink":"http://ydl8686.github.io/tags/git/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-02-17T14:27:40.784Z","updated":"2021-02-18T02:17:29.865Z","comments":true,"path":"2021/02/17/hello-world/","link":"","permalink":"http://ydl8686.github.io/2021/02/17/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"随笔","slug":"随笔","permalink":"http://ydl8686.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}],"categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://ydl8686.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"前端","slug":"前端","permalink":"http://ydl8686.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"算法","slug":"算法","permalink":"http://ydl8686.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"递归","slug":"递归","permalink":"http://ydl8686.github.io/tags/%E9%80%92%E5%BD%92/"},{"name":"vue","slug":"vue","permalink":"http://ydl8686.github.io/tags/vue/"},{"name":"项目","slug":"项目","permalink":"http://ydl8686.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"git","slug":"git","permalink":"http://ydl8686.github.io/tags/git/"},{"name":"NJUSE","slug":"NJUSE","permalink":"http://ydl8686.github.io/tags/NJUSE/"},{"name":"电子商务","slug":"电子商务","permalink":"http://ydl8686.github.io/tags/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1/"},{"name":"数据库开发","slug":"数据库开发","permalink":"http://ydl8686.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91/"},{"name":"服务端开发","slug":"服务端开发","permalink":"http://ydl8686.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"面试","slug":"面试","permalink":"http://ydl8686.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"贪心","slug":"贪心","permalink":"http://ydl8686.github.io/tags/%E8%B4%AA%E5%BF%83/"},{"name":"数字数组排序","slug":"数字数组排序","permalink":"http://ydl8686.github.io/tags/%E6%95%B0%E5%AD%97%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/"},{"name":"js","slug":"js","permalink":"http://ydl8686.github.io/tags/js/"},{"name":"API","slug":"API","permalink":"http://ydl8686.github.io/tags/API/"},{"name":"实用技巧","slug":"实用技巧","permalink":"http://ydl8686.github.io/tags/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"Vue","slug":"Vue","permalink":"http://ydl8686.github.io/tags/Vue/"},{"name":"计网","slug":"计网","permalink":"http://ydl8686.github.io/tags/%E8%AE%A1%E7%BD%91/"},{"name":"Java","slug":"Java","permalink":"http://ydl8686.github.io/tags/Java/"},{"name":"maven","slug":"maven","permalink":"http://ydl8686.github.io/tags/maven/"},{"name":"链表","slug":"链表","permalink":"http://ydl8686.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"双指针","slug":"双指针","permalink":"http://ydl8686.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"栈","slug":"栈","permalink":"http://ydl8686.github.io/tags/%E6%A0%88/"},{"name":"优先级队列","slug":"优先级队列","permalink":"http://ydl8686.github.io/tags/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"},{"name":"最大堆、最小堆","slug":"最大堆、最小堆","permalink":"http://ydl8686.github.io/tags/%E6%9C%80%E5%A4%A7%E5%A0%86%E3%80%81%E6%9C%80%E5%B0%8F%E5%A0%86/"},{"name":"队列","slug":"队列","permalink":"http://ydl8686.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"JDBC","slug":"JDBC","permalink":"http://ydl8686.github.io/tags/JDBC/"},{"name":"随笔","slug":"随笔","permalink":"http://ydl8686.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"StringBuffer","slug":"StringBuffer","permalink":"http://ydl8686.github.io/tags/StringBuffer/"},{"name":"Stack","slug":"Stack","permalink":"http://ydl8686.github.io/tags/Stack/"}]}