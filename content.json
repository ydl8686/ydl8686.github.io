{"meta":{"title":"Ydl's Blog","subtitle":null,"description":"待葡萄成熟透","author":"Ydl","url":"http://ydl8686.github.io","root":"/"},"pages":[{"title":"About","date":"2023-02-18T01:46:09.145Z","updated":"2021-05-06T12:20:17.861Z","comments":true,"path":"about/index.html","permalink":"http://ydl8686.github.io/about/index.html","excerpt":"","text":""},{"title":"Project","date":"2023-02-18T01:46:09.192Z","updated":"2021-05-06T12:20:17.863Z","comments":true,"path":"project/index.html","permalink":"http://ydl8686.github.io/project/index.html","excerpt":"","text":""},{"title":"Tags","date":"2023-02-18T01:46:09.168Z","updated":"2021-05-06T12:20:17.865Z","comments":true,"path":"tags/index.html","permalink":"http://ydl8686.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","slug":"photos","date":"2023-02-18T01:46:09.212Z","updated":"2022-12-31T04:05:37.209Z","comments":false,"path":"photos/index.html","permalink":"http://ydl8686.github.io/photos/index.html","excerpt":"","text":"Photos 图片正在加载中… (function() { var loadScript = function(path) { var $script = document.createElement('script') document.getElementsByTagName('body')[0].appendChild($script) $script.setAttribute('src', path) } setTimeout(function() { loadScript('./ins.js') }, 0) })()"},{"title":"","date":"2023-02-18T01:46:09.272Z","updated":"2021-02-18T08:39:30.229Z","comments":true,"path":"photos/ins.css","permalink":"http://ydl8686.github.io/photos/ins.css","excerpt":"","text":"#post-instagram{ padding: 30px; } #post-instagram .article-entry{ padding-right: 0; } .instagram{ background-color:#F5FFFF; position: relative; min-height: 500px; } .instagram img { width: 100%; } .instagram .year { font-size: 16px; } .instagram .open-ins{ padding: 10px 0; color: #cdcdcd; } .instagram .open-ins:hover{ color: #657b83; } .instagram .year{ display: inline; } .instagram .thumb { width: 25%; height: 0; padding-bottom: 25%; position: relative; display: inline-block; text-align: center; background: #ededed; outline: 1px solid #ddd; } .instagram .thumb a { position: relative; } .instagram .album h1 em{ font-style: normal; font-size: 14px; margin-left: 10px; } .instagram .album ul{ display: flex; flex-wrap: wrap; clear: both; width: 100%; text-align: left; } .instagram .album li{ list-style: none; display: inline-block; box-sizing: border-box; padding: 0 5px; margin-bottom: -10px; height: 0; width: 25%; position: relative; padding-bottom: 25%; } .instagram .album li:before{ display: none; } .instagram .album div.img-box{ position: absolute; width: 90%; height: 90%; -webkit-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); -moz-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); } .instagram .album div.img-box img{ width: 100%; height: 100%; position: absolute; z-index: 2; } .instagram .album div.img-box .img-bg{ position: absolute; top: 0; left: 0; bottom: 0px; width: 100%; margin: -5px; padding: 5px; -webkit-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -moz-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -webkit-transition: all 0.15s ease-out 0.1s; -moz-transition: all 0.15s ease-out 0.1s; -o-transition: all 0.15s ease-out 0.1s; transition: all 0.15s ease-out 0.1s; opacity: 0.2; cursor: pointer; display: block; z-index: 3; } .instagram .album div.img-box .icon { font-size: 14px; position: absolute; left: 50%; top: 50%; margin-left: -7px; margin-top: -7px; color: #999; z-index: 1; } .instagram .album div.img-box .img-bg:hover{ opacity: 0; } .photos-btn-wrap { border-bottom: 1px solid #e5e5e5; margin-bottom: 20px; } .photos-btn { font-size: 16px; color: #333; margin-bottom: -4px; padding: 5px 8px 3px; } .photos-btn.active { color: #08c; border: 1px solid #e5e5e5; border-bottom: 5px solid #fff; } @media screen and (max-width:600px) { .instagram .thumb { width: 50%; padding-bottom: 50%; } .instagram .album li { width: 100%; position: relative; padding-bottom: 100%; text-align: center; } .instagram .album div.img-box{ margin: 0; width: 90%; height: 90%; } }"},{"title":"","date":"2023-02-18T01:46:09.220Z","updated":"2021-02-18T08:39:30.229Z","comments":true,"path":"photos/ins.js","permalink":"http://ydl8686.github.io/photos/ins.js","excerpt":"","text":"/******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports; /******/ /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ exports: {}, /******/ id: moduleId, /******/ loaded: false /******/ }; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.loaded = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = \"/dist/\"; /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(0); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(1); var _view = __webpack_require__(2); var _view2 = _interopRequireDefault(_view); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } /** * @name impush-client * @description 这个项目让我发家致富… * @date 2016-12-1 */ var _collection = []; var _count = 0; var searchData; function addMask(elem) { var rect = elem.getBoundingClientRect(); var style = getComputedStyle(elem, null); var mask = document.createElement('i'); mask.className = 'icon-film'; mask.style.color = '#fff'; mask.style.fontSize = '26px'; mask.style.position = 'absolute'; mask.style.right = '10px'; mask.style.bottom = '10px'; mask.style.zIndex = 1; elem.parentNode.appendChild(mask); } var createVideoIncon = function createVideoIncon() { var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]'); for (var i = 0, len = $videoImg.length; i < len; i++) { addMask($videoImg[i]); } }; var render = function render(res) { var ulTmpl = \"\"; for (var j = 0, len2 = res.list.length; j < len2; j++) { var data = res.list[j].arr; var liTmpl = \"\"; for (var i = 0, len = data.link.length; i < len; i++) { var minSrc = 'https://raw.githubusercontent.com/ydl8686/Blog-Back-Up/master/min_photos/' + data.link[i]; var src = 'https://raw.githubusercontent.com/ydl8686/Blog-Back-Up/master/photos/' + data.link[i]; var type = data.type[i]; var target = src + (type === 'video' ? '.mp4' : '.jpg'); src += ''; liTmpl += '\\ \\ \\ \\ ' + data.text[i] + '\\ '; } ulTmpl = ulTmpl + '' + data.year + '年' + data.month + '月\\ ' + liTmpl + '\\ '; } document.querySelector('.instagram').innerHTML = '' + ulTmpl + ''; createVideoIncon(); _view2.default.init(); }; var replacer = function replacer(str) { var arr = str.split(\"/\"); return \"/assets/ins/\" + arr[arr.length - 1]; }; var ctrler = function ctrler(data) { var imgObj = {}; for (var i = 0, len = data.length; i < len; i++) { var y = data[i].y; var m = data[i].m; var src = replacer(data[i].src); var text = data[i].text; var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m); if (imgObj[key]) { imgObj[key].srclist.push(src); imgObj[key].text.push(text); } else { imgObj[key] = { year: y, month: m, srclist: [src], text: [text] }; } } render(imgObj); }; function loadData(success) { if (!searchData) { var xhr = new XMLHttpRequest(); xhr.open('GET', './data.json?t=' + +new Date(), true); xhr.onload = function() { if (this.status >= 200 && this.status < 300) { var res = JSON.parse(this.response); searchData = res; success(searchData); } else { console.error(this.statusText); } }; xhr.onerror = function() { console.error(this.statusText); }; xhr.send(); } else { success(searchData); } } var Ins = { init: function init() { loadData(function(data) { render(data); }); } }; Ins.init(); // export default impush; /***/ }, /* 1 */ /***/ function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */ (function(global) { 'use strict'; var inViewport = __webpack_require__(3); var lazyAttrs = ['data-src']; global.lzld = lazyload(); // Provide libs using getAttribute early to get the good src // and not the fake data-src replaceGetAttribute('Image'); replaceGetAttribute('IFrame'); function registerLazyAttr(attr) { if (indexOf.call(lazyAttrs, attr) === -1) { lazyAttrs.push(attr); } } function lazyload(opts) { opts = merge({ 'offset': 333, 'src': 'data-src', 'container': false }, opts || {}); if (typeof opts.src === 'string') { registerLazyAttr(opts.src); } var elts = []; function show(elt) { var src = findRealSrc(elt); if (src) { elt.src = src; } elt.setAttribute('data-lzled', true); elts[indexOf.call(elts, elt)] = null; } function findRealSrc(elt) { if (typeof opts.src === 'function') { return opts.src(elt); } return elt.getAttribute(opts.src); } function register(elt) { elt.onload = null; elt.removeAttribute('onload'); elt.onerror = null; elt.removeAttribute('onerror'); if (indexOf.call(elts, elt) === -1) { inViewport(elt, opts, show); } } return register; } function replaceGetAttribute(elementName) { var fullname = 'HTML' + elementName + 'Element'; if (fullname in global === false) { return; } var original = global[fullname].prototype.getAttribute; global[fullname].prototype.getAttribute = function(name) { if (name === 'src') { var realSrc; for (var i = 0, max = lazyAttrs.length; i < max; i++) { realSrc = original.call(this, lazyAttrs[i]); if (realSrc) { break; } } return realSrc || original.call(this, name); } // our own lazyloader will go through theses lines // because we use getAttribute(opts.src) return original.call(this, name); }; } function merge(defaults, opts) { for (var name in defaults) { if (opts[name] === undefined) { opts[name] = defaults[name]; } } return opts; } // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html function indexOf(value) { for (var i = this.length; i-- && this[i] !== value;) {} return i; } module.exports = lazyload; // export default impush; /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ }, /* 2 */ /***/ function(module, exports) { 'use strict'; var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) { // parse slide data (url, title, size ...) from DOM elements // (children of gallerySelector) var parseThumbnailElements = function parseThumbnailElements(el) { el = el.parentNode.parentNode; var thumbElements = el.getElementsByClassName('thumb'), numNodes = thumbElements.length, items = [], figureEl, linkEl, size, type, // video or not target, item; for (var i = 0; i < numNodes; i++) { figureEl = thumbElements[i]; // // include only element nodes if (figureEl.nodeType !== 1) { continue; } linkEl = figureEl.children[0]; // size = linkEl.getAttribute('data-size').split('x'); type = linkEl.getAttribute('data-type'); target = linkEl.getAttribute('data-target'); // create slide object item = { src: linkEl.getAttribute('href'), w: parseInt(size[0], 10), h: parseInt(size[1], 10) }; if (figureEl.children.length > 1) { item.title = figureEl.children[1].innerHTML; } if (linkEl.children.length > 0) { item.msrc = linkEl.children[0].getAttribute('src'); item.type = type; item.target = target; item.html = ''; if (type === 'video') { //item.src = null; } } item.el = figureEl; // save link to element for getThumbBoundsFn items.push(item); } return items; }; // find nearest parent element var closest = function closest(el, fn) { return el && (fn(el) ? el : closest(el.parentNode, fn)); }; // triggers when user clicks on thumbnail var onThumbnailsClick = function onThumbnailsClick(e) { e = e || window.event; e.preventDefault ? e.preventDefault() : e.returnValue = false; var eTarget = e.target || e.srcElement; // find root element of slide var clickedListItem = closest(eTarget, function(el) { return el.tagName && el.tagName.toUpperCase() === 'FIGURE'; }); if (!clickedListItem) { return; } // find index of clicked item by looping through all child nodes // alternatively, you may define index via data- attribute var clickedGallery = clickedListItem.parentNode, // childNodes = clickedListItem.parentNode.childNodes, // numChildNodes = childNodes.length, childNodes = document.getElementsByClassName('thumb'), numChildNodes = childNodes.length, nodeIndex = 0, index; for (var i = 0; i < numChildNodes; i++) { if (childNodes[i].nodeType !== 1) { continue; } if (childNodes[i] === clickedListItem) { index = nodeIndex; break; } nodeIndex++; } if (index >= 0) { // open PhotoSwipe if valid index found openPhotoSwipe(index, clickedGallery); } return false; }; // parse picture index and gallery index from URL (#&pid=1&gid=2) var photoswipeParseHash = function photoswipeParseHash() { var hash = window.location.hash.substring(1), params = {}; if (hash.length < 5) { return params; } var vars = hash.split('&'); for (var i = 0; i < vars.length; i++) { if (!vars[i]) { continue; } var pair = vars[i].split('='); if (pair.length < 2) { continue; } params[pair[0]] = pair[1]; } if (params.gid) { params.gid = parseInt(params.gid, 10); } return params; }; var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) { var pswpElement = document.querySelectorAll('.pswp')[0], gallery, options, items; items = parseThumbnailElements(galleryElement); // define options (if needed) options = { // define gallery index (for URL) galleryUID: galleryElement.getAttribute('data-pswp-uid'), getThumbBoundsFn: function getThumbBoundsFn(index) { // See Options -> getThumbBoundsFn section of documentation for more info var thumbnail = items[index].el.getElementsByTagName('img')[0], // find thumbnail pageYScroll = window.pageYOffset || document.documentElement.scrollTop, rect = thumbnail.getBoundingClientRect(); return { x: rect.left, y: rect.top + pageYScroll, w: rect.width }; } }; // PhotoSwipe opened from URL if (fromURL) { if (options.galleryPIDs) { // parse real index when custom PIDs are used // http://photoswipe.com/documentation/faq.html#custom-pid-in-url for (var j = 0; j < items.length; j++) { if (items[j].pid == index) { options.index = j; break; } } } else { // in URL indexes start from 1 options.index = parseInt(index, 10) - 1; } } else { options.index = parseInt(index, 10); } // exit if index not found if (isNaN(options.index)) { return; } if (disableAnimation) { options.showAnimationDuration = 0; } // Pass data to PhotoSwipe and initialize it gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options); gallery.init(); var $tempVideo; var stopVideoHandle = function stopVideoHandle() { if ($tempVideo) { $tempVideo.remove(); $tempVideo = null; } }; var changeHandle = function changeHandle() { var item = gallery.currItem; stopVideoHandle(); if (item.type === 'video') { var $ctn = item.container; var style = $ctn.getElementsByClassName('pswp__img')[0].style; var $video = document.createElement('video'); $video.setAttribute('autoplay', 'autoplay'); $video.setAttribute('controls', 'controls'); $video.setAttribute('src', item.target); $video.style.width = style.width; $video.style.height = style.height; $video.style.position = 'absolute'; $video.style.zIndex = 2; $tempVideo = $video; $ctn.appendChild($video); } }; gallery.listen('initialZoomIn', changeHandle); gallery.listen('afterChange', changeHandle); gallery.listen('initialZoomOut', stopVideoHandle); }; // loop through all gallery elements and bind events var galleryElements = document.querySelectorAll(gallerySelector); for (var i = 0, l = galleryElements.length; i < l; i++) { galleryElements[i].setAttribute('data-pswp-uid', i + 1); galleryElements[i].onclick = onThumbnailsClick; } // Parse URL and open gallery if it contains #&pid=3&gid=1 var hashData = photoswipeParseHash(); if (hashData.pid && hashData.gid) { openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true); } }; var Viewer = function() { function init() { initPhotoSwipeFromDOM('.photos'); } return { init: init }; }(); module.exports = Viewer; /***/ }, /* 3 */ /***/ function(module, exports) { /* WEBPACK VAR INJECTION */ (function(global) { module.exports = inViewport; var instances = []; var supportsMutationObserver = typeof global.MutationObserver === 'function'; function inViewport(elt, params, cb) { var opts = { container: global.document.body, offset: 0 }; if (params === undefined || typeof params === 'function') { cb = params; params = {}; } var container = opts.container = params.container || opts.container; var offset = opts.offset = params.offset || opts.offset; for (var i = 0; i < instances.length; i++) { if (instances[i].container === container) { return instances[i].isInViewport(elt, offset, cb); } } return instances[ instances.push(createInViewport(container)) - 1 ].isInViewport(elt, offset, cb); } function addEvent(el, type, fn) { if (el.attachEvent) { el.attachEvent('on' + type, fn); } else { el.addEventListener(type, fn, false); } } function debounce(func, wait, immediate) { var timeout; return function() { var context = this, args = arguments; var callNow = immediate && !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); function later() { timeout = null; if (!immediate) func.apply(context, args); } }; } // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708 var contains = function() { if (!global.document) { return true; } return global.document.documentElement.compareDocumentPosition ? function(a, b) { return !!(a.compareDocumentPosition(b) & 16); } : global.document.documentElement.contains ? function(a, b) { return a !== b && (a.contains ? a.contains(b) : false); } : function(a, b) { while (b = b.parentNode) { if (b === a) { return true; } } return false; }; } function createInViewport(container) { var watches = createWatches(); var scrollContainer = container === global.document.body ? global : container; var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15); addEvent(scrollContainer, 'scroll', debouncedCheck); if (scrollContainer === global) { addEvent(global, 'resize', debouncedCheck); } if (supportsMutationObserver) { observeDOM(watches, container, debouncedCheck); } // failsafe check, every 200ms we check for visible images // usecase: a hidden parent containing eleements // when the parent becomes visible, we have no event that the children // became visible setInterval(debouncedCheck, 150); function isInViewport(elt, offset, cb) { if (!cb) { return isVisible(elt, offset); } var remote = createRemote(elt, offset, cb); remote.watch(); return remote; } function createRemote(elt, offset, cb) { function watch() { watches.add(elt, offset, cb); } function dispose() { watches.remove(elt); } return { watch: watch, dispose: dispose }; } function watchInViewport(elt, offset, cb) { if (isVisible(elt, offset)) { watches.remove(elt); cb(elt); } } function isVisible(elt, offset) { if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) { return false; } // Check if the element is visible // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js if (!elt.offsetWidth || !elt.offsetHeight) { return false; } var eltRect = elt.getBoundingClientRect(); var viewport = {}; if (container === global.document.body) { viewport = { top: -offset, left: -offset, right: global.document.documentElement.clientWidth + offset, bottom: global.document.documentElement.clientHeight + offset }; } else { var containerRect = container.getBoundingClientRect(); viewport = { top: containerRect.top - offset, left: containerRect.left - offset, right: containerRect.right + offset, bottom: containerRect.bottom + offset }; } // The element must overlap with the visible part of the viewport var visible = ( (eltRect.right > viewport.left) && (eltRect.left < viewport.right) && (eltRect.bottom > viewport.top) && (eltRect.top < viewport.bottom) ); return visible; } return { container: container, isInViewport: isInViewport }; } function createWatches() { var watches = []; function add(elt, offset, cb) { if (!isWatched(elt)) { watches.push([elt, offset, cb]); } } function remove(elt) { var pos = indexOf(elt); if (pos !== -1) { watches.splice(pos, 1); } } function indexOf(elt) { for (var i = watches.length - 1; i >= 0; i--) { if (watches[i][0] === elt) { return i; } } return -1; } function isWatched(elt) { return indexOf(elt) !== -1; } function checkAll(cb) { return function() { for (var i = watches.length - 1; i >= 0; i--) { cb.apply(this, watches[i]); } }; } return { add: add, remove: remove, isWatched: isWatched, checkAll: checkAll }; } function observeDOM(watches, container, cb) { var observer = new MutationObserver(watch); var filter = Array.prototype.filter; var concat = Array.prototype.concat; observer.observe(container, { childList: true, subtree: true, // changes like style/width/height/display will be catched attributes: true }); function watch(mutations) { // some new DOM nodes where previously watched // we should check their positions if (mutations.some(knownNodes) === true) { setTimeout(cb, 0); } } function knownNodes(mutation) { var nodes = concat.call([], Array.prototype.slice.call(mutation.addedNodes), mutation.target ); return filter.call(nodes, watches.isWatched).length > 0; } } /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ } /******/ ]);"},{"title":"","date":"2023-02-18T01:46:09.207Z","updated":"2021-02-18T08:39:30.230Z","comments":true,"path":"photos/lazyload.min.js","permalink":"http://ydl8686.github.io/photos/lazyload.min.js","excerpt":"","text":"/*! * An jQuery | zepto plugin for lazy loading images. * author -> jieyou * see https://github.com/jieyou/lazyload * use some tuupola's code https://github.com/tuupola/jquery_lazyload (BSD) * use component's throttle https://github.com/component/throttle (MIT) */ !function(a){\"function\"==typeof define&&define.amd?define([\"jquery\"],a):a(window.jQuery||window.Zepto)}(function(a){function g(){}function h(a,b){var e;return e=b._$container==d?(\"innerHeight\"in c?c.innerHeight:d.height())+d.scrollTop():b._$container.offset().top+b._$container.height(),e=b.offset().left+e.threshold+b.width()}function l(a,b){var c=0;a.each(function(d){function g(){f.trigger(\"_lazyload_appear\"),c=0}var f=a.eq(d);if(!(f.width()b.failure_limit)return!1}else g()})}function m(a){return a.filter(function(b){return!a.eq(b)._lazyload_loadStarted})}function n(a,b){function h(){f=0,g=+new Date,e=a.apply(c,d),c=null,d=null}var c,d,e,f,g=0;return function(){c=this,d=arguments;var a=new Date-g;return f||(a>=b?h():f=setTimeout(h,b-a)),e}}var f,c=window,d=a(c),e={threshold:0,failure_limit:0,event:\"scroll\",effect:\"show\",effect_params:null,container:c,data_attribute:\"original\",data_srcset_attribute:\"original-srcset\",skip_invisible:!0,appear:g,load:g,vertical_only:!1,check_appear_throttle_time:300,url_rewriter_fn:g,no_fake_img_loader:!1,placeholder_data_img:\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\",placeholder_real_img:\"http://ditu.baidu.cn/yyfm/lazyload/0.0.1/img/placeholder.png\"};f=function(){var a=Object.prototype.toString;return function(b){return a.call(b).replace(\"[object \",\"\").replace(\"]\",\"\")}}(),a.fn.hasOwnProperty(\"lazyload\")||(a.fn.lazyload=function(b){var i,j,k,h=this;return a.isPlainObject(b)||(b={}),a.each(e,function(g,h){var i=f(b[g]);-1!=a.inArray(g,[\"threshold\",\"failure_limit\",\"check_appear_throttle_time\"])?\"String\"==i?b[g]=parseInt(b[g],10):\"Number\"!=i&&(b[g]=h):\"container\"==g?(b._$container=b.hasOwnProperty(g)?b[g]==c||b[g]==document?d:a(b[g]):d,delete b.container):!e.hasOwnProperty(g)||b.hasOwnProperty(g)&&i==f(e[g])||(b[g]=h)}),i=\"scroll\"==b.event,k=0==b.check_appear_throttle_time?l:n(l,b.check_appear_throttle_time),j=i||\"scrollstart\"==b.event||\"scrollstop\"==b.event,h.each(function(c){var e=this,f=h.eq(c),i=f.attr(\"src\"),k=f.attr(\"data-\"+b.data_attribute),l=b.url_rewriter_fn==g?k:b.url_rewriter_fn.call(e,f,k),n=f.attr(\"data-\"+b.data_srcset_attribute),o=f.is(\"img\");return 1==f._lazyload_loadStarted||i==l?(f._lazyload_loadStarted=!0,h=m(h),void 0):(f._lazyload_loadStarted=!1,o&&!i&&f.one(\"error\",function(){f.attr(\"src\",b.placeholder_real_img)}).attr(\"src\",b.placeholder_data_img),f.one(\"_lazyload_appear\",function(){function i(){d&&f.hide(),o?(n&&f.attr(\"srcset\",n),l&&f.attr(\"src\",l)):f.css(\"background-image\",'url(\"'+l+'\")'),d&&f[b.effect].apply(f,c?b.effect_params:[]),h=m(h)}var d,c=a.isArray(b.effect_params);f._lazyload_loadStarted||(d=\"show\"!=b.effect&&a.fn[b.effect]&&(!b.effect_params||c&&0==b.effect_params.length),b.appear!=g&&b.appear.call(e,f,h.length,b),f._lazyload_loadStarted=!0,b.no_fake_img_loader||n?(b.load!=g&&f.one(\"load\",function(){b.load.call(e,f,h.length,b)}),i()):a(\"\").one(\"load\",function(){i(),b.load!=g&&b.load.call(e,f,h.length,b)}).attr(\"src\",l))}),j||f.on(b.event,function(){f._lazyload_loadStarted||f.trigger(\"_lazyload_appear\")}),void 0)}),j&&b._$container.on(b.event,function(){k(h,b)}),d.on(\"resize load\",function(){k(h,b)}),a(function(){k(h,b)}),this})});"},{"title":"","date":"2023-02-18T01:46:09.266Z","updated":"2021-02-18T08:39:30.230Z","comments":true,"path":"photos/package.json","permalink":"http://ydl8686.github.io/photos/package.json","excerpt":"","text":"{\"name\":\"hexo-site\",\"version\":\"0.0.0\",\"private\":true,\"hexo\":{\"version\":\"3.2.2\"},\"dependencies\":{\"hexo\":\"^3.1.0\",\"hexo-deployer-git\":\"0.0.4\",\"hexo-deployer-rsync\":\"^0.1.2\",\"hexo-generator-archive\":\"^0.1.3\",\"hexo-generator-baidu-sitemap\":\"^0.1.2\",\"hexo-generator-category\":\"^0.1.3\",\"hexo-generator-feed\":\"^1.2.0\",\"hexo-generator-index\":\"^0.1.3\",\"hexo-generator-json-content\":\"^3.0.1\",\"hexo-generator-json-feed\":\"^1.0.0\",\"hexo-generator-sitemap\":\"^1.1.2\",\"hexo-generator-tag\":\"^0.1.2\",\"hexo-helper-qrcode\":\"^1.0.1\",\"hexo-renderer-ejs\":\"^0.1.0\",\"hexo-renderer-marked\":\"^0.2.5\",\"hexo-renderer-stylus\":\"^0.2.3\",\"hexo-server\":\"^0.1.2\"}}"},{"title":"","date":"2023-02-18T01:46:09.250Z","updated":"2021-02-18T11:22:01.123Z","comments":true,"path":"photos/data.json","permalink":"http://ydl8686.github.io/photos/data.json","excerpt":"","text":"{\"list\":[{\"date\":\"2021-2-\",\"arr\":{\"year\":2021,\"month\":2,\"link\":[\"2021-2-17_狼小魂大大.JPG\",\"2021-2-18_最近真的很爱浩浩和介叔啊.JPG\",\"2021-2-18_要吃冰淇淋么.JPG\"],\"text\":[\"狼小魂大大\",\"最近真的很爱浩浩和介叔啊\",\"要吃冰淇淋么\"],\"type\":[\"image\",\"image\",\"image\"]}}]}"},{"title":"","date":"2023-02-18T01:46:09.255Z","updated":"2021-02-18T11:21:06.931Z","comments":true,"path":"photos/README.html","permalink":"http://ydl8686.github.io/photos/README.html","excerpt":"","text":"Blog-Back-Up存储博客照片"}],"posts":[{"title":"面试 | webpack","slug":"面试-webpack","date":"2023-03-22T13:24:10.000Z","updated":"2023-03-22T15:42:51.243Z","comments":true,"path":"posts/27789/","link":"","permalink":"http://ydl8686.github.io/posts/27789/","excerpt":"","text":"webpack理解webpack是一个静态的打包工具，可以用来管理项目依赖，其中打包可以解决浏览器频繁请求的问题，loader作为翻译官可以提高开发效率（sass）、解决浏览器兼容问题（es6），plugin则扩展了webpack的功能 常见的loadersass-loader：将scss/sass转换成css image-loader：加载并且压缩图片文件 babel-loader：把es6转成es5 eslint-loader：通过eslint检查js代码 vue-loader：加载vue单文件组件 cache-loader：将结果缓存到磁盘里 常见的pluginvuex-persistedstate：解决刷新浏览器vuex数据丢失问题 clean-webpack-plugin：每次打包自动删除原来打包生成的包文件夹 babel-plugin-transform-remove-console：生产环境去掉console hot-module-replacement-plugin：模块热替换 loader和plugin的区别loader是一个函数，对参数进行转换，返回转换后的结果，相当于翻译官 plugin是插件，用来扩展webpack的功能，webpack运行时会广播出很多事件，plugin监听这些事件并通过webpack提供的API改变输出结果 loader不需要引入，plugin需要；前者在rules中配置，后者在plugins数组中配置 loader在webpack读取模块内容，生成AST语法树之前进行；plugin在整个打包过程中进行 webpack运行流程初始化流程：从配置文件和Shell语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数 编译构建流程：从Entry发出，针对每个Module串行调用对应的Loader去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理 输出流程：对编译后的Module组合成Chunk，把Chunk转换成文件，输出到文件系统 webpack proxy工作原理，为什么能解决跨域原理实质上是利用http-proxy-middleware 这个http代理中间件，实现请求转发给其他服务器 webpack-dev-server是webpack官方的一个开发工具，会启动一个本地服务器（只适用在开发过程中），通过设置webpack proxy实现代理请求后，相当于浏览器与服务端中添加一个代理者 当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地 本地浏览器和代理服务器是同源的，服务器与服务器之间不存在跨域问题，所以能解决跨域 使用webpack来优化前端性能js代码压缩terser-webpack-plugin：让bundle更小 css代码压缩css-minimizer-webpack-plugin：去除无用的空格 文件大小压缩compression-webpack-plugin：压缩文件 图片压缩使用image-webpack-loader来对不同图片进行压缩 tree shaking消除死代码 js 设置usedExports为true，没被用上的代码在打包时会加入unused harmony export mul注释，用来告知 terser-webpack-plugin在优化时，可以删掉这段代码 css 使用purgecss-plugin-webpack删掉没用到的css样式 代码分离默认情况下，所有的JavaScript代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度 splitChunksPlugin代码分离可以分成更小的bundle，控制资源加载优先级，提高代码的加载性能 提高webpack构建速度优化loader配置匹配文件类型的时候，注意提升正则表达式的性能（如果项目源码只有js文件，正则就不要写的很复杂） 配置include/exclude，规定哪些目录下的文件使用loader处理 优化resolve.modules和alias使用绝对路径和别名来减少查找过程 使用DLLPlugin插件对于依赖的第三方库，比如vue，vuex等这些不会修改的依赖，可以和自己编写的代码分开打包，好处是每次更改我本地代码的文件时，只需要重新打包我项目本身的文件代码，而不会再去编译第三方库 以后只要我们不升级第三方包，那么webpack就不会对这些库再次打包，从而提高打包的速度 使用cache-loader在一些性能开销较大的 loader之前添加 cache-loader，将结果缓存到磁盘里，提升二次构建速度 启动多线程使用terser-plugin多进程并行运行提高构建速度 webpack和vite webpack先打包再启动开发服务器；vite是直接启动开发服务器，不需要分析模块的依赖、不需要编译，因此启动速度非常快 在热更新时，webpack会将改变的模块的所有依赖重新编译，而vite则是让浏览器去重新请求该模块即可 vite使用的是ES Module，代码中不可以使用CommonJs sourceMap是什么是一项将打包压缩后的代码映射回源代码的技术，前者没有阅读性可言，开发中出现问题很难debug sourceMap可以帮助快速定位到源代码的位置，提高开发效率","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://ydl8686.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"面试 | 项目经历","slug":"面试-项目经历","date":"2023-03-21T15:33:18.000Z","updated":"2023-03-22T05:00:46.630Z","comments":true,"path":"posts/37306/","link":"","permalink":"http://ydl8686.github.io/posts/37306/","excerpt":"","text":"性能优化滑动列表渲染白屏问题webpack分包 兼容","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://ydl8686.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"面试 | 计算机网络","slug":"面试-计算机网络","date":"2023-03-21T13:27:42.000Z","updated":"2023-03-21T15:32:50.217Z","comments":true,"path":"posts/12148/","link":"","permalink":"http://ydl8686.github.io/posts/12148/","excerpt":"","text":"1. GET和POST请求的区别应用场景：GET请求是幂等请求，对服务器的资源不会产生影响；而POST请求一般会对服务器资源进行变更 请求长度：由于浏览器限制了url长度，所以get请求发送数据时的长度也会受到限制；POST请求则不会受到限制 2. 常见http请求头和响应头常见的请求头 Accept：浏览器能够处理的内容类型 Accept-Charset：浏览器能够显示的字符集 Accept-Encoding：浏览器能够处理的压缩编码 Accept-Language：浏览器当前设置的语言 Connection：浏览器与服务器之间连接的类型 Cookie：当前页面设置的任何Cookie Host：发出请求的页面所在的域 Referer：发出请求的页面的URL User-Agent：浏览器的用户代理字符串 常见的响应头 Date：表示消息发送的时间 server：服务器名称 Connection：浏览器与服务器之间连接的类型 Cache-Control：控制HTTP缓存 content-type：表示后面的文档属于什么MIME类型 （1）application/x-www-form-urlencoded：浏览器的原生 form 表单，数据放在 body 里面，数据 key1=val1&amp;key2=val2 的方式进行编码 （2）multipart/form-data：通常上传文件时使用该种方式 （3）application/json：消息主体是序列化后的 JSON 字符串 （4）text/xml：主要用来提交 XML 格式的数据 3. http状态码304是多好还是少好搜索引擎蜘蛛会通过一定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。如果网站一定时间内一直处于304的状态，那么会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么回访率也会提高。 304意味着使用缓存，网站的加载速度会更快；但是过多304会导致网站的快照停止 网页快照是指搜索引擎在收录网页时，对网页进行备份，存在自己的服务器缓存里，当用户在搜索引擎中点击“网页快照”链接时，搜索引擎再将Spider系统当时抓取并保存的网页内容展现出来 4. 常见的http请求方法 GET:：向服务器获取数据； POST：将实体提交到指定的资源，通常会造成服务器资源的修改； PUT：上传文件，更新数据； DELETE：删除服务器上的对象； HEAD：获取报文首部，与GET相比，不返回报文主体部分； OPTIONS：询问支持的请求方法，用来跨域请求； CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信； TRACE: 回显服务器收到的请求，主要⽤于测试或诊断。 5. options请求的使用场景 获取服务器支持的所有HTTP请求方法； 用来检查访问权限，例如在进行CORS跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限 6. HTTP各个版本区别HTTP1.0和HTTP 1.1的区别 连接方面，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。使用持久连接来使多个http请求复用同一个TCP连接 资源请求方面，在http1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了；并且不支持断点续传功能。http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，返回码是 206（Partial Content） 缓存方面，在http1.0中主要使用If-Modified-Since、Expires来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Modified-Since、If-None-Match http1.1 中新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。 http1.1 相对于 http1.0 还新增了很多请求方法，如 PUT、HEAD、OPTIONS 等。 HTTP1.1和HTTP 2.0的区别 二进制协议：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。 多路复用： HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”的问题。 数据流： HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。 头部压缩： HTTP/2 实现了头部压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送字段，只发送索引号，这样就能提高速度了。 服务器推送： HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源。 HTTP3使用UDP+QUIC的方式，其中QUIC整合了TCP以及TLS握手过程 解决队头阻塞：减少请求的次数（精灵图）；域名分片，因为一个域名的连接数是有限的，所以划分多个子域名来处理请求，http/2解决队头阻塞只是应用层表面，然而还是基于传输层TCP的，收不到还是会要等待重传造成阻塞 7. HTTP和HTTPS协议的区别 HTTP是明文传输，而HTTPS则会对传输的内容加密（HTTP劫持） HTTP是80端口，HTTPS是443端口 8. 在浏览器中输入baidu.com并回车后发生了什么（1）解析URL： 首先会对 URL 进行解析，如果输入的 URL 不合法，将会把输入的内容传递给搜索引擎。如果没有问题，检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。 （2）缓存判断： 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。 （3）DNS解析： 下一步是将域名转化成 IP 地址，首先判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。 （4）获取MAC地址： 当浏览器得到 IP 地址后，数据链路层的数据传输还需要知道目的主机 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求的主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。 （5）TCP三次握手： 首先客户端向服务器发送一个 SYN 连接请求报文段，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。 （6）HTTPS握手： 首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。 （7）返回数据： 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。 （8）页面渲染： 浏览器的GUI渲染线程首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，如果没有则会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制，这时整个页面就显示出来了。 （9）TCP四次挥手： 最后一步是 TCP 断开连接的四次挥手过程。如果客户端认为数据发送完成，那么向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据，不过服务端仍旧可以发送数据给客户端，还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://ydl8686.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"面试 | vue","slug":"面试-vue","date":"2023-03-21T07:09:32.000Z","updated":"2023-03-22T13:23:36.393Z","comments":true,"path":"posts/14980/","link":"","permalink":"http://ydl8686.github.io/posts/14980/","excerpt":"","text":"vue双向绑定vue的双向绑定是指数据和视图的修改会影响另外一方。 修改视图更新数据是通过addEventLisenter增加监听事件来实现的 修改数据更新视图是通过数据劫持和发布-订阅者模式实现的，vue2中通过Object.defineProperty方法来劫持各个属性，当触发对象属性的setter时，会通知订阅者触发相应的监听回调。主要流程如下 new Vue实例的时候会调用Observer和Compile，Observer来完成数据劫持（value丢失问题），Compile负责解析原先的dom，通过createDocumentFragment将要处理的dom放到临时内存里，统一处理后再append到vue挂载的dom上初始化视图 发布订阅者模式的实现和Dependency、Watcher两个类有关；Dependency维护了一个订阅者数组，以及两个方法：添加订阅者和通知数组内所有订阅者调用监听回调的方法。Watcher的构造函数则包含了监听的对象、监听的属性和属性发生修改的回调函数，对外暴露一个update方法给Dependency调用，内部再调用监听的回调函数 在Compile里会new Watcher ，不同的nodeType会有不同监听回调的Watcher，在Compile里告诉Watcher具体要的回调要怎么处理；new Watcher的时候会去访问对应的属性，为的是触发这个key的getter，在这个getter里将watcher加入到dependency的订阅数组里（为什么Dependency是在Observer里创建：确保当给key赋值一个对象类型的值时，这个值也有对应的Dependency）；setter则是负责调用dependency的notify computed和watch的区别computed是计算属性，他会根据其他属性的值计算结果，并且默认走缓存，只有当依赖的数据发生变化时才会重新计算。watch是监听器，负责监听数据，当监听的数据发生变化时就会触发相应的操作。 缓存方面，computed支持缓存，而watch不支持缓存 异步方面，computed中有异步操作时无法监听数据变化，而watch支持异步监听 v-if和v-show的区别实现上：v-if是动态的添加或者删除DOM元素，v-show则是通过设置元素的display样式属性控制显示隐藏 编译上：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，都会被编译生成DOM元素 性能上：v-if有更高的切换消耗，v-show有更高的初始渲染消耗 keep-alive的理解，如何实现，具体缓存的内容当一个组件在切换时需要保存状态防止多次渲染时，就可以使用keep-alive组件包裹 虚拟DOMVirtual Dom是一个JavaScript对象，包括tag、props、children属性，通过对象的方式来表示DOM结构，配合不同的渲染工具，使跨平台渲染成为可能，比如Node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟DOM 通过将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。当数据变化时，将现在的虚拟DOM会与缓存的虚拟DOM进行比较，vue内部封装了diff算法，通过这个算法来进行比较，渲染修改改变的变化，原先没有发生改变的则使用缓存。 无需手动操作DOM 首次渲染大量DOM时，由于多了一层虚拟DOM的计算，性能会稍差一些 虚拟DOM的解析过程首先对DOM树结构进行解析，使用js来模拟这个对象并保存下来，然后再把这个DOM插入到文档中 当页面发生变更，重新构建对象树，将新旧对象树进行diff比较，记录下差异patch对象，最后将ptach对象解析到真正的DOM树 具体来说，就是当数据发生变化时，通过劫持setter，让数据的Dependency去通知监听的Watcher，Watcher获取新的虚拟DOM执行patch，对比缓存的旧的虚拟DOM，如果sameVnode返回true，那么patchVnode进行后续对比子节点变化，如果vnode和oldVnode都有子节点并且子节点不一样，那么调用updateChildren更新子节点 diff算法原理diff中只对同层的子节点进行比较，放弃跨级的节点比较 首先，我们拿到新旧节点的数组，然后初始化四个指针，分别指向新旧节点的开始位置和结束位置，进行vNode的key的两两对比，相同则patchNode对比更新DOM 如果新的开始节点和旧开始节点相同，则都向后面移动，如果结尾节点相匹配，则都前移指针 如果新开始节点和旧结尾节点匹配上了，则会将旧的结束节点移动到旧的开始节点前 如果旧开始节点和新的结束节点相匹配，则会将旧开始节点移动到旧结束节点的后面 如果上述节点都没匹配上，则会进行一个兜底逻辑的判断，判断开始节点是否在旧节点中，若是存在则复用，若是不存在则在旧节点数组中创建 如果旧vnode先遍历完，就添加新vnode没有遍历的节点；如果新vnode先遍历完，就删除旧vnode没有遍历的节点 头对尾，尾对头的操作是因为可以通过reverse操作快速检测 vue3和vue2中diff的区别vue2是全量diff，vue3是静态标记+非全量diff vue3使用最长递增子序列优化了对比流程 key的作用在diff算法中更精确的找到相同节点，因此patch过程会非常高效 如果不使用key或者index作为key时，假设往列表中插入了一个新的元素，那么插入元素后面的元素的位置会发生变化，相比原来的虚拟DOM不再相同，所以全都会执行更新操作 vue-router如何实现懒加载箭头函数+importconst router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/list&#x27;, component: () =&gt; import(&#x27;@/components/list.vue&#x27;) &#125; ]&#125;) 箭头函数+requirecomponent: resolve =&gt; require([&#x27;@/components/list&#x27;], resolve) webpack的require.ensurecomponent: r =&gt; require.ensure([], () =&gt; r(require(&#x27;@/components/list&#x27;)), &#x27;list&#x27;) vue2和vue3的区别双向绑定使用的API不同；前者是Object.defineProperty，后者是Proxy object.defineProperty无法监听添加或删除对象的属性；本身也无法监听数组的push等方法，vue底层额外进行了处理，但是仍然无法监听到数组下标和长度的变化 Proxy直接代理整个对象而非对象的属性；可以监听数组的变化 vue2使用的是option API，vue3使用的是composition API diff算法不同；前者使用的是头尾节点对比，后者是最长递增子序列 生命周期钩子函数不同；前者是beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed；后者是setup、onBeforeMount、onMounted、onBeforeUpdate、onUpdated、onRenderTracked、onRenderTriggered","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://ydl8686.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"面试合集","slug":"面试合集","date":"2023-02-26T23:58:35.000Z","updated":"2023-03-21T15:10:58.561Z","comments":true,"path":"posts/57112/","link":"","permalink":"http://ydl8686.github.io/posts/57112/","excerpt":"","text":"UDP和TCP的区别、使用场景、优劣，如何让UDP更可靠区别 TCP面向连接，UDP是无连接的TCP在开始数据传输之前要经过三次握手，UDP却不需要任何准备即可进行数据传输，因此UDP不会引入建立连接的时延 TCP提供可靠的服务，UDP则是尽最大努力交付TCP传输数据具有重传机制，如果在传输数据的过程中发生丢包事件，发送方会重传丢失的数据以保证发送的数据一定能完整到达接收方，因此是可靠的。UDP在网络层不能保证数据传输的可靠性。（可以在应用层实现UDP数据传输的可靠性） UDP效率比TCP高UDP在传输数据前不需要建立连接，没有繁琐的握手过程，没有复杂的拥塞控制算法和重传机制，所以UDP相对于TCP具有较高的效率。 每一条TCP连接只能是点到点，UDP支持一对一、一对多、多对多 TCP对系统资源要求较多，UDP对系统资源要求较少TCP建立连接后，会为连接分配发送缓存和接受缓存，维护拥塞控制变量以及序号和确认号的参数，因此需要占用较多的系统资源。而UDP是无连接的，对系统资源要求较少 使用场景TCP：对网络通讯质量有要求时，例如整个数据要准确无误的传递给对方 FTP：文件传输协议 SSH：安全登录 Telnet：不安全文本传送 SMTP：简单邮件传输协议 HTTP：超文本传输协议 UDP：对网络通讯质量要求不高时，要求网络通讯速度能尽量的快 流媒体 如果采用TCP，一旦发生丢包，TCP会将后续包缓存起来，等前面的包重传并接收到后再继续发送（重传的数据会占用窗口大小），延迟会越来越大 实时游戏 自定义重传策略能把丢包产生的延迟降到最低 物联网 各自优缺点TCP优点：可靠、稳定 TCP缺点：慢、效率低、占用系统资源高、易被攻击（SYN Flood攻击） SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪 UDP优点：快、稍安全 UDP缺点：不可靠、不稳定 如何让UDP更可靠在上层应用层模仿TCP的可靠性传输 添加seq/ack机制，确保数据发送到对端 添加超时重传机制 闭包 上级作用域指的是创建时的上级而不是调用的上级，与this指针不同 定义闭包是指能够访问另一个函数内部变量的函数，创建闭包最常见的方式就是将函数作为返回值 有时候需要得到函数内的局部变量。但是，正常情况下这是办不到的，只有通过变通方法才能实现，闭包就是这种方法 实际应用获取多个元素并添加点击事件 for (var j = 0; j &lt; op.length; j++) &#123; (function(j) &#123; op[j].onclick = function() &#123; alert(j); &#125;; &#125;)(j);&#125; 作用 保护函数的私有变量不受外部的干扰（立即执行函数）。形成不销毁的栈内存。 保存，把一些函数内的值保存下来。闭包可以实现方法和属性的私有化 缺点被引用的内部变量不能被销毁，增大了内存消耗，使用不当易造成内存泄露 Vue响应式原理Vue是基于Object.defineProperty来实现数据响应的，通过Object.defineProperty的 getter/setter 对收集的依赖项进行监听,在属性被访问和修改时通知变化,进而更新视图数据 受现代JavaScript 的限制 (以及废弃Object.observe)，Vue2不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行getter/setter 转化过程，所以属性必须在 data 对象上存在才能让Vue转换它，这样才能让它是响应的。 https加密过程 websocketWebSocket是一种在单个TCP连接上进行全双工通信的协议，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，允许服务端主动向客户端推送数据 在 WebSocket出现以前，使用HTTP创建一个和服务端进双通道通信的 web 应用，需要进行不停的轮询，这会导致一些问题： 服务端被迫维持来自每个客户端的大量不同的连接 大量的轮询请求会造成高开销，比如会带上多余重复的header，造成了无用的数据传输。 虽然HTTP/2也具备服务器推送功能，但HTTP/2只能推送静态资源，无法推送指定的信息 websocket和http是有一定交叉关系的，在最开始握手的时候是采用http来进行协议切换的，101状态码表示切换成功 特点没有同源限制，客户端可以与任意服务器通信； 与 HTTP 协议有着良好的兼容性，默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器； 建立连接需要握手（HTTP就不需要） 在线离线问题–时间戳当客户端第一次发送请求至服务端时会携带唯一标识、以及时间戳，服务端到db或者缓存去查询该请求的唯一标识，如果不存在就存入db或者缓存中， 第二次客户端定时再次发送请求依旧携带唯一标识、以及时间戳，服务端到db或者缓存去查询该请求的唯一标识，如果存在就把上次的时间戳拿取出来，使用当前时间戳减去上次的时间，得出的毫秒秒数判断是否大于指定的时间，若小于的话就是在线，否则就是离线； 断线问题–心跳检测 客户端每隔一段时间发一个探测包给服务器，并启动一个超时定时器 服务器端接收到检测包，应该回应一个包给客户端 如果客户机收到服务器的应答包，则说明服务器正常，删除超时定时器 如果客户端的超时定时器超时，依然没有收到应答包，则说明服务器挂了 数据类型基本数据类型null：typeof null为object，表示没有任何对象，例如原型链的末端Object.prototype.__proto__ undefined：表示没有任何值，例如声明但是没有初始化的变量、不存在的对象属性 这俩都没有对象包装器，所以就是一个值 boolean number：+0===-0 //true，但是除的时候会分别得到+Infinity和-Infinity；NaN是唯一不等于自身的值； string：字符串长度是指其中UTF-16代码单元的数量，可能与Unicode字符的实际数量不同；不可变 bigint：表示任意大小的整数 symbol：独一无二的值，哪怕创建时的传参是一样的，symbol值也不一样；可以用来定义常量消除魔法字符、作为对象属性（不过for in来遍历对象属性时不会输出symbol值作为的key） const PROP_NAME = Symbol()const PROP_AGE = Symbol()let obj = &#123; [PROP_NAME]: &quot;一斤代码&quot;&#125;obj[PROP_AGE] = 18obj[PROP_NAME] // &#x27;一斤代码&#x27;obj[PROP_AGE] // 18 区别声明时，基本数据存放在栈里，引用数据存放在堆中 访问时，基本数据类型是按值访问的，引用数据类型是按引用访问的 修改时，基本数据是不可变的，引用数据则是可变的 传参时，基本数据类型传的是值，引用数据类型传的是引用（对象在堆上的引用） 因此，参数是一个对象时，函数内部尽量不要修改函数外部的值 基本数据类型的赋值是把值拷贝一份，而引用数据类型则是拷贝对象在堆上的地址，不会新创建对象 css中的一些单位em和rem计算em，如果自身元素是没有设置字体大小的，那么就会根据其父元素（如果父元素没有设置font-size，就去找爷元素递归）的字体大小作为参照去计算，如果元素本身已经设置了字体，那么就会基于自身的字体大小进行计算（width等设置了em，先看自己元素有没有设置font-size，有的话拿这个算，没的话再往上找） rem和em比较相似，不过计算的参照物不是父元素，而是根html元素，避免了字体大小逐层复合的连锁反应 浏览器默认字体16px vh、vw、vmin、vmax以vh为例，表示视窗高度的百分比，1vh就相当于整个视窗高度的1% %盒模型中的百分比width/height、max-width/height、min-width/height：值为百分比时，其相对于包含块的 width/height 进行计算； padding、margin：值为百分比时，如果是水平的值，就是相对于包含块的width进行计算；如果是垂直的值，就是相对于包含块的height进行计算。 文本中的百分比font-size：根据父元素的font-size进行计算； line-height：根据font-size进行计算； 定位中的百分比如果元素为静态（ static ）或相对定位（ relative ），包含块一般是其父容器； 如果元素为绝对定位（ absolute ），包含块应该是离它最近的 position 为 absolute 、 relative 或 fixed 的祖先元素； 如果元素为固定定位（ fixed ），包含块就是视窗（ viewport ） HTTP缓存与CDN缓存HTTP缓存（客户端缓存）缓存是一种保存资源副本并在下次请求时直接使用该副本的技术，当 web 缓存发现请求的资源已经被存储，那么直接使用该资源的拷贝，而不会去再次请求服务端 根据是否需要重新向服务器发起请求可以分成两种：强制缓存和对比/协商缓存 强制缓存 客户端请求数据 服务端返回数据以及缓存规则 客户端将数据和缓存规则存进缓存数据库 再次请求数据，先看缓存数据库里的缓存规则，如果资源没过期那么直接从缓存数据库中取，否则向服务端发起请求 Expires：主要是用在http/1.0，现在默认使用http/1.1，作用基本忽略；它的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。 到期时间是由服务端生成的，如果客户端时间跟服务器时间不一致，这就会导致命中误差 Cache-Control：默认值为private ​ max-age：设置资源可以被缓存的时间，单位为秒，在这段时间内再次请求这个资源将会直接使用缓存数据库中的数据 ​ s-maxage：和 max-age 是一样的，不过它只针对代理服务器缓存而言 ​ public：响应可以被任何缓存区（发送请求的客户端、代理服务器CDN等）缓存 ​ private：只有个人能缓存，代理服务器不可以缓存 ​ no-cache：强制客户端每次直接向服务器发送请求，服务器接收到请求后，判断资源是否变更，是则返回新内容，否则返回304，未变更 ​ no-store：禁止一切缓存 对比/协商缓存 客户端请求数据 服务端返回数据以及缓存标识 客户端将数据以及缓存标识存进缓存数据库 再次请求数据，将缓存标识发给服务端 服务端返回304，未变更，客户端直接使用缓存数据；否则返回最新数据以及缓存规则 Last-Modified（响应）/If-Modified-Since（请求） 服务端响应请求时，会带上Last-Modified字段告诉浏览器这个资源的==最后修改时间==；浏览器后来再次请求时，带上If-Modified-Since字段发给服务端；服务端通过对比资源最后的修改时间来判断是否能使用缓存 Etag（响应）/If-None-Match（请求） 优先级比Last-Modified/If-Modified-Since更高； 服务端响应请求时，会带上Etag字段告诉浏览器这个资源在服务器的==唯一标识==；浏览器后来再次请求时，带上If-None-Match字段发给服务端；服务端对比这个If-None-Match和这个资源现在的Etag是否一致来判断是否能使用缓存 CDN缓存（服务端缓存）将源站上的资源缓存到各地的==边缘服务器==节点上，当用户访问该资源时，cdn再通过==负载均衡==将用户的请求调度到最近的缓存节点上 s-maxage=0、max-age=0、no-cache、no-store、private中的任一种时候，该类型文件就被认定为不缓存文件，所有请求直接转发源站；只有当存在缓存且缓存过期的时候，才会与源站对比缓存是否被修改。 跨域同源：协议、域名、端口缺一不同源；限制发送Ajax非同源请求、获取非同源的DOM、读取非同源的Cookie/LocalStorage等 解决jsonp使用img、script、link标签中的src来进行跨域get请求 缺点在于需要后端配合，将返回结果包装成callback(res)的形式 如果黑客通过这种方式对服务器进行攻击，可以通过设置页面的==内容安全协议csp==进行防范 cors跨域简单请求：直接发送请求到服务器，只请求一次 请求方式是GET/POST/HEAD 请求头限制：Accept、Accept-Language、Content-Language、Content-Type、Last-Event-ID Content-type值为application/x-www-form-urlencoded、multipart/form-data、text/plain 复杂请求：会在正式请求发送之前，先发一个预检options请求进行校验，校验通过后才能进行正式请求 vue双向绑定vue的双向绑定是指数据和视图的修改会影响另外一方。通过js方法修改数据时，页面会相应变化；修改页面时，数据也会更新；后者是通过addEventLisenter增加监听事件来实现的 vue是通过数据劫持和发布-订阅者模式实现修改数据更新视图的，vue2中通过Object.defineProperty方法来劫持各个属性，当触发对象属性的setter时，会通知订阅者触发相应的监听回调。主要流程如下 new Vue实例的时候会调用Observer和Compile，Observer来完成数据劫持（value丢失问题），Compile负责解析原先的dom，通过createDocumentFragment将要处理的dom放到临时内存里，统一处理后再append到vue挂载的dom上初始化视图 发布订阅者模式实现和Dependency、Watcher两个类有关；Dependency维护了一个订阅者数组，以及两个方法，添加订阅者和通知数组内所有订阅者调用监听回调的方法。Watcher则是有监听的对象、监听的属性和属性发生修改的回调函数，对外暴露一个update方法给Dependency调用，内部再调用监听的回调函数 在Compile里会new Watcher ，不同的nodeType会有不同监听回调的Watcher，在Compile里告诉Watcher具体要的回调要怎么处理；new Watcher的时候会去访问对应的属性，为的是触发这个key的getter，在这个getter里将watcher加入到dependency的订阅数组里（为什么Dependency是在Observer里创建？）；setter则是负责调用dependency的notify webpack是什么：静态打包工具、管理模块依赖 作用：编译代码，es6转es5，解决浏览器兼容问题；模块整合，解决浏览器频繁请求文件的问题； 构建流程：初始化阶段、编译构建阶段、输出阶段 webpack和vitewebpack先打包再启动开发服务器；vite是直接启动开发服务器，然后按需编译依赖文件，所以vite的请求速度更快 package.json和package-lock.json的区别前者是npm init时生成的，用来描述项目及项目依赖的模块信息 后者是npm install生成的，用来记录node_modules里所有模块的版本信息、来源以及依赖的小版本信息 为什么还要package-lock.json：包含resolved下载地址和requires相关依赖，所以相对下载速度也更快","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://ydl8686.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"📖算法 | 每日一题","slug":"算法-每日一题","date":"2023-02-12T04:47:41.000Z","updated":"2023-02-13T07:56:52.418Z","comments":true,"path":"posts/26641/","link":"","permalink":"http://ydl8686.github.io/posts/26641/","excerpt":"","text":"字母板上的路径 2023-2-12 每次都是先上下移动再左右移动，针对z的特殊情况需要先左右移动再上下，因为z的右边是空的走不了 var alphabetBoardPath = function(target) &#123; let result=&#x27;&#x27;; if(!target)&#123; return &#x27;&#x27;; &#125; // m,n用来表示上一个字符起点的坐标 let m=0; let n=0; for(let i=0;i&lt;target.length;i++)&#123; let obj=coordinate(target.charAt(i)); let y=run(obj.y-n,&#x27;y&#x27;); let x=run(obj.x-m,&#x27;x&#x27;); // 特殊情况判断 if(target.charAt(i)===&#x27;z&#x27;)&#123; result=result+y+x+&#x27;!&#x27;; &#125; else&#123; result=result+x+y+&#x27;!&#x27;; &#125; m=obj.x; n=obj.y; &#125; return result;&#125;;// 返回字符在字母板上的位置let coordinate=char=&gt;&#123; let num=char.charCodeAt()-&#x27;a&#x27;.charCodeAt(); return &#123; x:Math.floor(num/5), y:num%5, &#125;&#125;//返回从起点到终点的路径字符串let run=(val, axis)=&gt;&#123; let result=&#x27;&#x27;; if(val===0)&#123; return result; &#125; let char=&#x27;&#x27;; if(axis===&#x27;x&#x27;)&#123; if(val&gt;0)&#123; char=&#x27;D&#x27;; &#125; else&#123; char=&#x27;U&#x27;; &#125; &#125; else&#123; if(val&gt;0)&#123; char=&#x27;R&#x27;; &#125; else&#123; char=&#x27;L&#x27;; &#125; &#125; for(let i=0;i&lt;Math.abs(val);i++)&#123; result=result+char; &#125; return result;&#125; 替换子串得到平衡字符串 2023-2-13 首先是题目条件的转化，将得到平衡字符串转化为寻找包含指定字符串的子串需要注意的是，寻找子串要尽可能降低时间复杂度，减少循环 var balancedString = function(s) &#123; let m=new Map(); for(let i=0;i&lt;s.length;i++)&#123; if(m.has(s.charAt(i)))&#123; m.set(s.charAt(i),m.get(s.charAt(i))+1); &#125; else&#123; m.set(s.charAt(i),1); &#125; &#125; let mod=new Map(); for(let x of m)&#123; if(x[1]&gt;(s.length/4))&#123; mod.set(x[0],x[1]-(s.length/4)); &#125; &#125; //接下来就是要找一个包含mod的子串 return help(s,mod);&#125;;let help=(s,m)=&gt;&#123; let l=0; for(let x of m)&#123; l+=x[1]; &#125; // result是我们要的子串长度 for(let result=l;result&lt;=s.length;result++)&#123; // 降低时间复杂度，对于一个长度只声明一次map，通过添加/删除元素来避免多次循环声明 let t=s.substring(0,result); let mymap=new Map(); for(let k=0;k&lt;t.length;k++)&#123; if(mymap.has(t.charAt(k)))&#123; mymap.set(t.charAt(k),mymap.get(t.charAt(k))+1); &#125; else&#123; mymap.set(t.charAt(k),1); &#125; &#125; for(let i=0;i+result&lt;=s.length;i++)&#123; if(i!=0)&#123; mymap.set(s.charAt(i-1),mymap.get(s.charAt(i-1))-1); if(mymap.has(s.charAt(i-1+result)))&#123; mymap.set(s.charAt(i-1+result),mymap.get(s.charAt(i-1+result))+1); &#125; else&#123; mymap.set(s.charAt(i-1+result),1); &#125; &#125; let signal=true; for(let u of m)&#123; if(!mymap.has(u[0]) || mymap.get(u[0])&lt;u[1])&#123; signal=false; &#125; &#125; if(signal)&#123; return result; &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://ydl8686.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"软件安全课程实践","slug":"软件安全实践","date":"2023-02-10T03:02:03.000Z","updated":"2023-02-16T15:09:52.686Z","comments":true,"path":"posts/49951/","link":"","permalink":"http://ydl8686.github.io/posts/49951/","excerpt":"","text":"第一题 P239 12. 安装ubuntu sudo pip install flawfinder 使用root权限是为了将flawfinder加入环境变量，可以直接使用flawfinder作为命令，如果直接pip安装，接下来的操作会报错提示没有flawfinder命令 去知乎上搜索github上的c项目，并在ubuntu上以zip包形式下载下来 flawfinder --quiet --html $&#123;目标目录路径&#125; &gt; $&#123;输出路径&#125; 解析错误，需要将源代码转换至utf-8编码 sudo pip install cvt2utfcvt2utf convert ./ -b -i c cpp -x txt 将cpp和c文件转换为utf-8编码 再次运行flawrfinder命令，成功输出results.html 对比其他C/C++代码分析工具如RATS、Splint的异同 Flawfinder：一款开源的用于C/C++静态扫描的分析工具，其根据内部字典数据库进行静态搜索，匹配简单的缺陷与漏洞，flawfinder工具不需要编译C/C++代码，可以直接进行扫描分析。简单快速，优点是免费，且不需要编译。source RATS：一种用于C、C++、Python、Per和PHP代码的安全审计工具。它能够对源代码进行扫描，找出潜在的危险函数调用。该工具的最终目标并不是找出代码漏洞，而是为人工安全审计提供一个方便合理的起点。RATS结合了静态检查技术和深度语义分析技术检查缓冲区溢出漏洞。RATS遵守通用公共许可证GPL。RATS可以对整个工程代码进行检查，而不是单一文件。同时，RATS还可以检查数组的边界。source Splint：(原来的 LCLint) 是一个GNU免费授权的Lint程序，是一个动态检查C语言程序安全弱点和编写错误的程序。Splint会进行多种常规检查,包括未使用的变量,类型不一致,使用未定义变量,无法执行的代码,忽略返回值,执行路径未返回,无限循环等错误。source 第二题 P239 15. 下载American Fuzzy Lop项目 wget https://lcamtuf.coredump.cx/afl/releases/afl-latest.tgztar -zxvf afl-latest.tgzcd afl-2.52b 安装gcc编译器 sudo apt-get install gcc 编译以及安装 make // 从makefile中读取指令，然后编译sudo make install // 从makefile中读取指令，安装到指定的位置afl-fuzz // 验证是否安装成功 创建测试文件mytestfile.c #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;signal.h&gt; int vuln(char *str)&#123; int len = strlen(str); if(str[0] == &#x27;A&#x27; &amp;&amp; len == 66) &#123; raise(SIGSEGV); &#125; else if(str[0] == &#x27;F&#x27; &amp;&amp; len == 6) &#123; raise(SIGSEGV); &#125; else &#123; printf(&quot;it is good!\\n&quot;); &#125; return 0;&#125;int main(int argc, char *argv[])&#123; char buf[100]=&#123;0&#125;; gets(buf); //存在栈溢出漏洞 printf(buf); //存在格式化字符串漏洞 vuln(buf); return 0;&#125; 使用afl-gcc -g -o afl_test mytestfile.c进行编译插桩 创建fuzz_input和fuzz_output文件夹作为模糊测试的输入输出，并在fuzz_input下通过echo 666 &gt; testcase创建一个测试样本 开始模糊测试afl-fuzz -i fuzz_input -o fuzz_output ./afl_test 报错，系统配置问题导致出错 解决方案：root权限执行 `echo ecore > /proc/sys/kernel/core_pattern` 再次开始模糊测试 14分钟后 结果分析 crashes文件夹里面是产生crash的样例 hangs里面是产生超时的样例 queue里面是每个不同执行路径的测试用例 第三题 P239 16. ubuntu下安装Metasploit curl https://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/templates/metasploit-framework-wrappers/msfupdate.erb &gt; msfinstall &amp;&amp; chmod 755 msfinstall &amp;&amp; ./msfinstall 在msf控制台输入search ms08-067搜索并使用ms08-067漏洞模块 show options查看当前配置 使用set RHOST 172.16.237.142命令设置靶机ip 需要关闭xp的防火墙，否则两台电脑无法互相ping通 使用set payload windows/meterpreter/reverse_tcp设置payload并再次查看配置 输入exploit命令开始对靶机进行渗透攻击，并进入特殊的payload：meterpreter 进行渗透操作 上传攻击机文件至靶机 截屏 clearev清除靶机日志 第四题 P304 25. 从github里160道crackme中找到一道Brad Soblesky.1.exe，使用vc6编写，在给定的输入框中输入正确的字符串才算成功，否则失败 使用OllyDbg打开上述exe文件 因为提示输入的内容、输入错误/成功的消息都是由字符串组成，所以我们搜索文本字符串 在这里，我们看到了输入错误的提示Incorrect try again!!，因为这一部分猜测是拿我们输入的字符串（可能进一步加密）和正确密码对比后的结果，所以我们双击找到起始函数位置下的断点，倒推对比的逻辑 这幅图里可以看到两种情况，分别是正确的和错误的，在此之前则是判断以及跳转的逻辑，重点关注 jnz 和 jmp jnz和jmp在汇编语言中都代表指令的跳转，前者表示上条指令结果不为0时转移，后者则是无条件跳转；指令中的SHORT规定了转移地址的标号为有符号的8位二进制数 尝试修改汇编代码，把跳转逻辑直接抹掉并保存 再次运行程序，发现无论输入什么都提示Correct way to go!!，破解成功 第五题 P342 12.熊猫烧香的病毒行为 运行病毒前 运行病毒后，通过对比可以发现多出了一个名为spoclsv.exe的进程，即熊猫烧香病毒创建出来的进程 启动项被修改 启动项可以用来设置开机自启动 注册表被编辑，并启动了对应的spoclsv.exe文件 注册表实际上是一个庞大的数据库，这个数据库记录了机器软硬件环境的各种信息，对操作系统及应用程序的正常运行至关重要。具体来讲，此数据库包含了Windows系统和应用程序的初始化信息、应用程序和文档文件的关联、硬件设备的说明、状态和属性等数据，操作系统和应用程序会对此数据库进行频繁存取，以保存和获取必要的数据source 在对应目录下发现了该exe文件 图标被修改 C盘根目录下生成setup.exe和autorun.inf文件 分析熊猫烧香的病毒结构 三个关键函数，作用分别是释放病毒并运行、感染其他文件、病毒的自我保护，这里选取第一个函数进行具体分析 拷贝病毒并运行 检查Desktop.ini文件是否存在，不存在则跳转 call是在调用字符串拼接函数，把拼接的结果完整路径放到EAX寄存器里，再次调用函数来判断该路径文件是否存在，如果文件不存在则跳转至00408110 如果存在则删掉该文件 还是调用同样的字符串拼接函数，之后把对应的文件删除 读取病毒文件到内存中 判断文件大小是否为0、是否被感染、是否第一次运行 test是为了判断文件大小是否为0，不为0则文件首地址放到EAX寄存器里；再CMP比较文件最后一个数据是否为0，为0表示没有被感染过；最后再CMP判断是否是第一次运行病毒程序 拷贝病毒到系统目录下，并且运行起来 小结 检查Desktoi.ini是否存在，存在就删除，不存在就创建 拷贝病毒文件到内存，并作相应的判断 拷贝到系统目录下，并且运行","categories":[],"tags":[{"name":"课业","slug":"课业","permalink":"http://ydl8686.github.io/tags/%E8%AF%BE%E4%B8%9A/"}]},{"title":"设计模式六大原则","slug":"设计模式六大原则","date":"2023-02-05T15:58:13.000Z","updated":"2023-02-11T03:31:34.929Z","comments":true,"path":"posts/12639/","link":"","permalink":"http://ydl8686.github.io/posts/12639/","excerpt":"","text":"单一职责原则","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://ydl8686.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"面试 | css","slug":"css","date":"2022-09-03T02:57:16.000Z","updated":"2023-02-12T04:55:44.824Z","comments":true,"path":"posts/19784/","link":"","permalink":"http://ydl8686.github.io/posts/19784/","excerpt":"","text":"1. 度量单位em、rem、vh、vw、%em相对长度单位，相对于当前对象内文本的字体尺寸，根据父元素的font-size大小变化而变化 rem相对长度单位，相对于根元素（即html元素）font-size的倍数，不会被它的父元素影响 rem布局的本质是等比缩放大屏用户需要有选择要更大字体或者更多内容的自由，如果使用rem布局，那么用户就只能被迫接受更大字体 vh和vwviewport height和viewport width，对应的是window.innerHeight和window.innerWidth，把浏览器导航栏下方到浏览器下方的距离化成了100份 %相对于父元素的大小 2. rem布局加载闪烁问题在使用rem布局时可能会出现加载闪烁的问题，也就是在加载的时候会出现元素一开始很小，闪烁后恢复正常大小的情况；这是因为引入的js文件中有修改font-size的部分，阻塞了后续的DOM解析和渲染；此时前面的DOM可以被正确地解析及渲染，所以会出现元素很小的情况，之后js解析完成后，元素恢复正常大小可以使用媒体查询来设置html元素的font-size；这样dom还没有渲染完但是已经可以正常展现的时候，显示的元素大小也是正确的 https://blog.csdn.net/u013778905/article/details/77938784https://yanhaijing.com/css/2017/09/29/principle-of-rem-layout/ 3. position中的relative和absoluterelative 相对于原来位置移动，设置后元素仍然处于文档流中，可能会撑大容器 absolute 元素会脱离文档流，没有设置偏移量的话就还在原来的位置，会影响其他元素的位置定位 在父元素没有设置相对定位(relative)或绝对定位(absolute+fixed)的情况下，元素相对于html元素偏移 父元素设置了相对定位或绝对定位后，元素会相对于离自己最近的设置了相对或绝对定位的父元素进行定位 https://www.runoob.com/w3cnote/css-position-static-relative-absolute-fixed.html 4. 三栏布局实现 grid布局.container &#123; display: grid; grid-template-columns: 100px auto 200px;&#125; flex布局.container &#123; display: flex;&#125;.item1 &#123; height: 60vh; width: 100px;&#125;.item2 &#123; height: 130vh; flex: 1 0 auto;&#125;.item3 &#123; height: 80vh; width: 240px;&#125; 浮动+BFC.column1 &#123; float: left; width: 100px; height: 300px; background-color: green;&#125;.column2 &#123; float: right; width: 100px; height: 300px; background-color: green;&#125;.column3 &#123; overflow: hidden; /*创建bfc*/ height: 300px; background-color: red;&#125; 5. BFC块级格式化上下文，其中格式化上下文是指页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用 高度塌陷：在文档流中，父元素的高度默认是被子元素撑开的，但是子元素设置成浮动后，子元素会脱离文档流，导致子元素无法撑起父元素的高度可以将父元素高度写死防止高度塌陷的问题，但是一旦高度写死，父元素的高度将不能自动适应子元素的高度 形成BFC的条件 浮动元素 position(absolute、fixed) display为inline-block，table-cell，table-caption overflow除了visible以外的值","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://ydl8686.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"面试 | js","slug":"面试lalala","date":"2022-01-18T07:15:26.000Z","updated":"2023-03-25T01:07:54.329Z","comments":true,"path":"posts/55448/","link":"","permalink":"http://ydl8686.github.io/posts/55448/","excerpt":"","text":"1. 数据类型基本类型String、Number、Boolean、null、undefined、Symbol、BigInt Symbol在ES6中新引入的一种数据类型，用来表示“独一无二”的值，可以用作对象属性的唯一标识符 let info1 = &#123; name: &#x27;波吉&#x27;, description: &#x27;又善良又可爱&#x27;,&#125;;let info2 = &#123; description: &#x27;排名第一的国王&#x27;&#125; 现在想要汇总这两个对象为info，使用Object.assign(&#123;&#125;, info1, info2)，后一个描述会覆盖掉前一个描述，使用Symbol进行改写就可以了 let info1 = &#123; name: &#x27;波吉&#x27;, [Symbol(&#x27;description&#x27;)]: &#x27;又善良又可爱&#x27;,&#125;;let info2 = &#123; [Symbol(&#x27;description&#x27;)]: &#x27;排名第一的国王&#x27;&#125;let info = Object.assign(&#123;&#125;, info1, info2);let t = Object.getOwnPropertySymbols(info);for(let i=0; i&lt;t.length; i++)&#123; console.log(t[i], info[t[i]]);&#125;// Symbol(description) &#x27;又善良又可爱&#x27;// Symbol(description) &#x27;排名第一的国王&#x27; 其实Symbol里面的参数是可有可无的；本质上是生成了一个唯一的属性，所以汇总的时候不会覆盖 除此之外，不能通过info[Symbol(&#39;description&#39;)]来访问info1和info2里的描述，因为这种写法相当于又给info添加了一个唯一的属性，必须通过Object.getOwnPropertySymbols(info)来获取属性列表，进而取到对应的值 let t = Symbol();let info = &#123;name: &#x27;波吉&#x27;,t: &#x27;1&#x27;,[t]: &#x27;又善良又可爱&#x27;, // 变量做属性要加方括号&#125;;info.t // &#x27;1&#x27;info[&#x27;t&#x27;] // &#x27;1&#x27;info[t] // &#x27;又善良又可爱&#x27; 引用数据类型Object、Array、Function 区别存储位置不同 2. 检测数据类型Object.prototype.toString.call：Array、Function等重写了toString，所以得用Object.prototype.toString.call而不是toString instanceof constructor typeof：用来判断除了object（包括null）的基本数据类型 3. 判断是否是数组 Object.prototype.toString.call(obj) obj instanceof Array Array.isArray(obj) obj.__proto__ === Array.prototype Array.prototype.isPrototypeOf(obj) 4. null和undefined区别undefined表示未定义，例如声明了但还没有定义的变量的值是undefined；null表示空对象，例如Object.prototype.__proto__是null表示已经到头了 undefined不是保留字，可以用作变量名；null是保留字 可以通过void 0来获取undefined 5. typeof null的结果Object null的底层存储全是0，而000的类型标签刚好表示对象 6. 为什么0.1+0.2!==0.3因为0.1和0.2在底层双精度浮点数的二进制存储都是无限循环，相加存在误差 可以通过Number.EPSILON进行修正 7. ||和&amp;&amp;的返回值 对于 || ，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值 &amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值 8. 判断相等的方法使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较 使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false 使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的 9. 包装类型在调用基本类型的属性或方法时，隐式地将基本类型转换为对象 装包let a = &#x27;abc&#x27;;Object(a); 拆包let a = new String(&#x27;123&#x27;);a.valueOf(); 10. 隐式类型转换如果变量是基本类型，那么直接返回 对于对象，使用ToPrimitive方法 如果是对象，那么先toString，再valueOf，如果中间有基本类型就返回，没有就报错 如果是Date，那么先valueOf，再toString，如果中间有基本类型就返回，没有就报错 11. 拷贝每个数据都会占有一块内存，通过变量来访问；如果拷贝之后的不同变量访问的是同一块内存，这种方式就是浅拷贝；如果是开辟了一块新的内存来拷贝的话，不同变量访问的就不是同一块内存，就是深拷贝 拷贝基本数据类型，例如Number、String都是浅拷贝，深浅拷贝只针对对象，例如Array、Object 浅拷贝1.直接用= let a = &#123; name: &#x27;波吉&#x27;, rank: 1&#125;;let b = a;b.rank = 10086;a.rank /*10086*/b === a /* true */ 2.Object.assign 该方法可以把任意多个源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象；拷贝的是对象属性而不是对象本身 let a = &#123; name: &#x27;波吉&#x27;, rank: 1&#125;;/* 如果a是数组的话就是Object.assign([] ,a) */let b = Object.assign(&#123;&#125;, a);a === b /* false */ 像上面这个例子，a里面的属性都是基础数据类型，所以使用该方法之后就相当于深拷贝，但如果a里面的属性是对象的话，那么只是拷贝了引用；如果a是数组的话也是很类似的，看数组元素是数字还是对象，如果是数字就是深拷贝，对象就是浅拷贝 let a = &#123; name: &#x27;波吉&#x27;, friends: &#123; name1: &#x27;卡克&#x27;, name2: &#x27;snake&#x27; &#125;&#125;;let b = Object.assign(&#123;&#125;, a);b.name = &#x27;ydl&#x27;;b.friends.name2 = &#x27;蛇&#x27;;/* a为 &#123; name: &#x27;波吉&#x27;, friends: &#123; name1: &#x27;卡克&#x27;, name2: &#x27;蛇&#x27; &#125; &#125; */ 3.扩展运算符... 和Object.assign很类似，也是对对象属性或数组元素进行拷贝 let a = &#123; name: &#x27;波吉&#x27;, friends: &#123; name1: &#x27;卡克&#x27;, name2: &#x27;snake&#x27; &#125;&#125;;let b =&#123; ...a&#125; 12. let、const、var的区别块级作用域、变量提升、重复声明、初始值设置、指针指向 13. 箭头函数与普通函数的区别箭头函数没有自己的this，箭头函数里的this指向不会通过call、apply、bind等方法改变 箭头函数不能作为构造函数，因为new的第二步需要将函数中的this指向创建的对象，但是箭头函数没有this，且不能改变指向，所以不能 箭头函数没有argument 箭头函数没有prototype 14. Map和Object都是键值对的集合 map的key是有序的，迭代时以插入的顺序返回键值；object的则是无序的 map的key可以是任意值；object的则必须是String或Symbol map默认不包含任何键；object有一个原型，原型上的键名可能和自己设置的冲突 15. JSONJSON 是一种轻量级的数据交换格式，基于js ，但是JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如 JSON 中属性值不能为函数、NaN等，因此大多数的 js 对象是不符合 JSON 对象的格式的。 JSON.stringfy用来js对象转JSON字符串 JSON.parse用来JSON字符串转js对象 16. js脚本延迟加载的方式defer属性： 让脚本的请求加载与文档的解析同步，然后在文档解析完成后再执行这个脚本文件 async属性： 使脚本异步请求加载，不会阻塞页面的解析过程，但是脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞 动态创建 DOM 方式： 对文档的加载事件进行监听，当文档加载完成后再创建 script 标签来引入 js 脚本 setTimeout 17. DOM和BOMDOM 指的是文档对象模型，把文档当做一个对象 BOM 指的是浏览器对象模型，把浏览器当做一个对象来对待，核心是 window，具有双重角色，既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象 18. ES6模块和commonJS模块的异同CommonJS的 require 语法是同步的，当我们使用require 加载一个模块的时候，必须要等这个模块加载完后，才会执行后面的代码，在浏览器端文件一般存放在服务器或者CDN上，如果使用同步的方式加载一个模块还需要由网络来决定快慢，很容易进入“假死状态” CommonJS模块输出的是一个值的拷贝，ES6 模块输出的是值的引用 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口 对于循环引用，CommonJS 输出的是当前已经执行那部分的值，而不是代码全部执行后的值，ES6 模块是动态引用，变量不会被缓存，真正取值的时候就能取到最终的值 19. 解释型语言和编译型语言的区别 解释型每次运行都需要解释源代码，效率较低；编译型一次性编译成平台相关的机器语言文件，以后在运行时，直接运行编译结果即可 解释型只要平台提供相应的解释器，就可以运行源代码，所以移植性更好；编译型与特定平台相关，一般无法移植到其他平台 20. for in和for of的区别 for… of 遍历获取的是对象的键值，for…in 获取的是对象的键名 for… in 会遍历对象的整个原型链，而 for … of 只遍历当前对象不会遍历原型链 for in可以搭配hasOwnProperty来实现只遍历当前对象 21. 原型与原型链原型：每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了所有创建的实例可以共享的属性和方法 原型链：当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么就去原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去 22. 闭包/作用域/作用域链指有权访问另一个函数作用域中变量的函数 全局作用域、函数作用域、块级作用域 作用域链： 在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链 23. 执行上下文当js执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文 24. 实现继承的方式原型链继承：将父类实例作为子类的原型 Student.prototype=new Person(); 缺点： 无法实现多继承 所有新实例都会共享父类实例、原型链上的属性和方法 子构造函数的constructor指向错误，需要额外Student.prototype.constructor=Student; 构造函数继承：在一个类中执行另一个类的构造函数，通过 call函数设置 this的指向，这样就可以得到另一个类的所有属性 function Student(name, grade, site) &#123; Person.call(this, name) WebsiteMaster.call(this, site) this.grade = grade&#125; 缺点： 只能继承父类的实例属性，不能继承父类原型上的属性、方法 实例并不是父类的实例，而只是子类的实例 寄生组合式：通过 Object.create()来代替给子类原型赋值的过程，解决了两次调用父类构造函数的问题 function Student(name, grade, site) &#123; Person.call(this, name) // 继承属性 WebsiteMaster.call(this, site) this.grade = grade&#125;Student.prototype = Object.create(Person.prototype) // 继承方法Student.prototype.constructor = Student // 修复构造函数指向 25. 垃圾回收垃圾回收是指收回已经不再参与运行的变量所占用的内存空间 3. 对象拷贝深拷贝1.把对象转换成JSON字符串再转换回来 let obj1 = &#123; name: &#123; a: &quot;波吉&quot; &#125; &#125;;let obj2 = JSON.parse(JSON.stringify(obj1)); 能处理的数据只有能够被json直接表示的结构；当遇到循环引用的对象时会报错；当遇到函数、undefined、symbol时，如果这些是作为对象属性来stringfy，那么直接忽略；如果是作为数组元素，那么为null，如果单独拿来stringfy，则是undefined 循环引用 let obj1 = &#123;&#125;;let obj2 = &#123; b: obj1&#125;;obj1.a = obj2; 2.递归拷贝 Reflect.ownKeys()方法返回一个由目标对象自身的属性组成的数组，不包括原型链上继承的属性；考虑了Symbol、undefined、函数for in方法会考虑对象原型链上的继承的属性、undefined、函数，但是没考虑Symbol const deepClone=target=&gt;&#123; if(typeof target!==&#x27;object&#x27;)&#123; return target; &#125; let cloneTarget=Array.isArray(target)?[]:&#123;&#125;; for(let key of Reflect.ownKeys(target))&#123; cloneTarget[key]=deepClone(target[key]); &#125; return cloneTarget;&#125; 4. new运算符执行过程function Person(name) &#123; this.name = name;&#125;let boji = new Person(&#x27;波吉&#x27;); 以上面代码为例，new Person(&#39;波吉&#39;)可以解析为以下步骤 var obj = &#123;&#125;;obj.__proto__ = Person.prototype; var result = Person.call(obj, &#x27;波吉&#x27;)； return typeof result === &#x27;object&#x27; ? result||obj : obj; 创建一个继承自Person.prototype的空对象 将构造函数中的this指向obj，并传递参数’波吉’调用构造函数；执行完毕后，obj多了一个属性name，并且其值为波吉 返回对象给变量boji 如果构造函数本身返回了一个对象，那么new操作符返回的就是构造函数的返回值 如果构造函数返回的不是对象（例如null，undefined；虽然null是基本数据类型，但是typeof确是object）或者啥也没返回，那么new返回的就是继承自Person.prototype的新对象 手写实现// 法一function objGenerator() &#123; var obj = &#123;&#125;; cons = arguments[0]; obj.__proto__ = cons.prototype; var result = cons.apply(obj, [].slice.call(arguments).slice(1)); return typeof result === &#x27;object&#x27; ? result || obj : obj&#125;// 法二 更优雅function objGenerator(cons, ...arg) &#123; var obj = &#123;&#125;; obj.__proto__ = cons.prototype; var result = cons.apply(obj, arg); return typeof result === &#x27;object&#x27; ? result || obj : obj&#125;var p = objGenerator(Person, &#x27;波吉&#x27;); 5. apply、call、bind异同相同点这三个函数都是 Function原型上的方法 Function.prototype.call()，Function.prototype.apply，Function.prototype.bind()，因此所有的函数可以调用这三个方法。 三个函数的第一个参数都是必选的，表示this的指向，如果不需要指定this的指向，第一个参数可以为null 不同点函数调用apply、call时的返回值就是函数本身的返回值，而调用bind返回值是一个新的函数 apply接受的是一个参数数组，而call是多个参数","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://ydl8686.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"📖算法 | 剑指offer","slug":"剑指offer算法","date":"2022-01-17T08:50:36.000Z","updated":"2023-03-03T08:54:04.291Z","comments":true,"path":"posts/30446/","link":"","permalink":"http://ydl8686.github.io/posts/30446/","excerpt":"","text":"03 数组中重复的数字 解法1使用数据结构Set，利用其不会储存相同元素的特性来解决，不断往里面添加元素，看看Set大小有没有变，没变说明添加的就是重复的元素 var findRepeatNumber = function(nums) &#123; let mySet = new Set(); let size = mySet.size; let result = -1; nums.some(e =&gt; &#123; mySet.add(e); if(mySet.size === size) &#123; result = e; return true; &#125; size+=1; &#125;) return result;&#125;; 需要注意的是，在遍历数组nums的时候，不能采用forEach里return结果的方式，因为这样并不会跳出循环，break也是一样的；可以使用some和every方法来实现可跳出的循环，前者return true时跳出，后者return false跳出 解法2可以使用原地交换的方式，因为题目中说长度为n的数组，元素大小在[0,n-1]，有重复元素，那么在建立索引和值的对应关系上，一定会出现某个索引对应了两个值的情况，该值就是重复的元素 var findRepeatNumber = function(nums) &#123; let i=0; while(true)&#123; if(nums[i] !== i)&#123; /*防止出现1，1，1的情况*/ if(nums[nums[i]] === nums[i])&#123; return nums[i]; &#125; /*交换*/ [nums[nums[i]], nums[i]] =[nums[i], nums[nums[i]]]; &#125; else &#123; i++; &#125; &#125;&#125;; 04 二维数组中的查找 因为每行、每列都是递增顺序排列的，所以可以从右上角开始，如果当前数组中的数比target大，那么往左移；小，那么往下移；终止循环的条件是索引越界 var findNumberIn2DArray = function(matrix, target) &#123; let i = 0; let j = matrix[0].length-1; while(true) &#123; if(i&gt;matrix.length-1 || j&lt;0) &#123; return false; &#125; if(target === matrix[i][j]) &#123; return true; &#125; if(matrix[i][j] &gt; target) &#123; j--; &#125; else if(matrix[i][j] &lt; target) &#123; i++; &#125; &#125;&#125;; 05 替换空格 使用js的常用API就可以解决 // 法一var replaceSpace = function(s) &#123; return s.split(&#x27; &#x27;).join(&#x27;%20&#x27;);&#125;;// 法二var replaceSpace = function(s) &#123; // 必须要有g，不然只会替换第一个 return s.replace(/\\s/g, &#x27;%20&#x27;);&#125;; str.replace(/^\\s+|\\s+$/g, &#39;haloha&#39;)\\s : 表示 space ，空格+： 一个或多个^： 开始，^\\s，以空格开始$： 结束，\\s$，以空格结束|： 或者/g：global， 全局 06 从尾到头打印链表 先顺序遍历，把结果放到数组里，再reverse一下；或者使用unshift() /** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;number[]&#125; */// 法一var reversePrint = function(head) &#123; let result = []; while(head) &#123; result.push(head.val); head = head.next; &#125; result.reverse(); return result;&#125;;// 法二var reversePrint = function(head) &#123; let result = []; while(head) &#123; /*在数组首位置添加元素*/ result.unshift(head.val); head = head.next; &#125; return result;&#125;; 07 重建二叉树 核心是递归，根据preorder里的第一个元素，可以把inorder划分成左子树和右子树，再根据inoder里子树的大小，将preorder里划分成左子树和右子树，然后对应的进行递归操作即可 /** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;number[]&#125; preorder * @param &#123;number[]&#125; inorder * @return &#123;TreeNode&#125; */var buildTree = function(preorder, inorder) &#123; let result = new TreeNode(preorder[0]); // 特殊情况 // if(preorder.length === 1)&#123; // return result; // &#125; // else if(preorder.length === 0)&#123; // return null; // &#125; let index = inorder.indexOf(preorder[0]); result.left = buildTree(preorder.slice(1, 1+index), inorder.slice(0, index)); result.right = buildTree(preorder.slice(1+index), inorder.slice(index+1)); return result;&#125;; 10 斐波那契数列 解法1（动态规划）使用最简单的递归方法，，果然超时了，函数的入栈出栈的时间成本还是太高了，所以用了最简单的迭代，不过空间复杂度是O(N)，比较占用内存 var fib = function(n) &#123; if(n === 0 || n === 1) &#123; return n; &#125; let arr = [0, 1]; for(let i=2; i&lt;=n; i++) &#123; arr[i] = (arr[i-1] + arr[i-2])%1000000007; &#125; return arr[n];&#125;;// 还可以继续优化，因为n只与n-1，n-2有关，所以可以将空间复杂度降至O（1） 解法2使用递归的同时，再开辟一个新的数组用来存储已经算过的项，避免重复；例如算n-1和n-2这两项的时候都会用到第n-3项。所以在使用某一项的时候先看看这个数组里面有没有值，没有值再递归计算赋值 不过这样时间复杂度和空间复杂度都好高啊，还是使用动态规划最好 青蛙跳台阶也可以转换成类似的想法，关键是得到f(n)=f(n-1)+f(n-2)这个不变式 11 旋转数组的最小数字 线性遍历数组，发现后一个比前一个小，那么后一个就是答案；如果遍历完都没找到就说明这个数组是升序排列，返回第一个就好；时间复杂度O（N） var minArray = function(numbers) &#123; for(let i=0;i&lt;numbers.length-1;i++)&#123; if(numbers[i+1] &lt; numbers[i])&#123; return numbers[i+1]; &#125; &#125; return numbers[0]&#125;; 12 矩阵中的路径🌟 回溯 本题的思路核心是回溯，每次判断完一条路径是否符合条件后，要及时把状态恢复，以便其他条件递归 var exist = function(board, word) &#123; for(let i=0;i&lt;board.length;i++)&#123; for(let j=0;j&lt;board[0].length;j++)&#123; // 特殊情况，要判断的word只有一个字符 if(word.length===1 &amp;&amp; board[i][j]===word.charAt(0))&#123; return true; &#125; else if(board[i][j]===word.charAt(0))&#123; if(help(board,word.substring(1),i,j))&#123; return true; &#125; &#125; &#125; &#125; return false;&#125;;// 用来判断某一个字符是否存在符合条件的下一个字符var help = (board, word, i, j) =&gt; &#123; // 用来记录i,j位置的元素，用来回溯 let temp=board[i][j]; // 确保不会出现重复使用的情况 board[i][j]=&#x27;0&#x27;; let target = word.charAt(0); let signal1=false; let signal2=false; let signal3=false; let signal4=false; let res1=false; let res2=false; let res3=false; let res4=false; // 判断四个方向是否可行，并分别进行递归判断 if(j+1&lt;board[0].length &amp;&amp; board[i][j+1]===target)&#123; signal1=true; res1=help(board, word.substring(1),i,j+1); &#125; if(i+1&lt;board.length &amp;&amp; board[i+1][j]===target)&#123; signal2=true; res2=help(board, word.substring(1),i+1,j); &#125; if(j-1&gt;=0 &amp;&amp; board[i][j-1]===target)&#123; signal3=true; res3=help(board, word.substring(1),i,j-1); &#125; if(i-1&gt;=0 &amp;&amp; board[i-1][j]===target)&#123; signal4=true; res4=help(board, word.substring(1),i-1,j); &#125; // 当前状态的恢复 board[i][j]=temp; // 结果判定 if(word.length===1 &amp;&amp; (signal1||signal2||signal3||signal4))&#123; return true; &#125; else if(signal1||signal2||signal3||signal4)&#123; return res1||res2||res3||res4; &#125; else&#123; return false; &#125;&#125; 19 删除链表的倒数第 N 个结点 var removeNthFromEnd = function(head, n) &#123; let p=head; let target=head; for(let i=0;i&lt;n-1;i++)&#123; p=p.next; &#125; let pre=head; while(p.next)&#123; pre=target; p=p.next; target=target.next; &#125; /** 特殊情况，要删除的节点是头节点 链表只有一个元素，删除这个元素也可以归为上面👆“要删除的节点是头节点”这一类 **/ if(head===target)&#123; return target.next; &#125; pre.next=target.next; return head;&#125;; 29 顺时针打印矩阵 var spiralOrder = function(matrix) &#123; let result=[]; // 判断数组是否为空 // 不能[]===[] //false if(matrix.length===0)&#123; return result; &#125; help(matrix,result,0,0,matrix[0].length-1,matrix.length-1); return result;&#125;;let help=(matrix,result,l,t,r,b)=&gt;&#123; if(l===r &amp;&amp; t===b)&#123; result.push(matrix[t][l]); return; &#125; if(l&gt;r || t&gt;b)&#123; return; &#125; if(l&lt;r &amp;&amp; t==b)&#123; for(let i=l;i&lt;=r;i++)&#123; result.push(matrix[t][i]); &#125; &#125; else if(t&lt;b &amp;&amp; l==r)&#123; for(let i=t;i&lt;=b;i++)&#123; result.push(matrix[i][r]); &#125; &#125; else&#123; for(let i=l;i&lt;=r;i++)&#123; result.push(matrix[t][i]); &#125; for(let i=t+1;i&lt;=b;i++)&#123; result.push(matrix[i][r]); &#125; for(let i=r-1;i&gt;=l;i--)&#123; result.push(matrix[b][i]); &#125; for(let i=b-1;i&gt;t;i--)&#123; result.push(matrix[i][l]); &#125; &#125; l++; t++; r--; b--; help(matrix,result,l,t,r,b);&#125; 38 字符串的排列🌟 回溯 考察的是DFS+回溯，回溯体现在数组和字符串上，需要注意的是当字符串只有一个字符时的特殊情况 // 数组在某个index添加删除元素var permutation = function(s) &#123; if(!s)&#123; return []; &#125; let strArr=s.split(&#x27;&#x27;); let result=new Set(); let temp=&#x27;&#x27;; for(let i=0;i&lt;strArr.length;i++)&#123; temp+=strArr[i]; let char=strArr[i]; let charIndex=strArr.indexOf(char); strArr.splice(charIndex,1); help(strArr,result,temp); temp=temp.substring(0,temp.length-1); strArr.splice(charIndex,0,char); &#125; return Array.from(result);&#125;;let help=(strArr,result,temp)=&gt;&#123; // 两种情况 if(strArr.length===0)&#123; result.add(temp); return ; &#125; if(strArr.length===1)&#123; temp+=strArr[0]; result.add(temp); return ; &#125; else&#123; for(let i=0;i&lt;strArr.length;i++)&#123; temp+=strArr[i]; let char=strArr[i]; let charIndex=strArr.indexOf(char); strArr.splice(charIndex,1); help(strArr,result,temp); temp=temp.substring(0,temp.length-1); strArr.splice(charIndex,0,char); &#125; &#125;&#125; 44 数字序列中某一位的数字 找规律，计算不同位数占用索引的多少，倒推给定的n属于哪一个数，然后找到对应的某一位即可 var findNthDigit = function(n) &#123; if(n&lt;10)&#123; return n; &#125; let i=1; // i表示n所在数字的位数 let cp=n; while(cp-(Math.pow(10,i)-Math.pow(10,i-1))*i&gt;0)&#123; cp=cp-(Math.pow(10,i)-Math.pow(10,i-1))*i; i++; &#125; cp=cp-1; let t=Math.floor(cp/i); let m=cp%i; let tempResult=Math.pow(10,i-1)+t; return (tempResult+&#x27;&#x27;).charAt(m);&#125;; 50 第一个只出现一次的字符 解法1用两个数组来解决这个问题，一个数组用来存储遍历过的字符，一个数组用来存储已经重复过的的字符；遍历时遇到的字符在这两个数组内都没有出现时，进入第一个数组；如果在第一个数组中出现了，那么从第一个数组中剔除，并加入第二个数组；其余情况都不用考虑 不过好像其实也没有降低时间复杂度，因为使用到了indexOf来查找重复字符的索引，如果让自己来实现的话，又是O(N)的复杂度，综合下来还是O(N2)时间复杂度 var firstUniqChar = function(s) &#123; if(!s)&#123; return &#x27; &#x27;; &#125; let temp = []; let dupTemp = []; for(let i=0;i&lt;s.length;i++)&#123; if(dupTemp.indexOf(s[i]) === -1 &amp;&amp; temp.indexOf(s[i]) === -1)&#123; temp.push(s[i]); &#125; else if(temp.indexOf(s[i]) !== -1)&#123; temp.splice(temp.indexOf(s[i]), 1); dupTemp.push(s[i]); &#125; &#125; return temp[0]?temp[0]:&#x27; &#x27;;&#125;; 解法2使用map来解决；需要注意到的是，map对象是乱序的；但是按照key,value的形式来遍历时，是按照插入的顺序进行的 var firstUniqChar = function(s) &#123; var map = new Map(); for(let i=0;i&lt;s.length;i++)&#123; var cur = s.charAt(i); if(map.has(cur))&#123; // 如果已经出现过这个字符，那么设为false map.set(cur,false); &#125; else &#123; // 第一次遇到设置成true map.set(cur,true); &#125; &#125; for([key,value] of map)&#123; if(value)&#123; return key; &#125; &#125; return &#x27; &#x27;&#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://ydl8686.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"js常用API","slug":"js算法常用API","date":"2021-03-24T06:05:09.000Z","updated":"2023-02-13T07:52:54.722Z","comments":true,"path":"posts/14402/","link":"","permalink":"http://ydl8686.github.io/posts/14402/","excerpt":"总结了一些比较常用的数据结构以及对应的API","text":"总结了一些比较常用的数据结构以及对应的API 常用数据结构Arrayjs数组里面的元素类型可以都不一样 var a=new Array()var a=[1,2,3]a.length //NumberArray.isArray(a) //truea.toString() //返回数组的字符串形式&quot;1,2,3&quot;a.push(value,vlaue....) //在数组的末端添加一个或多个元素，并返回添加后的数组长度。pop() //用于删除数组的最后一个元素，并返回该元素shift() //用于删除数组的第一个元素，并返回该元素unshift(value) //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。join() //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。concat() //将参数数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。reverse() //用于颠倒数组中元素的顺序，改变了原数组slice(start_index, upto_index); //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。splice(index, count_to_remove, addElement1, addElement2, ...); //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。sort() //对原数组成员进行排序，默认是按照字典顺序排序。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。map() //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。forEach() //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。filter() //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。some() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。every() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。reduce() //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员）reduceRight() //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员）indexOf(s) //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置lastIndexOf(s) //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。 map//传入函数的形式不同a.map((x)=&gt;&#123; return -x;&#125;) //把a数组里的所有元素取反，返回新数组a.map(function(x)&#123; return Math.abs(x)&#125;) //取绝对值 forEacha.forEach((x,y,z)=&gt;&#123; console.log(x,y,z)&#125;)// forEach中不能使用break或return来跳出循环// 可以使用some和every方法来实现可跳出的循环，前者return true时跳出，后者return false跳出 filterarr.filter(x=&gt;&#123; if(x===&#x27;2&#x27;)&#123; return true &#125; else&#123; return false &#125;&#125;) //把符合条件的元素返回组成一个新数组 some/everyarr.some(x=&gt;&#123; if(x===&#x27;2&#x27;)&#123; return true &#125; else&#123; return false &#125;&#125;) //arr[1,2,&#x27;1&#x27;,&#x27;2&#x27;] truearr.every(x=&gt;&#123; if(x===&#x27;2&#x27;)&#123; return true &#125; else&#123; return false &#125;&#125;) //false reduce//z是索引，w是原数组t.reduce((x,y,z,w)=&gt;&#123; console.log(z) // 1 2 return x*y;&#125;) //arr[1,2,3] 6t.reduce((x,y,z,w)=&gt;&#123; console.log(z) // 0 1 2 return x*y;&#125;,0) 0 Stringvar s=new String()var s=&quot;12345&quot;var str=String.fromCharCode(97); //str=&#x27;a&#x27;s.lengths.chatAt(index) //返回指定位置的字符s.concat(s2) //返回新的连接后的字符串s.slice(start,end) //用于从原字符串取出子字符串并返回新字符串，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。s.substring(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。s.substr(start,length) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。s.indexOf(s) //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 s.lastIndexOf() //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。s.trim() //用于去除字符串两端的空格，返回一个新字符串s.toLowerCase() //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。s.toUpperCase() //全部转为大写s.localeCompare(s2) //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。s.match(regexp) //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。s.search() //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。s.replace(oldValue,newValue) //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。s.split() //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。 Mapvar m = new Map(); // 空Mapm.set(&#x27;Adam&#x27;, 67); // 添加新的key-valuem.has(&#x27;Adam&#x27;); // 是否存在key &#x27;Adam&#x27;: truem.get(&#x27;Adam&#x27;); // 67m.delete(&#x27;Adam&#x27;); // 删除key &#x27;Adam&#x27;//遍历mapfor([key,value] of map)&#123; console.log(key,value)&#125; Setvar s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3, 3]); // &#123;1, 2, 3&#125;s.add(4);s; // Set &#123;1, 2, 3, 4&#125;s.delete(3);s; // Set &#123;1, 2, 4&#125;s.size; // 3s.has(2); // true 常用方法进制转换var value = parseInt(12).toString(2); //parsetInt里面是要转换的数字，toString里面是要转换的进制，如果要转换为其他进制，替换掉就好了 判断变量类型判断变量类型一般用typeof就可以了 声明相同元素数组new Array(100).fill(1)数组长度为100，每个元素都是1 声明固定长宽的二维数组/** * 10列10行 **/let arr = new Array(10);for(let i = 0;i &lt; arr.length; i++)&#123; arr[i] = new Array(10).fill(0);&#125; 遍历Array、Map、SetArray可以使用下标，Map和Set不能使用下标，ES6引入了iterable类型，Array,Map,Set都属于iterable类型，它们可以使用for…of循环来遍历 let a = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;];let s = new Set([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]);let m = new Map([[1, &#x27;x&#x27;], [2, &#x27;y&#x27;], [3, &#x27;z&#x27;]]);for (let x of a) &#123; log(x); &#125;for (let x of s) &#123; log(x);&#125;for (let x of m) &#123; log(x[0] + &#x27;=&#x27; + x[1]); // 分别是key和value&#125; 字符与ASCII码互转将字符转为ascii码 let char=&#x27;a&#x27;;let num=str.charCodeAt(); // 97 将ascii码转为对应字符 let num=97;let char=String.fromCharCode(num); 小数取整向上取整Math.ceil(3/2) //2 向下取整Math.floor(3/2) //1 四舍五入取整Math.round(3/2) //2 数组索引处添加/删除都是对原数组进行操作删除arr.splice(index, 1)添加arr.splice(index, 0, content)","categories":[],"tags":[{"name":"API","slug":"API","permalink":"http://ydl8686.github.io/tags/API/"}]},{"title":"快捷键","slug":"快捷键","date":"2021-03-24T02:57:01.000Z","updated":"2022-12-31T04:05:37.193Z","comments":true,"path":"posts/20356/","link":"","permalink":"http://ydl8686.github.io/posts/20356/","excerpt":"","text":"mac1.ctrl+左/右：切换左右桌面2.ctrl+command+q：锁屏 mac下的chrome1.command+n：打开新窗口2.command+t：打开新标签页3.command+option+左/右：切换前/后标签页4.command+w：关闭当前标签页 mac下的vscode1.ctrl+反引号：显示终端2.command+ctrl+f：全屏/退出全屏3.option+点击：插入多个光标4.command+i：选中当前行5.command+shift+k：删除当前行6.option+上/下：移动上下行7.command+enter：下一行插入8.command+shift+enter：上一行插入9.shift+option（ALT）+f：格式化代码","categories":[],"tags":[{"name":"实用技巧","slug":"实用技巧","permalink":"http://ydl8686.github.io/tags/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}]}],"categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://ydl8686.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"算法","slug":"算法","permalink":"http://ydl8686.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"课业","slug":"课业","permalink":"http://ydl8686.github.io/tags/%E8%AF%BE%E4%B8%9A/"},{"name":"设计模式","slug":"设计模式","permalink":"http://ydl8686.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"API","slug":"API","permalink":"http://ydl8686.github.io/tags/API/"},{"name":"实用技巧","slug":"实用技巧","permalink":"http://ydl8686.github.io/tags/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}]}