{"meta":{"title":"Ydl's Blog","subtitle":null,"description":"待葡萄成熟透","author":"Ydl","url":"http://ydl8686.github.io","root":"/"},"pages":[{"title":"About","date":"2023-04-15T08:18:18.263Z","updated":"2021-05-06T12:20:17.000Z","comments":true,"path":"about/index.html","permalink":"http://ydl8686.github.io/about/index.html","excerpt":"","text":""},{"title":"Project","date":"2023-04-15T08:18:18.334Z","updated":"2021-05-06T12:20:17.000Z","comments":true,"path":"project/index.html","permalink":"http://ydl8686.github.io/project/index.html","excerpt":"","text":""},{"title":"Tags","date":"2023-04-15T08:18:18.296Z","updated":"2021-05-06T12:20:17.000Z","comments":true,"path":"tags/index.html","permalink":"http://ydl8686.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"vue3项目实战","slug":"vue3项目实战","date":"2023-04-16T01:42:34.000Z","updated":"2023-04-16T03:59:59.342Z","comments":true,"path":"posts/43715/","link":"","permalink":"http://ydl8686.github.io/posts/43715/","excerpt":"","text":"public目录下的文件是不会被vite所编译的 v-text相当于使用插值表达式，v-html还能把字符串当作html来解析","categories":[],"tags":[{"name":"vue3","slug":"vue3","permalink":"http://ydl8686.github.io/tags/vue3/"}]},{"title":"webpack","slug":"面试-webpack","date":"2023-03-22T13:24:10.000Z","updated":"2023-04-15T08:19:22.809Z","comments":true,"path":"posts/27789/","link":"","permalink":"http://ydl8686.github.io/posts/27789/","excerpt":"","text":"webpack理解webpack是一个静态的打包工具，可以用来管理项目依赖，其中打包可以解决浏览器频繁请求的问题，loader作为翻译官可以提高开发效率（sass）、解决浏览器兼容问题（es6），plugin则扩展了webpack的功能 常见的loadersass-loader：将scss/sass转换成css image-loader：加载并且压缩图片文件 babel-loader：把es6转成es5 eslint-loader：通过eslint检查js代码 vue-loader：加载vue单文件组件 cache-loader：将结果缓存到磁盘里 常见的pluginvuex-persistedstate：解决刷新浏览器vuex数据丢失问题 clean-webpack-plugin：每次打包自动删除原来打包生成的包文件夹 babel-plugin-transform-remove-console：生产环境去掉console hot-module-replacement-plugin：模块热替换 loader和plugin的区别loader是一个函数，对参数进行转换，返回转换后的结果，相当于翻译官 plugin是插件，用来扩展webpack的功能，webpack运行时会广播出很多事件，plugin监听这些事件并通过webpack提供的API改变输出结果 loader不需要引入，plugin需要；前者在rules中配置，后者在plugins数组中配置 loader在webpack读取模块内容，生成AST语法树之前进行；plugin在整个打包过程中进行 webpack运行流程初始化流程：从配置文件和Shell语句中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数 编译构建流程：从Entry发出，针对每个Module串行调用对应的Loader去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理 输出流程：对编译后的Module组合成Chunk，把Chunk转换成文件，输出到文件系统 webpack proxy工作原理，为什么能解决跨域原理实质上是利用http-proxy-middleware 这个http代理中间件，实现请求转发给其他服务器 webpack-dev-server是webpack官方的一个开发工具，会启动一个本地服务器（只适用在开发过程中），通过设置webpack proxy实现代理请求后，相当于浏览器与服务端中添加一个代理者 当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地 本地浏览器和代理服务器是同源的，服务器与服务器之间不存在跨域问题，所以能解决跨域 使用webpack来优化前端性能js代码压缩terser-webpack-plugin：让bundle更小 css代码压缩css-minimizer-webpack-plugin：去除无用的空格 文件大小压缩compression-webpack-plugin：压缩文件 图片压缩使用image-webpack-loader来对不同图片进行压缩 tree shaking消除死代码 js 设置usedExports为true，没被用上的代码在打包时会加入unused harmony export mul注释，用来告知 terser-webpack-plugin在优化时，可以删掉这段代码 css 使用purgecss-plugin-webpack删掉没用到的css样式 代码分离默认情况下，所有的JavaScript代码（业务代码、第三方依赖、暂时没有用到的模块）在首页全部都加载，就会影响首页的加载速度 splitChunksPlugin代码分离可以分成更小的bundle，控制资源加载优先级，提高代码的加载性能 提高webpack构建速度优化loader配置匹配文件类型的时候，注意提升正则表达式的性能（如果项目源码只有js文件，正则就不要写的很复杂） 配置include/exclude，规定哪些目录下的文件使用loader处理 优化resolve.modules和alias使用绝对路径和别名来减少查找过程 使用DLLPlugin插件对于依赖的第三方库，比如vue，vuex等这些不会修改的依赖，可以和自己编写的代码分开打包，好处是每次更改我本地代码的文件时，只需要重新打包我项目本身的文件代码，而不会再去编译第三方库 以后只要我们不升级第三方包，那么webpack就不会对这些库再次打包，从而提高打包的速度 使用cache-loader在一些性能开销较大的 loader之前添加 cache-loader，将结果缓存到磁盘里，提升二次构建速度 启动多线程使用terser-plugin多进程并行运行提高构建速度 webpack和vite webpack先打包再启动开发服务器；vite是直接启动开发服务器，不需要分析模块的依赖、不需要编译，因此启动速度非常快 在热更新时，webpack会将改变的模块的所有依赖重新编译，而vite则是让浏览器去重新请求该模块即可 vite使用的是ES Module，代码中不可以使用CommonJs sourceMap是什么是一项将打包压缩后的代码映射回源代码的技术，前者没有阅读性可言，开发中出现问题很难debug sourceMap可以帮助快速定位到源代码的位置，提高开发效率","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://ydl8686.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"计算机网络","slug":"面试-计算机网络","date":"2023-03-21T13:27:42.000Z","updated":"2023-04-15T08:19:11.736Z","comments":true,"path":"posts/12148/","link":"","permalink":"http://ydl8686.github.io/posts/12148/","excerpt":"","text":"1. GET和POST请求的区别应用场景：GET请求是幂等请求，对服务器的资源不会产生影响；而POST请求一般会对服务器资源进行变更 请求长度：由于浏览器限制了url长度，所以get请求发送参数的长度也会受到限制；POST请求则不会受到限制 书签：GET产生的url地址可以保存为书签，但是POST不可以 数据包：GET会把header和data通过一个TCP数据包发出去，而POST先通过OPTION发送header，响应100 continue后再发送data，最终响应200 本质上都是TCP连接，HTTP只是个行为准则，定义了不同的语义 2. 常见http请求头和响应头常见的请求头 Accept：浏览器能够处理的内容类型 Accept-Charset：浏览器能够显示的字符集 Accept-Encoding：浏览器能够处理的压缩编码 Accept-Language：浏览器当前设置的语言 Connection：浏览器与服务器之间连接的类型 Cookie：当前页面设置的任何Cookie Host：发出请求的页面所在的域 Referer：发出请求的页面的URL User-Agent：浏览器的用户代理字符串 常见的响应头 Date：表示消息发送的时间 server：服务器名称 Connection：浏览器与服务器之间连接的类型 Cache-Control：控制HTTP缓存 Content-type：表示后面的文档属于什么MIME类型 （1）application/x-www-form-urlencoded：浏览器的原生 form 表单，数据放在 body 里面，数据 key1=val1&amp;key2=val2 的方式进行编码 （2）multipart/form-data：通常上传文件时使用该种方式 （3）application/json：消息主体是序列化后的 JSON 字符串 （4）text/xml：主要用来提交 XML 格式的数据 3. http状态码304是多好还是少好搜索引擎蜘蛛会通过一定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。如果网站一定时间内一直处于304的状态，那么会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么回访率也会提高。 304意味着使用缓存，网站的加载速度会更快；但是过多304会导致网站的快照停止 网页快照是指搜索引擎在收录网页时，对网页进行备份，存在自己的服务器缓存里，当用户在搜索引擎中点击“网页快照”链接时，搜索引擎再将Spider系统当时抓取并保存的网页内容展现出来 4. 常见的http请求方法 GET:：向服务器获取数据； POST：将实体提交到指定的资源，通常会造成服务器资源的修改； PUT：上传文件，更新数据； DELETE：删除服务器上的对象； HEAD：获取报文首部，与GET相比，不返回报文主体部分； OPTIONS：询问支持的请求方法，用来跨域请求； CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信； TRACE: 回显服务器收到的请求，主要⽤于测试或诊断。 5. options请求的使用场景 获取服务器支持的所有HTTP请求方法； 用来检查访问权限，例如在进行CORS跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限 6. HTTP各个版本区别HTTP1.0和HTTP 1.1的区别 连接方面，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。使用持久连接来使多个http请求复用同一个TCP连接 资源请求方面，在http1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了；并且不支持断点续传功能。http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，返回码是 206（Partial Content） 缓存方面，在http1.0中主要使用If-Modified-Since、Expires来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Modified-Since、If-None-Match http1.1 中新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。 http1.1 相对于 http1.0 还新增了很多请求方法，如 PUT、HEAD、OPTIONS 等。 HTTP1.1和HTTP 2.0的区别 二进制协议：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。 多路复用： HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”的问题。 数据流： HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。 头部压缩： HTTP/2 实现了头部压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送字段，只发送索引号，这样就能提高速度了。 服务器推送： HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源。 HTTP3使用UDP+QUIC的方式，其中QUIC整合了TCP以及TLS握手过程 解决队头阻塞：减少请求的次数（精灵图）；域名分片，因为一个域名的连接数是有限的，所以划分多个子域名来处理请求，这些子域名指向同一台服务器；http/2解决队头阻塞只是应用层表面，然而还是基于传输层TCP的，收不到还是会要等待重传造成阻塞 7. HTTP和HTTPS协议的区别 HTTP是明文传输，而HTTPS则会对传输的内容加密（HTTP劫持） HTTP是80端口，HTTPS是443端口 8. 在浏览器中输入baidu.com并回车后发生了什么（1）解析URL： 首先会对 URL 进行解析，如果输入的 URL 不合法，将会把输入的内容传递给搜索引擎。如果没有问题，检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。 （2）缓存判断： 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。 （3）DNS解析： 下一步是将域名转化成 IP 地址，首先判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。 （4）获取MAC地址： 当浏览器得到 IP 地址后，数据链路层的数据传输还需要知道目的主机 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求的主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。 （5）TCP三次握手： 首先客户端向服务器发送一个 SYN 连接请求报文段，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。 （6）HTTPS握手： 首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。 （7）返回数据： 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。 （8）页面渲染： 浏览器的GUI渲染线程首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，如果没有则会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制，这时整个页面就显示出来了。 （9）TCP四次挥手： 最后一步是 TCP 断开连接的四次挥手过程。如果客户端认为数据发送完成，那么向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据，不过服务端仍旧可以发送数据给客户端，还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。 9. 长连接、短连接http1.0默认是短连接，在完成一次请求响应后就关闭连接；http1.1默认是长连接，完成一次请求响应后，TCP连接不会断开，下一次请求响应会复用这个连接，在保持期间，如果没有数据包发送，需要双方发送链接检测包 长连接适用于请求响应频繁、点对点的通讯，并且连接数不能太多，例如数据库的连接 短连接适用于例如电商web网站的请求响应服务，如果每个用户占用一个连接那么会很消耗后端资源 10. 请求/响应报文请求/响应行 请求/响应头 空行 请求/响应体 11. http2的首部压缩HPACK在http2连接过程中维护了一个首部表来跟踪存储发送过的键值对，对于相同数据不再发送，新的首部键值对会使用哈夫曼编码来压缩，要么追加到表的末尾，要么替换之前的值 12. url的组成 13. https在http的基础上使用ssl/tls来加密数据包，相比http具有身份验证（浏览器内置一些CA的数字证书，防止中间人攻击，）、信息加密（使用对称密钥加密，防止http劫持）、完整性校验（hash）的功能 建立连接过程 服务器把自己的公钥发给CA，CA使用自己的私钥进行数字签名（对证书内容进行hash得到摘要，指定了HASH算法）并返回公钥证书 客户端请求https连接，发送协议版本号、随机数A、客户端支持的加密方法，服务器返回公钥证书，随机数B 客户端拿到公钥证书后，使用浏览器内置的一些CA的公钥进行解密并对公钥证书HASH比对，确认消息没有被篡改，得到服务器的公钥 客户端生成随机数C，并用公钥进行加密，发给服务器 服务端使用私钥解密随机数C，至此，客户端和服务端都有了A、B、C 客户端和服务端使用约定好的加密算法加密ABC，生成对称密钥，之后就是对用对称密钥进行对称加密 14. 状态码100 continue（OPTION）、101 switch protocol（websocket）、200 ok、204 no content（响应报文没有响应体）、206 partial content（响应报文使用content-range指定实体内容的范围） 301 moved permanently（永久重定向，location字段指定新的URI，已保存的书签会根据这个新的URI更新书签） 302 found（临时重定向，未登录用户访问用户中心重定向到登录页面就是302） ​ 303 see other（和302比较相似，明确表示采用GET方法获取资源） ​ 307 temporary redirect（和302相似，不过不会从post转为get） 302是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码⼜出来了两个303和307 304 not modified（缓存） 400 bad request、401 unauthorized、403 forbidden、404 not found、405 method not allowed OPTION会返回Access-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE 500 internal server error、502 bad gateway、503 service unavailable、504 gateway timeout 15. 网络模型 16. UDP和TCP的区别、使用场景、优劣，如何让UDP更可靠区别 TCP面向连接，UDP是无连接的TCP在开始数据传输之前要经过三次握手，UDP却不需要任何准备即可进行数据传输，因此UDP不会引入建立连接的时延 TCP提供可靠的服务，UDP则是尽最大努力交付TCP传输数据具有重传机制，如果在传输数据的过程中发生丢包事件，发送方会重传丢失的数据以保证发送的数据一定能完整到达接收方，因此是可靠的。UDP在网络层不能保证数据传输的可靠性。（可以在应用层实现UDP数据传输的可靠性） UDP效率比TCP高UDP在传输数据前不需要建立连接，没有繁琐的握手过程，没有复杂的拥塞控制算法和重传机制，所以UDP相对于TCP具有较高的效率。 每一条TCP连接只能是点到点，UDP支持一对一、一对多、多对多 TCP对系统资源要求较多，UDP对系统资源要求较少TCP建立连接后，会为连接分配发送缓存和接受缓存，维护拥塞控制变量以及序号和确认号的参数，因此需要占用较多的系统资源。而UDP是无连接的，对系统资源要求较少 使用场景TCP：对网络通讯质量有要求时，例如整个数据要准确无误的传递给对方 FTP：文件传输协议 SSH：安全登录 Telnet：不安全文本传送 SMTP：简单邮件传输协议 HTTP：超文本传输协议 UDP：对网络通讯质量要求不高时，要求网络通讯速度能尽量的快 流媒体 如果采用TCP，一旦发生丢包，TCP会将后续包缓存起来，等前面的包重传并接收到后再继续发送（重传的数据会占用窗口大小），延迟会越来越大 实时游戏 自定义重传策略能把丢包产生的延迟降到最低 物联网 各自优缺点TCP优点：可靠、稳定 TCP缺点：慢、效率低、占用系统资源高、易被攻击（SYN Flood攻击） SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪 UDP优点：快、稍安全 UDP缺点：不可靠、不稳定 如何让UDP更可靠在上层应用层模仿TCP的可靠性传输 添加seq/ack机制，确保数据发送到对端 添加超时重传机制 17. UDP为什么不可靠不保证消息交付：不确认，不重传 不进行拥塞控制，不保证交付顺序 18. TCP重传超时重传机制、快重传、带选择的快重传 19. TCP拥塞控制机制–拥塞窗口慢启动 拥塞避免（？接下来） 快重传 快恢复 20. TCP流量控制机制–滑动窗口连接的两端有两个缓冲区，通过发送窗口通告，告知对方自己的缓冲区还能存多少，从而限制发送的数据量 21. TCP的可靠传输机制–ARQ协议和滑动窗口协议ARQ是指自动重传协议 22. TCP粘包A分别发送两个数据data1、data2给B，这两个数据TCP会先存放到缓冲区里再发送；如果B先收到data1的部分数据，然后再收到data1剩余部分数据和data2数据，那么就算是一种粘包 解决：关闭nagle算法，不缓冲直接发送；封包/拆包，在每个数据包前后放一些有特征的数据 为什么UDP不会粘包：UDP是面向消息的协议，每个数据包都是一条消息，接收的时候只能接受独立的消息","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://ydl8686.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"vue","slug":"面试-vue","date":"2023-03-21T07:09:32.000Z","updated":"2023-04-15T08:19:19.943Z","comments":true,"path":"posts/14980/","link":"","permalink":"http://ydl8686.github.io/posts/14980/","excerpt":"","text":"vue双向绑定vue的双向绑定是指数据和视图的修改会影响另外一方。 修改视图更新数据是通过addEventLisenter增加监听事件来实现的 修改数据更新视图是通过数据劫持和发布-订阅者模式实现的，vue2中通过Object.defineProperty方法来劫持各个属性，当触发对象属性的setter时，会通知订阅者触发相应的监听回调。主要流程如下 new Vue实例的时候会调用Observer和Compile，Observer来完成数据劫持（value丢失问题），Compile负责解析原先的dom，通过createDocumentFragment将要处理的dom放到临时内存里，统一处理后再append到vue挂载的dom上初始化视图 发布订阅者模式的实现和Dependency、Watcher两个类有关；Dependency维护了一个订阅者数组，以及两个方法：添加订阅者和通知数组内所有订阅者调用监听回调的方法。Watcher的构造函数则包含了监听的对象、监听的属性和属性发生修改的回调函数，对外暴露一个update方法给Dependency调用，内部再调用监听的回调函数 在Compile里会new Watcher ，不同的nodeType会有不同监听回调的Watcher，在Compile里告诉Watcher具体要的回调要怎么处理；new Watcher的时候会去访问对应的属性，为的是触发这个key的getter，在这个getter里将watcher加入到dependency的订阅数组里（为什么Dependency是在Observer里创建：确保当给key赋值一个对象类型的值时，这个值也有对应的Dependency）；setter则是负责调用dependency的notify computed和watch的区别computed是计算属性，他会根据其他属性的值计算结果，并且默认走缓存，只有当依赖的数据发生变化时才会重新计算。watch是监听器，负责监听数据，当监听的数据发生变化时就会触发相应的操作。 缓存方面，computed支持缓存，而watch不支持缓存 异步方面，computed中有异步操作时无法监听数据变化，而watch支持异步监听 v-if和v-show的区别实现上：v-if是动态的添加或者删除DOM元素，v-show则是通过设置元素的display样式属性控制显示隐藏 编译上：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，都会被编译生成DOM元素 性能上：v-if有更高的切换消耗，v-show有更高的初始渲染消耗 keep-alive的理解，如何实现，具体缓存的内容当一个组件在切换时需要保存状态防止多次渲染时，就可以使用keep-alive组件包裹 虚拟DOMVirtual Dom是一个JavaScript对象，包括tag、props、children属性，通过对象的方式来表示DOM结构，配合不同的渲染工具，使跨平台渲染成为可能，比如Node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟DOM 通过将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。当数据变化时，将现在的虚拟DOM会与缓存的虚拟DOM进行比较，vue内部封装了diff算法，通过这个算法来进行比较，渲染修改改变的变化，原先没有发生改变的则使用缓存。 无需手动操作DOM 首次渲染大量DOM时，由于多了一层虚拟DOM的计算，性能会稍差一些 虚拟DOM的解析过程首先对DOM树结构进行解析，使用js来模拟这个对象并保存下来，然后再把这个DOM插入到文档中 当页面发生变更，重新构建对象树，将新旧对象树进行diff比较，记录下差异patch对象，最后将ptach对象解析到真正的DOM树 具体来说，就是当数据发生变化时，通过劫持setter，让数据的Dependency去通知监听的Watcher，Watcher获取新的虚拟DOM执行patch，对比缓存的旧的虚拟DOM，如果sameVnode返回true，那么patchVnode进行后续对比子节点变化，如果vnode和oldVnode都有子节点并且子节点不一样，那么调用updateChildren更新子节点 diff算法原理diff中只对同层的子节点进行比较，放弃跨级的节点比较 首先，我们拿到新旧节点的数组，然后初始化四个指针，分别指向新旧节点的开始位置和结束位置，进行vNode的key的两两对比，相同则patchNode对比更新DOM 如果新的开始节点和旧开始节点相同，则都向后面移动，如果结尾节点相匹配，则都前移指针 如果新开始节点和旧结尾节点匹配上了，则会将旧的结束节点移动到旧的开始节点前 如果旧开始节点和新的结束节点相匹配，则会将旧开始节点移动到旧结束节点的后面 如果上述节点都没匹配上，则会进行一个兜底逻辑的判断，判断开始节点是否在旧节点中，若是存在则复用，若是不存在则在旧节点数组中创建 如果旧vnode先遍历完，就添加新vnode没有遍历的节点；如果新vnode先遍历完，就删除旧vnode没有遍历的节点 头对尾，尾对头的操作是因为可以通过reverse操作快速检测 vue3和vue2中diff的区别vue2是全量diff，vue3是静态标记+非全量diff vue3使用最长递增子序列优化了对比流程 key的作用在diff算法中更精确的找到相同节点，因此patch过程会非常高效 如果不使用key或者index作为key时，假设往列表中插入了一个新的元素，那么插入元素后面的元素的位置会发生变化，相比原来的虚拟DOM不再相同，所以全都会执行更新操作 vue-router如何实现懒加载箭头函数+importconst router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/list&#x27;, component: () =&gt; import(&#x27;@/components/list.vue&#x27;) &#125; ]&#125;) 箭头函数+requirecomponent: resolve =&gt; require([&#x27;@/components/list&#x27;], resolve) webpack的require.ensurecomponent: r =&gt; require.ensure([], () =&gt; r(require(&#x27;@/components/list&#x27;)), &#x27;list&#x27;) vue2和vue3的区别双向绑定使用的API不同；前者是Object.defineProperty，后者是Proxy object.defineProperty无法监听添加或删除对象的属性；本身也无法监听数组的push等方法，vue底层额外进行了处理，但是仍然无法监听到数组下标和长度的变化 Proxy直接代理整个对象而非对象的属性；可以监听数组的变化 vue2使用的是option API，vue3使用的是composition API diff算法不同；前者使用的是头尾节点对比，后者是最长递增子序列 生命周期钩子函数不同；前者是beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed；后者是setup、onBeforeMount、onMounted、onBeforeUpdate、onUpdated、onRenderTracked、onRenderTriggered","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://ydl8686.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"css","slug":"css","date":"2022-09-03T02:57:16.000Z","updated":"2023-04-15T08:20:40.282Z","comments":true,"path":"posts/19784/","link":"","permalink":"http://ydl8686.github.io/posts/19784/","excerpt":"","text":"1. 度量单位em、rem、vh、vw、%em相对长度单位，相对于当前对象内文本的字体尺寸，根据父元素的font-size大小变化而变化 rem相对长度单位，相对于根元素（即html元素）font-size的倍数，不会被它的父元素影响 rem布局的本质是等比缩放大屏用户需要有选择要更大字体或者更多内容的自由，如果使用rem布局，那么用户就只能被迫接受更大字体 vh和vwviewport height和viewport width，对应的是window.innerHeight和window.innerWidth，把浏览器导航栏下方到浏览器下方的距离化成了100份 %相对于父元素的大小 2. rem布局加载闪烁问题在使用rem布局时可能会出现加载闪烁的问题，也就是在加载的时候会出现元素一开始很小，闪烁后恢复正常大小的情况；这是因为引入的js文件中有修改font-size的部分，阻塞了后续的DOM解析和渲染；此时前面的DOM可以被正确地解析及渲染，所以会出现元素很小的情况，之后js解析完成后，元素恢复正常大小可以使用媒体查询来设置html元素的font-size；这样dom还没有渲染完但是已经可以正常展现的时候，显示的元素大小也是正确的 https://blog.csdn.net/u013778905/article/details/77938784https://yanhaijing.com/css/2017/09/29/principle-of-rem-layout/ 3. position中的relative和absoluterelative 相对于原来位置移动，设置后元素仍然处于文档流中，可能会撑大容器 absolute 元素会脱离文档流，没有设置偏移量的话就还在原来的位置，会影响其他元素的位置定位 在父元素没有设置相对定位(relative)或绝对定位(absolute+fixed)的情况下，元素相对于html元素偏移 父元素设置了相对定位或绝对定位后，元素会相对于离自己最近的设置了相对或绝对定位的父元素进行定位 https://www.runoob.com/w3cnote/css-position-static-relative-absolute-fixed.html 4. 三栏布局实现 grid布局.container &#123; display: grid; grid-template-columns: 100px auto 200px;&#125; flex布局.container &#123; display: flex;&#125;.item1 &#123; height: 60vh; width: 100px;&#125;.item2 &#123; height: 130vh; flex: 1 0 auto;&#125;.item3 &#123; height: 80vh; width: 240px;&#125; 浮动+BFC.column1 &#123; float: left; width: 100px; height: 300px; background-color: green;&#125;.column2 &#123; float: right; width: 100px; height: 300px; background-color: green;&#125;.column3 &#123; overflow: hidden; /*创建bfc*/ height: 300px; background-color: red;&#125; 5. BFC块级格式化上下文，其中格式化上下文是指页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用 高度塌陷：在文档流中，父元素的高度默认是被子元素撑开的，但是子元素设置成浮动后，子元素会脱离文档流，导致子元素无法撑起父元素的高度可以将父元素高度写死防止高度塌陷的问题，但是一旦高度写死，父元素的高度将不能自动适应子元素的高度 形成BFC的条件 浮动元素 position(absolute、fixed) display为inline-block，table-cell，table-caption overflow除了visible以外的值","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://ydl8686.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"📖算法 | 剑指offer","slug":"剑指offer算法","date":"2022-01-17T08:50:36.000Z","updated":"2023-03-03T08:54:04.000Z","comments":true,"path":"posts/30446/","link":"","permalink":"http://ydl8686.github.io/posts/30446/","excerpt":"","text":"03 数组中重复的数字 解法1使用数据结构Set，利用其不会储存相同元素的特性来解决，不断往里面添加元素，看看Set大小有没有变，没变说明添加的就是重复的元素 var findRepeatNumber = function(nums) &#123; let mySet = new Set(); let size = mySet.size; let result = -1; nums.some(e =&gt; &#123; mySet.add(e); if(mySet.size === size) &#123; result = e; return true; &#125; size+=1; &#125;) return result;&#125;; 需要注意的是，在遍历数组nums的时候，不能采用forEach里return结果的方式，因为这样并不会跳出循环，break也是一样的；可以使用some和every方法来实现可跳出的循环，前者return true时跳出，后者return false跳出 解法2可以使用原地交换的方式，因为题目中说长度为n的数组，元素大小在[0,n-1]，有重复元素，那么在建立索引和值的对应关系上，一定会出现某个索引对应了两个值的情况，该值就是重复的元素 var findRepeatNumber = function(nums) &#123; let i=0; while(true)&#123; if(nums[i] !== i)&#123; /*防止出现1，1，1的情况*/ if(nums[nums[i]] === nums[i])&#123; return nums[i]; &#125; /*交换*/ [nums[nums[i]], nums[i]] =[nums[i], nums[nums[i]]]; &#125; else &#123; i++; &#125; &#125;&#125;; 04 二维数组中的查找 因为每行、每列都是递增顺序排列的，所以可以从右上角开始，如果当前数组中的数比target大，那么往左移；小，那么往下移；终止循环的条件是索引越界 var findNumberIn2DArray = function(matrix, target) &#123; let i = 0; let j = matrix[0].length-1; while(true) &#123; if(i&gt;matrix.length-1 || j&lt;0) &#123; return false; &#125; if(target === matrix[i][j]) &#123; return true; &#125; if(matrix[i][j] &gt; target) &#123; j--; &#125; else if(matrix[i][j] &lt; target) &#123; i++; &#125; &#125;&#125;; 05 替换空格 使用js的常用API就可以解决 // 法一var replaceSpace = function(s) &#123; return s.split(&#x27; &#x27;).join(&#x27;%20&#x27;);&#125;;// 法二var replaceSpace = function(s) &#123; // 必须要有g，不然只会替换第一个 return s.replace(/\\s/g, &#x27;%20&#x27;);&#125;; str.replace(/^\\s+|\\s+$/g, &#39;haloha&#39;)\\s : 表示 space ，空格+： 一个或多个^： 开始，^\\s，以空格开始$： 结束，\\s$，以空格结束|： 或者/g：global， 全局 06 从尾到头打印链表 先顺序遍历，把结果放到数组里，再reverse一下；或者使用unshift() /** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;number[]&#125; */// 法一var reversePrint = function(head) &#123; let result = []; while(head) &#123; result.push(head.val); head = head.next; &#125; result.reverse(); return result;&#125;;// 法二var reversePrint = function(head) &#123; let result = []; while(head) &#123; /*在数组首位置添加元素*/ result.unshift(head.val); head = head.next; &#125; return result;&#125;; 07 重建二叉树 核心是递归，根据preorder里的第一个元素，可以把inorder划分成左子树和右子树，再根据inoder里子树的大小，将preorder里划分成左子树和右子树，然后对应的进行递归操作即可 /** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;number[]&#125; preorder * @param &#123;number[]&#125; inorder * @return &#123;TreeNode&#125; */var buildTree = function(preorder, inorder) &#123; let result = new TreeNode(preorder[0]); // 特殊情况 // if(preorder.length === 1)&#123; // return result; // &#125; // else if(preorder.length === 0)&#123; // return null; // &#125; let index = inorder.indexOf(preorder[0]); result.left = buildTree(preorder.slice(1, 1+index), inorder.slice(0, index)); result.right = buildTree(preorder.slice(1+index), inorder.slice(index+1)); return result;&#125;; 10 斐波那契数列 解法1（动态规划）使用最简单的递归方法，，果然超时了，函数的入栈出栈的时间成本还是太高了，所以用了最简单的迭代，不过空间复杂度是O(N)，比较占用内存 var fib = function(n) &#123; if(n === 0 || n === 1) &#123; return n; &#125; let arr = [0, 1]; for(let i=2; i&lt;=n; i++) &#123; arr[i] = (arr[i-1] + arr[i-2])%1000000007; &#125; return arr[n];&#125;;// 还可以继续优化，因为n只与n-1，n-2有关，所以可以将空间复杂度降至O（1） 解法2使用递归的同时，再开辟一个新的数组用来存储已经算过的项，避免重复；例如算n-1和n-2这两项的时候都会用到第n-3项。所以在使用某一项的时候先看看这个数组里面有没有值，没有值再递归计算赋值 不过这样时间复杂度和空间复杂度都好高啊，还是使用动态规划最好 青蛙跳台阶也可以转换成类似的想法，关键是得到f(n)=f(n-1)+f(n-2)这个不变式 11 旋转数组的最小数字 线性遍历数组，发现后一个比前一个小，那么后一个就是答案；如果遍历完都没找到就说明这个数组是升序排列，返回第一个就好；时间复杂度O（N） var minArray = function(numbers) &#123; for(let i=0;i&lt;numbers.length-1;i++)&#123; if(numbers[i+1] &lt; numbers[i])&#123; return numbers[i+1]; &#125; &#125; return numbers[0]&#125;; 12 矩阵中的路径🌟 回溯 本题的思路核心是回溯，每次判断完一条路径是否符合条件后，要及时把状态恢复，以便其他条件递归 var exist = function(board, word) &#123; for(let i=0;i&lt;board.length;i++)&#123; for(let j=0;j&lt;board[0].length;j++)&#123; // 特殊情况，要判断的word只有一个字符 if(word.length===1 &amp;&amp; board[i][j]===word.charAt(0))&#123; return true; &#125; else if(board[i][j]===word.charAt(0))&#123; if(help(board,word.substring(1),i,j))&#123; return true; &#125; &#125; &#125; &#125; return false;&#125;;// 用来判断某一个字符是否存在符合条件的下一个字符var help = (board, word, i, j) =&gt; &#123; // 用来记录i,j位置的元素，用来回溯 let temp=board[i][j]; // 确保不会出现重复使用的情况 board[i][j]=&#x27;0&#x27;; let target = word.charAt(0); let signal1=false; let signal2=false; let signal3=false; let signal4=false; let res1=false; let res2=false; let res3=false; let res4=false; // 判断四个方向是否可行，并分别进行递归判断 if(j+1&lt;board[0].length &amp;&amp; board[i][j+1]===target)&#123; signal1=true; res1=help(board, word.substring(1),i,j+1); &#125; if(i+1&lt;board.length &amp;&amp; board[i+1][j]===target)&#123; signal2=true; res2=help(board, word.substring(1),i+1,j); &#125; if(j-1&gt;=0 &amp;&amp; board[i][j-1]===target)&#123; signal3=true; res3=help(board, word.substring(1),i,j-1); &#125; if(i-1&gt;=0 &amp;&amp; board[i-1][j]===target)&#123; signal4=true; res4=help(board, word.substring(1),i-1,j); &#125; // 当前状态的恢复 board[i][j]=temp; // 结果判定 if(word.length===1 &amp;&amp; (signal1||signal2||signal3||signal4))&#123; return true; &#125; else if(signal1||signal2||signal3||signal4)&#123; return res1||res2||res3||res4; &#125; else&#123; return false; &#125;&#125; 19 删除链表的倒数第 N 个结点 var removeNthFromEnd = function(head, n) &#123; let p=head; let target=head; for(let i=0;i&lt;n-1;i++)&#123; p=p.next; &#125; let pre=head; while(p.next)&#123; pre=target; p=p.next; target=target.next; &#125; /** 特殊情况，要删除的节点是头节点 链表只有一个元素，删除这个元素也可以归为上面👆“要删除的节点是头节点”这一类 **/ if(head===target)&#123; return target.next; &#125; pre.next=target.next; return head;&#125;; 29 顺时针打印矩阵 var spiralOrder = function(matrix) &#123; let result=[]; // 判断数组是否为空 // 不能[]===[] //false if(matrix.length===0)&#123; return result; &#125; help(matrix,result,0,0,matrix[0].length-1,matrix.length-1); return result;&#125;;let help=(matrix,result,l,t,r,b)=&gt;&#123; if(l===r &amp;&amp; t===b)&#123; result.push(matrix[t][l]); return; &#125; if(l&gt;r || t&gt;b)&#123; return; &#125; if(l&lt;r &amp;&amp; t==b)&#123; for(let i=l;i&lt;=r;i++)&#123; result.push(matrix[t][i]); &#125; &#125; else if(t&lt;b &amp;&amp; l==r)&#123; for(let i=t;i&lt;=b;i++)&#123; result.push(matrix[i][r]); &#125; &#125; else&#123; for(let i=l;i&lt;=r;i++)&#123; result.push(matrix[t][i]); &#125; for(let i=t+1;i&lt;=b;i++)&#123; result.push(matrix[i][r]); &#125; for(let i=r-1;i&gt;=l;i--)&#123; result.push(matrix[b][i]); &#125; for(let i=b-1;i&gt;t;i--)&#123; result.push(matrix[i][l]); &#125; &#125; l++; t++; r--; b--; help(matrix,result,l,t,r,b);&#125; 38 字符串的排列🌟 回溯 考察的是DFS+回溯，回溯体现在数组和字符串上，需要注意的是当字符串只有一个字符时的特殊情况 // 数组在某个index添加删除元素var permutation = function(s) &#123; if(!s)&#123; return []; &#125; let strArr=s.split(&#x27;&#x27;); let result=new Set(); let temp=&#x27;&#x27;; for(let i=0;i&lt;strArr.length;i++)&#123; temp+=strArr[i]; let char=strArr[i]; let charIndex=strArr.indexOf(char); strArr.splice(charIndex,1); help(strArr,result,temp); temp=temp.substring(0,temp.length-1); strArr.splice(charIndex,0,char); &#125; return Array.from(result);&#125;;let help=(strArr,result,temp)=&gt;&#123; // 两种情况 if(strArr.length===0)&#123; result.add(temp); return ; &#125; if(strArr.length===1)&#123; temp+=strArr[0]; result.add(temp); return ; &#125; else&#123; for(let i=0;i&lt;strArr.length;i++)&#123; temp+=strArr[i]; let char=strArr[i]; let charIndex=strArr.indexOf(char); strArr.splice(charIndex,1); help(strArr,result,temp); temp=temp.substring(0,temp.length-1); strArr.splice(charIndex,0,char); &#125; &#125;&#125; 44 数字序列中某一位的数字 找规律，计算不同位数占用索引的多少，倒推给定的n属于哪一个数，然后找到对应的某一位即可 var findNthDigit = function(n) &#123; if(n&lt;10)&#123; return n; &#125; let i=1; // i表示n所在数字的位数 let cp=n; while(cp-(Math.pow(10,i)-Math.pow(10,i-1))*i&gt;0)&#123; cp=cp-(Math.pow(10,i)-Math.pow(10,i-1))*i; i++; &#125; cp=cp-1; let t=Math.floor(cp/i); let m=cp%i; let tempResult=Math.pow(10,i-1)+t; return (tempResult+&#x27;&#x27;).charAt(m);&#125;; 50 第一个只出现一次的字符 解法1用两个数组来解决这个问题，一个数组用来存储遍历过的字符，一个数组用来存储已经重复过的的字符；遍历时遇到的字符在这两个数组内都没有出现时，进入第一个数组；如果在第一个数组中出现了，那么从第一个数组中剔除，并加入第二个数组；其余情况都不用考虑 不过好像其实也没有降低时间复杂度，因为使用到了indexOf来查找重复字符的索引，如果让自己来实现的话，又是O(N)的复杂度，综合下来还是O(N2)时间复杂度 var firstUniqChar = function(s) &#123; if(!s)&#123; return &#x27; &#x27;; &#125; let temp = []; let dupTemp = []; for(let i=0;i&lt;s.length;i++)&#123; if(dupTemp.indexOf(s[i]) === -1 &amp;&amp; temp.indexOf(s[i]) === -1)&#123; temp.push(s[i]); &#125; else if(temp.indexOf(s[i]) !== -1)&#123; temp.splice(temp.indexOf(s[i]), 1); dupTemp.push(s[i]); &#125; &#125; return temp[0]?temp[0]:&#x27; &#x27;;&#125;; 解法2使用map来解决；需要注意到的是，map对象是乱序的；但是按照key,value的形式来遍历时，是按照插入的顺序进行的 var firstUniqChar = function(s) &#123; var map = new Map(); for(let i=0;i&lt;s.length;i++)&#123; var cur = s.charAt(i); if(map.has(cur))&#123; // 如果已经出现过这个字符，那么设为false map.set(cur,false); &#125; else &#123; // 第一次遇到设置成true map.set(cur,true); &#125; &#125; for([key,value] of map)&#123; if(value)&#123; return key; &#125; &#125; return &#x27; &#x27;&#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://ydl8686.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"js常用API","slug":"js算法常用API","date":"2021-03-24T06:05:09.000Z","updated":"2023-02-13T07:52:54.000Z","comments":true,"path":"posts/14402/","link":"","permalink":"http://ydl8686.github.io/posts/14402/","excerpt":"总结了一些比较常用的数据结构以及对应的API","text":"总结了一些比较常用的数据结构以及对应的API 常用数据结构Arrayjs数组里面的元素类型可以都不一样 var a=new Array()var a=[1,2,3]a.length //NumberArray.isArray(a) //truea.toString() //返回数组的字符串形式&quot;1,2,3&quot;a.push(value,vlaue....) //在数组的末端添加一个或多个元素，并返回添加后的数组长度。pop() //用于删除数组的最后一个元素，并返回该元素shift() //用于删除数组的第一个元素，并返回该元素unshift(value) //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。join() //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。concat() //将参数数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。reverse() //用于颠倒数组中元素的顺序，改变了原数组slice(start_index, upto_index); //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。splice(index, count_to_remove, addElement1, addElement2, ...); //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。sort() //对原数组成员进行排序，默认是按照字典顺序排序。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。map() //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。forEach() //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。filter() //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。some() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。every() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。reduce() //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员）reduceRight() //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员）indexOf(s) //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置lastIndexOf(s) //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。 map//传入函数的形式不同a.map((x)=&gt;&#123; return -x;&#125;) //把a数组里的所有元素取反，返回新数组a.map(function(x)&#123; return Math.abs(x)&#125;) //取绝对值 forEacha.forEach((x,y,z)=&gt;&#123; console.log(x,y,z)&#125;)// forEach中不能使用break或return来跳出循环// 可以使用some和every方法来实现可跳出的循环，前者return true时跳出，后者return false跳出 filterarr.filter(x=&gt;&#123; if(x===&#x27;2&#x27;)&#123; return true &#125; else&#123; return false &#125;&#125;) //把符合条件的元素返回组成一个新数组 some/everyarr.some(x=&gt;&#123; if(x===&#x27;2&#x27;)&#123; return true &#125; else&#123; return false &#125;&#125;) //arr[1,2,&#x27;1&#x27;,&#x27;2&#x27;] truearr.every(x=&gt;&#123; if(x===&#x27;2&#x27;)&#123; return true &#125; else&#123; return false &#125;&#125;) //false reduce//z是索引，w是原数组t.reduce((x,y,z,w)=&gt;&#123; console.log(z) // 1 2 return x*y;&#125;) //arr[1,2,3] 6t.reduce((x,y,z,w)=&gt;&#123; console.log(z) // 0 1 2 return x*y;&#125;,0) 0 Stringvar s=new String()var s=&quot;12345&quot;var str=String.fromCharCode(97); //str=&#x27;a&#x27;s.lengths.chatAt(index) //返回指定位置的字符s.concat(s2) //返回新的连接后的字符串s.slice(start,end) //用于从原字符串取出子字符串并返回新字符串，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。s.substring(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。s.substr(start,length) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。s.indexOf(s) //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 s.lastIndexOf() //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。s.trim() //用于去除字符串两端的空格，返回一个新字符串s.toLowerCase() //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。s.toUpperCase() //全部转为大写s.localeCompare(s2) //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。s.match(regexp) //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。s.search() //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。s.replace(oldValue,newValue) //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。s.split() //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。 Mapvar m = new Map(); // 空Mapm.set(&#x27;Adam&#x27;, 67); // 添加新的key-valuem.has(&#x27;Adam&#x27;); // 是否存在key &#x27;Adam&#x27;: truem.get(&#x27;Adam&#x27;); // 67m.delete(&#x27;Adam&#x27;); // 删除key &#x27;Adam&#x27;//遍历mapfor([key,value] of map)&#123; console.log(key,value)&#125; Setvar s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3, 3]); // &#123;1, 2, 3&#125;s.add(4);s; // Set &#123;1, 2, 3, 4&#125;s.delete(3);s; // Set &#123;1, 2, 4&#125;s.size; // 3s.has(2); // true 常用方法进制转换var value = parseInt(12).toString(2); //parsetInt里面是要转换的数字，toString里面是要转换的进制，如果要转换为其他进制，替换掉就好了 判断变量类型判断变量类型一般用typeof就可以了 声明相同元素数组new Array(100).fill(1)数组长度为100，每个元素都是1 声明固定长宽的二维数组/** * 10列10行 **/let arr = new Array(10);for(let i = 0;i &lt; arr.length; i++)&#123; arr[i] = new Array(10).fill(0);&#125; 遍历Array、Map、SetArray可以使用下标，Map和Set不能使用下标，ES6引入了iterable类型，Array,Map,Set都属于iterable类型，它们可以使用for…of循环来遍历 let a = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;];let s = new Set([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]);let m = new Map([[1, &#x27;x&#x27;], [2, &#x27;y&#x27;], [3, &#x27;z&#x27;]]);for (let x of a) &#123; log(x); &#125;for (let x of s) &#123; log(x);&#125;for (let x of m) &#123; log(x[0] + &#x27;=&#x27; + x[1]); // 分别是key和value&#125; 字符与ASCII码互转将字符转为ascii码 let char=&#x27;a&#x27;;let num=str.charCodeAt(); // 97 将ascii码转为对应字符 let num=97;let char=String.fromCharCode(num); 小数取整向上取整Math.ceil(3/2) //2 向下取整Math.floor(3/2) //1 四舍五入取整Math.round(3/2) //2 数组索引处添加/删除都是对原数组进行操作删除arr.splice(index, 1)添加arr.splice(index, 0, content)","categories":[],"tags":[{"name":"API","slug":"API","permalink":"http://ydl8686.github.io/tags/API/"}]},{"title":"快捷键","slug":"快捷键","date":"2021-03-24T02:57:01.000Z","updated":"2022-12-31T04:05:37.000Z","comments":true,"path":"posts/20356/","link":"","permalink":"http://ydl8686.github.io/posts/20356/","excerpt":"","text":"mac1.ctrl+左/右：切换左右桌面2.ctrl+command+q：锁屏 mac下的chrome1.command+n：打开新窗口2.command+t：打开新标签页3.command+option+左/右：切换前/后标签页4.command+w：关闭当前标签页 mac下的vscode1.ctrl+反引号：显示终端2.command+ctrl+f：全屏/退出全屏3.option+点击：插入多个光标4.command+i：选中当前行5.command+shift+k：删除当前行6.option+上/下：移动上下行7.command+enter：下一行插入8.command+shift+enter：上一行插入9.shift+option（ALT）+f：格式化代码","categories":[],"tags":[{"name":"实用技巧","slug":"实用技巧","permalink":"http://ydl8686.github.io/tags/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}]}],"categories":[],"tags":[{"name":"vue3","slug":"vue3","permalink":"http://ydl8686.github.io/tags/vue3/"},{"name":"面试","slug":"面试","permalink":"http://ydl8686.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"算法","slug":"算法","permalink":"http://ydl8686.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"API","slug":"API","permalink":"http://ydl8686.github.io/tags/API/"},{"name":"实用技巧","slug":"实用技巧","permalink":"http://ydl8686.github.io/tags/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"}]}