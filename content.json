{"meta":{"title":"Ydl's Blog","subtitle":null,"description":"待葡萄成熟透","author":"Ydl","url":"http://ydl8686.github.io","root":"/"},"pages":[{"title":"About","date":"2021-05-06T12:20:17.862Z","updated":"2021-05-06T12:20:17.861Z","comments":true,"path":"about/index.html","permalink":"http://ydl8686.github.io/about/index.html","excerpt":"","text":""},{"title":"","date":"2021-02-18T11:22:01.123Z","updated":"2021-02-18T11:22:01.123Z","comments":true,"path":"photos/data.json","permalink":"http://ydl8686.github.io/photos/data.json","excerpt":"","text":"{\"list\":[{\"date\":\"2021-2-\",\"arr\":{\"year\":2021,\"month\":2,\"link\":[\"2021-2-17_狼小魂大大.JPG\",\"2021-2-18_最近真的很爱浩浩和介叔啊.JPG\",\"2021-2-18_要吃冰淇淋么.JPG\"],\"text\":[\"狼小魂大大\",\"最近真的很爱浩浩和介叔啊\",\"要吃冰淇淋么\"],\"type\":[\"image\",\"image\",\"image\"]}}]}"},{"title":"相册","slug":"photos","date":"2021-02-18T08:39:30.229Z","updated":"2021-02-18T08:39:30.229Z","comments":false,"path":"photos/index.html","permalink":"http://ydl8686.github.io/photos/index.html","excerpt":"","text":"Photos 图片正在加载中… (function() { var loadScript = function(path) { var $script = document.createElement('script') document.getElementsByTagName('body')[0].appendChild($script) $script.setAttribute('src', path) } setTimeout(function() { loadScript('./ins.js') }, 0) })()"},{"title":"","date":"2021-02-18T08:39:30.229Z","updated":"2021-02-18T08:39:30.229Z","comments":true,"path":"photos/ins.css","permalink":"http://ydl8686.github.io/photos/ins.css","excerpt":"","text":"#post-instagram{ padding: 30px; } #post-instagram .article-entry{ padding-right: 0; } .instagram{ background-color:#F5FFFF; position: relative; min-height: 500px; } .instagram img { width: 100%; } .instagram .year { font-size: 16px; } .instagram .open-ins{ padding: 10px 0; color: #cdcdcd; } .instagram .open-ins:hover{ color: #657b83; } .instagram .year{ display: inline; } .instagram .thumb { width: 25%; height: 0; padding-bottom: 25%; position: relative; display: inline-block; text-align: center; background: #ededed; outline: 1px solid #ddd; } .instagram .thumb a { position: relative; } .instagram .album h1 em{ font-style: normal; font-size: 14px; margin-left: 10px; } .instagram .album ul{ display: flex; flex-wrap: wrap; clear: both; width: 100%; text-align: left; } .instagram .album li{ list-style: none; display: inline-block; box-sizing: border-box; padding: 0 5px; margin-bottom: -10px; height: 0; width: 25%; position: relative; padding-bottom: 25%; } .instagram .album li:before{ display: none; } .instagram .album div.img-box{ position: absolute; width: 90%; height: 90%; -webkit-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); -moz-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); } .instagram .album div.img-box img{ width: 100%; height: 100%; position: absolute; z-index: 2; } .instagram .album div.img-box .img-bg{ position: absolute; top: 0; left: 0; bottom: 0px; width: 100%; margin: -5px; padding: 5px; -webkit-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -moz-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -webkit-transition: all 0.15s ease-out 0.1s; -moz-transition: all 0.15s ease-out 0.1s; -o-transition: all 0.15s ease-out 0.1s; transition: all 0.15s ease-out 0.1s; opacity: 0.2; cursor: pointer; display: block; z-index: 3; } .instagram .album div.img-box .icon { font-size: 14px; position: absolute; left: 50%; top: 50%; margin-left: -7px; margin-top: -7px; color: #999; z-index: 1; } .instagram .album div.img-box .img-bg:hover{ opacity: 0; } .photos-btn-wrap { border-bottom: 1px solid #e5e5e5; margin-bottom: 20px; } .photos-btn { font-size: 16px; color: #333; margin-bottom: -4px; padding: 5px 8px 3px; } .photos-btn.active { color: #08c; border: 1px solid #e5e5e5; border-bottom: 5px solid #fff; } @media screen and (max-width:600px) { .instagram .thumb { width: 50%; padding-bottom: 50%; } .instagram .album li { width: 100%; position: relative; padding-bottom: 100%; text-align: center; } .instagram .album div.img-box{ margin: 0; width: 90%; height: 90%; } }"},{"title":"","date":"2021-02-18T08:49:06.952Z","updated":"2021-02-18T08:39:30.229Z","comments":true,"path":"photos/ins.js","permalink":"http://ydl8686.github.io/photos/ins.js","excerpt":"","text":"/******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports; /******/ /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ exports: {}, /******/ id: moduleId, /******/ loaded: false /******/ }; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.loaded = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = \"/dist/\"; /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(0); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(1); var _view = __webpack_require__(2); var _view2 = _interopRequireDefault(_view); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } /** * @name impush-client * @description 这个项目让我发家致富… * @date 2016-12-1 */ var _collection = []; var _count = 0; var searchData; function addMask(elem) { var rect = elem.getBoundingClientRect(); var style = getComputedStyle(elem, null); var mask = document.createElement('i'); mask.className = 'icon-film'; mask.style.color = '#fff'; mask.style.fontSize = '26px'; mask.style.position = 'absolute'; mask.style.right = '10px'; mask.style.bottom = '10px'; mask.style.zIndex = 1; elem.parentNode.appendChild(mask); } var createVideoIncon = function createVideoIncon() { var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]'); for (var i = 0, len = $videoImg.length; i < len; i++) { addMask($videoImg[i]); } }; var render = function render(res) { var ulTmpl = \"\"; for (var j = 0, len2 = res.list.length; j < len2; j++) { var data = res.list[j].arr; var liTmpl = \"\"; for (var i = 0, len = data.link.length; i < len; i++) { var minSrc = 'https://raw.githubusercontent.com/ydl8686/Blog-Back-Up/master/min_photos/' + data.link[i]; var src = 'https://raw.githubusercontent.com/ydl8686/Blog-Back-Up/master/photos/' + data.link[i]; var type = data.type[i]; var target = src + (type === 'video' ? '.mp4' : '.jpg'); src += ''; liTmpl += '\\ \\ \\ \\ ' + data.text[i] + '\\ '; } ulTmpl = ulTmpl + '' + data.year + '年' + data.month + '月\\ ' + liTmpl + '\\ '; } document.querySelector('.instagram').innerHTML = '' + ulTmpl + ''; createVideoIncon(); _view2.default.init(); }; var replacer = function replacer(str) { var arr = str.split(\"/\"); return \"/assets/ins/\" + arr[arr.length - 1]; }; var ctrler = function ctrler(data) { var imgObj = {}; for (var i = 0, len = data.length; i < len; i++) { var y = data[i].y; var m = data[i].m; var src = replacer(data[i].src); var text = data[i].text; var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m); if (imgObj[key]) { imgObj[key].srclist.push(src); imgObj[key].text.push(text); } else { imgObj[key] = { year: y, month: m, srclist: [src], text: [text] }; } } render(imgObj); }; function loadData(success) { if (!searchData) { var xhr = new XMLHttpRequest(); xhr.open('GET', './data.json?t=' + +new Date(), true); xhr.onload = function() { if (this.status >= 200 && this.status < 300) { var res = JSON.parse(this.response); searchData = res; success(searchData); } else { console.error(this.statusText); } }; xhr.onerror = function() { console.error(this.statusText); }; xhr.send(); } else { success(searchData); } } var Ins = { init: function init() { loadData(function(data) { render(data); }); } }; Ins.init(); // export default impush; /***/ }, /* 1 */ /***/ function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */ (function(global) { 'use strict'; var inViewport = __webpack_require__(3); var lazyAttrs = ['data-src']; global.lzld = lazyload(); // Provide libs using getAttribute early to get the good src // and not the fake data-src replaceGetAttribute('Image'); replaceGetAttribute('IFrame'); function registerLazyAttr(attr) { if (indexOf.call(lazyAttrs, attr) === -1) { lazyAttrs.push(attr); } } function lazyload(opts) { opts = merge({ 'offset': 333, 'src': 'data-src', 'container': false }, opts || {}); if (typeof opts.src === 'string') { registerLazyAttr(opts.src); } var elts = []; function show(elt) { var src = findRealSrc(elt); if (src) { elt.src = src; } elt.setAttribute('data-lzled', true); elts[indexOf.call(elts, elt)] = null; } function findRealSrc(elt) { if (typeof opts.src === 'function') { return opts.src(elt); } return elt.getAttribute(opts.src); } function register(elt) { elt.onload = null; elt.removeAttribute('onload'); elt.onerror = null; elt.removeAttribute('onerror'); if (indexOf.call(elts, elt) === -1) { inViewport(elt, opts, show); } } return register; } function replaceGetAttribute(elementName) { var fullname = 'HTML' + elementName + 'Element'; if (fullname in global === false) { return; } var original = global[fullname].prototype.getAttribute; global[fullname].prototype.getAttribute = function(name) { if (name === 'src') { var realSrc; for (var i = 0, max = lazyAttrs.length; i < max; i++) { realSrc = original.call(this, lazyAttrs[i]); if (realSrc) { break; } } return realSrc || original.call(this, name); } // our own lazyloader will go through theses lines // because we use getAttribute(opts.src) return original.call(this, name); }; } function merge(defaults, opts) { for (var name in defaults) { if (opts[name] === undefined) { opts[name] = defaults[name]; } } return opts; } // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html function indexOf(value) { for (var i = this.length; i-- && this[i] !== value;) {} return i; } module.exports = lazyload; // export default impush; /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ }, /* 2 */ /***/ function(module, exports) { 'use strict'; var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) { // parse slide data (url, title, size ...) from DOM elements // (children of gallerySelector) var parseThumbnailElements = function parseThumbnailElements(el) { el = el.parentNode.parentNode; var thumbElements = el.getElementsByClassName('thumb'), numNodes = thumbElements.length, items = [], figureEl, linkEl, size, type, // video or not target, item; for (var i = 0; i < numNodes; i++) { figureEl = thumbElements[i]; // // include only element nodes if (figureEl.nodeType !== 1) { continue; } linkEl = figureEl.children[0]; // size = linkEl.getAttribute('data-size').split('x'); type = linkEl.getAttribute('data-type'); target = linkEl.getAttribute('data-target'); // create slide object item = { src: linkEl.getAttribute('href'), w: parseInt(size[0], 10), h: parseInt(size[1], 10) }; if (figureEl.children.length > 1) { item.title = figureEl.children[1].innerHTML; } if (linkEl.children.length > 0) { item.msrc = linkEl.children[0].getAttribute('src'); item.type = type; item.target = target; item.html = ''; if (type === 'video') { //item.src = null; } } item.el = figureEl; // save link to element for getThumbBoundsFn items.push(item); } return items; }; // find nearest parent element var closest = function closest(el, fn) { return el && (fn(el) ? el : closest(el.parentNode, fn)); }; // triggers when user clicks on thumbnail var onThumbnailsClick = function onThumbnailsClick(e) { e = e || window.event; e.preventDefault ? e.preventDefault() : e.returnValue = false; var eTarget = e.target || e.srcElement; // find root element of slide var clickedListItem = closest(eTarget, function(el) { return el.tagName && el.tagName.toUpperCase() === 'FIGURE'; }); if (!clickedListItem) { return; } // find index of clicked item by looping through all child nodes // alternatively, you may define index via data- attribute var clickedGallery = clickedListItem.parentNode, // childNodes = clickedListItem.parentNode.childNodes, // numChildNodes = childNodes.length, childNodes = document.getElementsByClassName('thumb'), numChildNodes = childNodes.length, nodeIndex = 0, index; for (var i = 0; i < numChildNodes; i++) { if (childNodes[i].nodeType !== 1) { continue; } if (childNodes[i] === clickedListItem) { index = nodeIndex; break; } nodeIndex++; } if (index >= 0) { // open PhotoSwipe if valid index found openPhotoSwipe(index, clickedGallery); } return false; }; // parse picture index and gallery index from URL (#&pid=1&gid=2) var photoswipeParseHash = function photoswipeParseHash() { var hash = window.location.hash.substring(1), params = {}; if (hash.length < 5) { return params; } var vars = hash.split('&'); for (var i = 0; i < vars.length; i++) { if (!vars[i]) { continue; } var pair = vars[i].split('='); if (pair.length < 2) { continue; } params[pair[0]] = pair[1]; } if (params.gid) { params.gid = parseInt(params.gid, 10); } return params; }; var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) { var pswpElement = document.querySelectorAll('.pswp')[0], gallery, options, items; items = parseThumbnailElements(galleryElement); // define options (if needed) options = { // define gallery index (for URL) galleryUID: galleryElement.getAttribute('data-pswp-uid'), getThumbBoundsFn: function getThumbBoundsFn(index) { // See Options -> getThumbBoundsFn section of documentation for more info var thumbnail = items[index].el.getElementsByTagName('img')[0], // find thumbnail pageYScroll = window.pageYOffset || document.documentElement.scrollTop, rect = thumbnail.getBoundingClientRect(); return { x: rect.left, y: rect.top + pageYScroll, w: rect.width }; } }; // PhotoSwipe opened from URL if (fromURL) { if (options.galleryPIDs) { // parse real index when custom PIDs are used // http://photoswipe.com/documentation/faq.html#custom-pid-in-url for (var j = 0; j < items.length; j++) { if (items[j].pid == index) { options.index = j; break; } } } else { // in URL indexes start from 1 options.index = parseInt(index, 10) - 1; } } else { options.index = parseInt(index, 10); } // exit if index not found if (isNaN(options.index)) { return; } if (disableAnimation) { options.showAnimationDuration = 0; } // Pass data to PhotoSwipe and initialize it gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options); gallery.init(); var $tempVideo; var stopVideoHandle = function stopVideoHandle() { if ($tempVideo) { $tempVideo.remove(); $tempVideo = null; } }; var changeHandle = function changeHandle() { var item = gallery.currItem; stopVideoHandle(); if (item.type === 'video') { var $ctn = item.container; var style = $ctn.getElementsByClassName('pswp__img')[0].style; var $video = document.createElement('video'); $video.setAttribute('autoplay', 'autoplay'); $video.setAttribute('controls', 'controls'); $video.setAttribute('src', item.target); $video.style.width = style.width; $video.style.height = style.height; $video.style.position = 'absolute'; $video.style.zIndex = 2; $tempVideo = $video; $ctn.appendChild($video); } }; gallery.listen('initialZoomIn', changeHandle); gallery.listen('afterChange', changeHandle); gallery.listen('initialZoomOut', stopVideoHandle); }; // loop through all gallery elements and bind events var galleryElements = document.querySelectorAll(gallerySelector); for (var i = 0, l = galleryElements.length; i < l; i++) { galleryElements[i].setAttribute('data-pswp-uid', i + 1); galleryElements[i].onclick = onThumbnailsClick; } // Parse URL and open gallery if it contains #&pid=3&gid=1 var hashData = photoswipeParseHash(); if (hashData.pid && hashData.gid) { openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true); } }; var Viewer = function() { function init() { initPhotoSwipeFromDOM('.photos'); } return { init: init }; }(); module.exports = Viewer; /***/ }, /* 3 */ /***/ function(module, exports) { /* WEBPACK VAR INJECTION */ (function(global) { module.exports = inViewport; var instances = []; var supportsMutationObserver = typeof global.MutationObserver === 'function'; function inViewport(elt, params, cb) { var opts = { container: global.document.body, offset: 0 }; if (params === undefined || typeof params === 'function') { cb = params; params = {}; } var container = opts.container = params.container || opts.container; var offset = opts.offset = params.offset || opts.offset; for (var i = 0; i < instances.length; i++) { if (instances[i].container === container) { return instances[i].isInViewport(elt, offset, cb); } } return instances[ instances.push(createInViewport(container)) - 1 ].isInViewport(elt, offset, cb); } function addEvent(el, type, fn) { if (el.attachEvent) { el.attachEvent('on' + type, fn); } else { el.addEventListener(type, fn, false); } } function debounce(func, wait, immediate) { var timeout; return function() { var context = this, args = arguments; var callNow = immediate && !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); function later() { timeout = null; if (!immediate) func.apply(context, args); } }; } // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708 var contains = function() { if (!global.document) { return true; } return global.document.documentElement.compareDocumentPosition ? function(a, b) { return !!(a.compareDocumentPosition(b) & 16); } : global.document.documentElement.contains ? function(a, b) { return a !== b && (a.contains ? a.contains(b) : false); } : function(a, b) { while (b = b.parentNode) { if (b === a) { return true; } } return false; }; } function createInViewport(container) { var watches = createWatches(); var scrollContainer = container === global.document.body ? global : container; var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15); addEvent(scrollContainer, 'scroll', debouncedCheck); if (scrollContainer === global) { addEvent(global, 'resize', debouncedCheck); } if (supportsMutationObserver) { observeDOM(watches, container, debouncedCheck); } // failsafe check, every 200ms we check for visible images // usecase: a hidden parent containing eleements // when the parent becomes visible, we have no event that the children // became visible setInterval(debouncedCheck, 150); function isInViewport(elt, offset, cb) { if (!cb) { return isVisible(elt, offset); } var remote = createRemote(elt, offset, cb); remote.watch(); return remote; } function createRemote(elt, offset, cb) { function watch() { watches.add(elt, offset, cb); } function dispose() { watches.remove(elt); } return { watch: watch, dispose: dispose }; } function watchInViewport(elt, offset, cb) { if (isVisible(elt, offset)) { watches.remove(elt); cb(elt); } } function isVisible(elt, offset) { if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) { return false; } // Check if the element is visible // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js if (!elt.offsetWidth || !elt.offsetHeight) { return false; } var eltRect = elt.getBoundingClientRect(); var viewport = {}; if (container === global.document.body) { viewport = { top: -offset, left: -offset, right: global.document.documentElement.clientWidth + offset, bottom: global.document.documentElement.clientHeight + offset }; } else { var containerRect = container.getBoundingClientRect(); viewport = { top: containerRect.top - offset, left: containerRect.left - offset, right: containerRect.right + offset, bottom: containerRect.bottom + offset }; } // The element must overlap with the visible part of the viewport var visible = ( (eltRect.right > viewport.left) && (eltRect.left < viewport.right) && (eltRect.bottom > viewport.top) && (eltRect.top < viewport.bottom) ); return visible; } return { container: container, isInViewport: isInViewport }; } function createWatches() { var watches = []; function add(elt, offset, cb) { if (!isWatched(elt)) { watches.push([elt, offset, cb]); } } function remove(elt) { var pos = indexOf(elt); if (pos !== -1) { watches.splice(pos, 1); } } function indexOf(elt) { for (var i = watches.length - 1; i >= 0; i--) { if (watches[i][0] === elt) { return i; } } return -1; } function isWatched(elt) { return indexOf(elt) !== -1; } function checkAll(cb) { return function() { for (var i = watches.length - 1; i >= 0; i--) { cb.apply(this, watches[i]); } }; } return { add: add, remove: remove, isWatched: isWatched, checkAll: checkAll }; } function observeDOM(watches, container, cb) { var observer = new MutationObserver(watch); var filter = Array.prototype.filter; var concat = Array.prototype.concat; observer.observe(container, { childList: true, subtree: true, // changes like style/width/height/display will be catched attributes: true }); function watch(mutations) { // some new DOM nodes where previously watched // we should check their positions if (mutations.some(knownNodes) === true) { setTimeout(cb, 0); } } function knownNodes(mutation) { var nodes = concat.call([], Array.prototype.slice.call(mutation.addedNodes), mutation.target ); return filter.call(nodes, watches.isWatched).length > 0; } } /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ } /******/ ]);"},{"title":"","date":"2021-02-18T08:39:30.230Z","updated":"2021-02-18T08:39:30.230Z","comments":true,"path":"photos/package.json","permalink":"http://ydl8686.github.io/photos/package.json","excerpt":"","text":"{\"name\":\"hexo-site\",\"version\":\"0.0.0\",\"private\":true,\"hexo\":{\"version\":\"3.2.2\"},\"dependencies\":{\"hexo\":\"^3.1.0\",\"hexo-deployer-git\":\"0.0.4\",\"hexo-deployer-rsync\":\"^0.1.2\",\"hexo-generator-archive\":\"^0.1.3\",\"hexo-generator-baidu-sitemap\":\"^0.1.2\",\"hexo-generator-category\":\"^0.1.3\",\"hexo-generator-feed\":\"^1.2.0\",\"hexo-generator-index\":\"^0.1.3\",\"hexo-generator-json-content\":\"^3.0.1\",\"hexo-generator-json-feed\":\"^1.0.0\",\"hexo-generator-sitemap\":\"^1.1.2\",\"hexo-generator-tag\":\"^0.1.2\",\"hexo-helper-qrcode\":\"^1.0.1\",\"hexo-renderer-ejs\":\"^0.1.0\",\"hexo-renderer-marked\":\"^0.2.5\",\"hexo-renderer-stylus\":\"^0.2.3\",\"hexo-server\":\"^0.1.2\"}}"},{"title":"","date":"2021-02-18T08:39:30.230Z","updated":"2021-02-18T08:39:30.230Z","comments":true,"path":"photos/lazyload.min.js","permalink":"http://ydl8686.github.io/photos/lazyload.min.js","excerpt":"","text":"/*! * An jQuery | zepto plugin for lazy loading images. * author -> jieyou * see https://github.com/jieyou/lazyload * use some tuupola's code https://github.com/tuupola/jquery_lazyload (BSD) * use component's throttle https://github.com/component/throttle (MIT) */ !function(a){\"function\"==typeof define&&define.amd?define([\"jquery\"],a):a(window.jQuery||window.Zepto)}(function(a){function g(){}function h(a,b){var e;return e=b._$container==d?(\"innerHeight\"in c?c.innerHeight:d.height())+d.scrollTop():b._$container.offset().top+b._$container.height(),e=b.offset().left+e.threshold+b.width()}function l(a,b){var c=0;a.each(function(d){function g(){f.trigger(\"_lazyload_appear\"),c=0}var f=a.eq(d);if(!(f.width()b.failure_limit)return!1}else g()})}function m(a){return a.filter(function(b){return!a.eq(b)._lazyload_loadStarted})}function n(a,b){function h(){f=0,g=+new Date,e=a.apply(c,d),c=null,d=null}var c,d,e,f,g=0;return function(){c=this,d=arguments;var a=new Date-g;return f||(a>=b?h():f=setTimeout(h,b-a)),e}}var f,c=window,d=a(c),e={threshold:0,failure_limit:0,event:\"scroll\",effect:\"show\",effect_params:null,container:c,data_attribute:\"original\",data_srcset_attribute:\"original-srcset\",skip_invisible:!0,appear:g,load:g,vertical_only:!1,check_appear_throttle_time:300,url_rewriter_fn:g,no_fake_img_loader:!1,placeholder_data_img:\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC\",placeholder_real_img:\"http://ditu.baidu.cn/yyfm/lazyload/0.0.1/img/placeholder.png\"};f=function(){var a=Object.prototype.toString;return function(b){return a.call(b).replace(\"[object \",\"\").replace(\"]\",\"\")}}(),a.fn.hasOwnProperty(\"lazyload\")||(a.fn.lazyload=function(b){var i,j,k,h=this;return a.isPlainObject(b)||(b={}),a.each(e,function(g,h){var i=f(b[g]);-1!=a.inArray(g,[\"threshold\",\"failure_limit\",\"check_appear_throttle_time\"])?\"String\"==i?b[g]=parseInt(b[g],10):\"Number\"!=i&&(b[g]=h):\"container\"==g?(b._$container=b.hasOwnProperty(g)?b[g]==c||b[g]==document?d:a(b[g]):d,delete b.container):!e.hasOwnProperty(g)||b.hasOwnProperty(g)&&i==f(e[g])||(b[g]=h)}),i=\"scroll\"==b.event,k=0==b.check_appear_throttle_time?l:n(l,b.check_appear_throttle_time),j=i||\"scrollstart\"==b.event||\"scrollstop\"==b.event,h.each(function(c){var e=this,f=h.eq(c),i=f.attr(\"src\"),k=f.attr(\"data-\"+b.data_attribute),l=b.url_rewriter_fn==g?k:b.url_rewriter_fn.call(e,f,k),n=f.attr(\"data-\"+b.data_srcset_attribute),o=f.is(\"img\");return 1==f._lazyload_loadStarted||i==l?(f._lazyload_loadStarted=!0,h=m(h),void 0):(f._lazyload_loadStarted=!1,o&&!i&&f.one(\"error\",function(){f.attr(\"src\",b.placeholder_real_img)}).attr(\"src\",b.placeholder_data_img),f.one(\"_lazyload_appear\",function(){function i(){d&&f.hide(),o?(n&&f.attr(\"srcset\",n),l&&f.attr(\"src\",l)):f.css(\"background-image\",'url(\"'+l+'\")'),d&&f[b.effect].apply(f,c?b.effect_params:[]),h=m(h)}var d,c=a.isArray(b.effect_params);f._lazyload_loadStarted||(d=\"show\"!=b.effect&&a.fn[b.effect]&&(!b.effect_params||c&&0==b.effect_params.length),b.appear!=g&&b.appear.call(e,f,h.length,b),f._lazyload_loadStarted=!0,b.no_fake_img_loader||n?(b.load!=g&&f.one(\"load\",function(){b.load.call(e,f,h.length,b)}),i()):a(\"\").one(\"load\",function(){i(),b.load!=g&&b.load.call(e,f,h.length,b)}).attr(\"src\",l))}),j||f.on(b.event,function(){f._lazyload_loadStarted||f.trigger(\"_lazyload_appear\")}),void 0)}),j&&b._$container.on(b.event,function(){k(h,b)}),d.on(\"resize load\",function(){k(h,b)}),a(function(){k(h,b)}),this})});"},{"title":"Tags","date":"2021-05-06T12:20:17.865Z","updated":"2021-05-06T12:20:17.865Z","comments":true,"path":"tags/index.html","permalink":"http://ydl8686.github.io/tags/index.html","excerpt":"","text":""},{"title":"Project","date":"2021-05-06T12:20:17.863Z","updated":"2021-05-06T12:20:17.863Z","comments":true,"path":"project/index.html","permalink":"http://ydl8686.github.io/project/index.html","excerpt":"","text":""},{"title":"","date":"2021-02-18T11:21:06.931Z","updated":"2021-02-18T11:21:06.931Z","comments":true,"path":"photos/README.html","permalink":"http://ydl8686.github.io/photos/README.html","excerpt":"","text":"Blog-Back-Up存储博客照片"}],"posts":[{"title":"2021总结","slug":"2021总结","date":"2022-01-31T07:24:43.000Z","updated":"2022-01-31T08:01:58.334Z","comments":true,"path":"2022/01/31/2021总结/","link":"","permalink":"http://ydl8686.github.io/2022/01/31/2021%E6%80%BB%E7%BB%93/","excerpt":"","text":"总结今天是除夕，农历2021年的最后一天，总觉得要写点什么记下这一年发生的重要的事情，才不至于浑浑噩噩一年一年麻木的过去。 2021年经历了很多事情，包括升学、工作、生活上的，虽然当时可能不觉得，但现在看来也确确实实对我产生了影响，所以总结了下面几件对我意义重大的事情。 实习应该算是从小到大以来第一次脱离了“学校”这个氛围，去打工，去接触社会。我现在都还能记得，当初既要忙保研课程，另一面又各种疯狂地约面试；偏偏那段时间感情上还不太顺利，总是喜欢偷懒然后一个人去玄武湖瞎逛，给大伟打电话，给爸妈打电话等，然后逛到很晚回宿舍，准备下次的面试。准备得也不够充分，面试总是碰壁，不过好在及时总结教训，专业知识上的、面试技巧上的，然后非常幸运地拿到了腾讯的实习offer。 我实习的团队真是太棒了！无论是氛围上的，还是专业知识上的，都给了我很大的学习空间；在深圳一个人实习的日子，也锻炼了我的自理能力，如果还有机会去实习的话，我相信我一定能做得更好；回想起当初在深圳熬夜的日子，真的是后悔莫及，我应该抓紧机会，多在企业里学习知识，锻炼自己的能力才对。悟以往之不谏，知来者之可追；以后要做的很好才行！ 保研在深圳的时候，其实有段时间非常焦虑，因为不清楚软件设计会不会挂科；如果挂科了的话就得直接工作，然后参加实习生转正答辩，突然节奏就变得紧张起来；不过还好，最后只是虚惊一场，保研名额70+，我是40多名，勉勉强强。不过保研也导致了我大四上一直在摆烂，天天在宿舍里面荒度时光，当时想的是“只有大四上能够放松一下了，之后就要去实习没时间了”，不过我也不后悔，因为后悔也没有用，而且当时确实也玩得很爽；所以现在要多努力些，好好准备实习，不能一直摆烂。反正，不要做让自己后悔的事情就是了。 自立寒假在家一个月左右的时间，我深刻地意识到，我和我父母有着完全不一样的观念，家庭、工作、知识、时代等环境塑造了每个人不同的观念看法，在很多方面都是这样的，例如看待亲子关系、帮忙干活、拿小太阳取暖等等；我一直认为观念这种东西是很难去改变的，无法强求别人的观念一定要与自己一致，所以我很少会费口舌去向别人输出我的观念，因为都是徒劳而已。一段关系应该是求同存异，做家人是这样的，当朋友也是这样的；如果一定要求我的观念和别人的一致，那我倒不如敬而远之，做好自己就可以了。 我真的迫切希望我赶快经济独立，能够自己过好自己的生活，然后在保持适当的距离下和父母沟通，才是最好的状态，所以要好好准备专业技能，找到一份好的实习。 展望我希望我新的一年里能够 学日语（到考级的程度） 提高自己的自立自理能力（指研究生期间照顾好自己） 提高专业技能水平，多涨知识少玩手机（就决定做前端了！） 加油⛽️！","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://ydl8686.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"剑指offer算法","slug":"剑指offer算法","date":"2022-01-17T08:50:36.000Z","updated":"2022-08-22T14:32:56.100Z","comments":true,"path":"2022/01/17/剑指offer算法/","link":"","permalink":"http://ydl8686.github.io/2022/01/17/%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95/","excerpt":"","text":"03 数组中重复的数字 解法1使用数据结构Set，利用其不会储存相同元素的特性来解决，不断往里面添加元素，看看Set大小有没有变，没变说明添加的就是重复的元素 var findRepeatNumber = function(nums) &#123; let mySet = new Set(); let size = mySet.size; let result = -1; nums.some(e =&gt; &#123; mySet.add(e); if(mySet.size === size) &#123; result = e; return true; &#125; size+=1; &#125;) return result;&#125;; 需要注意的是，在遍历数组nums的时候，不能采用forEach里return结果的方式，因为这样并不会跳出循环，break也是一样的；可以使用some和every方法来实现可跳出的循环，前者return true时跳出，后者return false跳出 解法2可以使用原地交换的方式，因为题目中说长度为n的数组，元素大小在[0,n-1]，有重复元素，那么在建立索引和值的对应关系上，一定会出现某个索引对应了两个值的情况，该值就是重复的元素 var findRepeatNumber = function(nums) &#123; let i=0; while(true)&#123; if(nums[i] !== i)&#123; /*防止出现1，1，1的情况*/ if(nums[nums[i]] === nums[i])&#123; return nums[i]; &#125; /*交换*/ [nums[nums[i]], nums[i]] =[nums[i], nums[nums[i]]]; &#125; else &#123; i++; &#125; &#125;&#125;; 04 二维数组中的查找 因为每行、每列都是递增顺序排列的，所以可以从右上角开始，如果当前数组中的数比target大，那么往左移；小，那么往下移；终止循环的条件是索引越界 var findNumberIn2DArray = function(matrix, target) &#123; let i = 0; let j = matrix[0].length-1; while(true) &#123; if(i&gt;matrix.length-1 || j&lt;0) &#123; return false; &#125; if(target === matrix[i][j]) &#123; return true; &#125; if(matrix[i][j] &gt; target) &#123; j--; &#125; else if(matrix[i][j] &lt; target) &#123; i++; &#125; &#125;&#125;; 05 替换空格 使用js的常用API就可以解决 // 法一var replaceSpace = function(s) &#123; return s.split(&#x27; &#x27;).join(&#x27;%20&#x27;);&#125;;// 法二var replaceSpace = function(s) &#123; // 必须要有g，不然只会替换第一个 return s.replace(/\\s/g, &#x27;%20&#x27;);&#125;; str.replace(/^\\s+|\\s+$/g, &#39;haloha&#39;)\\s : 表示 space ，空格+： 一个或多个^： 开始，^\\s，以空格开始$： 结束，\\s$，以空格结束|： 或者/g：global， 全局 06 从尾到头打印链表 先顺序遍历，把结果放到数组里，再reverse一下；或者使用unshift() /** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;number[]&#125; */// 法一var reversePrint = function(head) &#123; let result = []; while(head) &#123; result.push(head.val); head = head.next; &#125; result.reverse(); return result;&#125;;// 法二var reversePrint = function(head) &#123; let result = []; while(head) &#123; /*在数组首位置添加元素*/ result.unshift(head.val); head = head.next; &#125; return result;&#125;; 07 重建二叉树 核心是递归，根据preorder里的第一个元素，可以把inorder划分成左子树和右子树，再根据inoder里子树的大小，将preorder里划分成左子树和右子树，然后对应的进行递归操作即可 /** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; *//** * @param &#123;number[]&#125; preorder * @param &#123;number[]&#125; inorder * @return &#123;TreeNode&#125; */var buildTree = function(preorder, inorder) &#123; let result = new TreeNode(preorder[0]); // 特殊情况 // if(preorder.length === 1)&#123; // return result; // &#125; // else if(preorder.length === 0)&#123; // return null; // &#125; let index = inorder.indexOf(preorder[0]); result.left = buildTree(preorder.slice(1, 1+index), inorder.slice(0, index)); result.right = buildTree(preorder.slice(1+index), inorder.slice(index+1)); return result;&#125;; 10 斐波那契数列 解法1（动态规划）使用最简单的递归方法，，果然超时了，函数的入栈出栈的时间成本还是太高了，所以用了最简单的迭代，不过空间复杂度是O(N)，比较占用内存 var fib = function(n) &#123; if(n === 0 || n === 1) &#123; return n; &#125; let arr = [0, 1]; for(let i=2; i&lt;=n; i++) &#123; arr[i] = (arr[i-1] + arr[i-2])%1000000007; &#125; return arr[n];&#125;;// 还可以继续优化，因为n只与n-1，n-2有关，所以可以将空间复杂度降至O（1） 解法2使用递归的同时，再开辟一个新的数组用来存储已经算过的项，避免重复；例如算n-1和n-2这两项的时候都会用到第n-3项。所以在使用某一项的时候先看看这个数组里面有没有值，没有值再递归计算赋值 不过这样时间复杂度和空间复杂度都好高啊，还是使用动态规划最好 青蛙跳台阶也可以转换成类似的想法，关键是得到f(n)=f(n-1)+f(n-2)这个不变式 11 旋转数组的最小数字 解法1线性遍历数组，发现后一个比前一个小，那么后一个就是答案；如果遍历完都没找到就说明这个数组是升序排列，返回第一个就好；时间复杂度O（N） var minArray = function(numbers) &#123; for(let i=0;i&lt;numbers.length-1;i++)&#123; if(numbers[i+1] &lt; numbers[i])&#123; return numbers[i+1]; &#125; &#125; return numbers[0]&#125;; 50 第一个只出现一次的字符 解法1用两个数组来解决这个问题，一个数组用来存储遍历过的字符，一个数组用来存储已经重复过的的字符；遍历时遇到的字符在这两个数组内都没有出现时，进入第一个数组；如果在第一个数组中出现了，那么从第一个数组中剔除，并加入第二个数组；其余情况都不用考虑 不过好像其实也没有降低时间复杂度，因为使用到了indexOf来查找重复字符的索引，如果让自己来实现的话，又是O(N)的复杂度，综合下来还是O(N2)时间复杂度 var firstUniqChar = function(s) &#123; if(!s)&#123; return &#x27; &#x27;; &#125; let temp = []; let dupTemp = []; for(let i=0;i&lt;s.length;i++)&#123; if(dupTemp.indexOf(s[i]) === -1 &amp;&amp; temp.indexOf(s[i]) === -1)&#123; temp.push(s[i]); &#125; else if(temp.indexOf(s[i]) !== -1)&#123; temp.splice(temp.indexOf(s[i]), 1); dupTemp.push(s[i]); &#125; &#125; return temp[0]?temp[0]:&#x27; &#x27;;&#125;; 解法2使用map来解决；需要注意到的是，map对象是乱序的；但是按照key,value的形式来遍历时，是按照插入的顺序进行的 var firstUniqChar = function(s) &#123; var map = new Map(); for(let i=0;i&lt;s.length;i++)&#123; var cur = s.charAt(i); if(map.has(cur))&#123; // 如果已经出现过这个字符，那么设为false map.set(cur,false); &#125; else &#123; // 第一次遇到设置成true map.set(cur,true); &#125; &#125; for([key,value] of map)&#123; if(value)&#123; return key; &#125; &#125; return &#x27; &#x27;&#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://ydl8686.github.io/tags/%E7%AE%97%E6%B3%95/"}]}],"categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://ydl8686.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"算法","slug":"算法","permalink":"http://ydl8686.github.io/tags/%E7%AE%97%E6%B3%95/"}]}